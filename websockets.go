// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mavenagi/mavenagi-go/internal"
	big "math/big"
)

// Audio chunk to send into the conversation.
var (
	agentAudioChunkFieldEventID = big.NewInt(1 << 0)
	agentAudioChunkFieldData    = big.NewInt(1 << 1)
)

type AgentAudioChunk struct {
	EventID string `json:"eventId" url:"eventId"`
	// Base64-encoded AI audio data
	Data string `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AgentAudioChunk) GetEventID() string {
	if a == nil {
		return ""
	}
	return a.EventID
}

func (a *AgentAudioChunk) GetData() string {
	if a == nil {
		return ""
	}
	return a.Data
}

func (a *AgentAudioChunk) Type() string {
	return a.type_
}

func (a *AgentAudioChunk) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentAudioChunk) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetEventID sets the EventID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentAudioChunk) SetEventID(eventID string) {
	a.EventID = eventID
	a.require(agentAudioChunkFieldEventID)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentAudioChunk) SetData(data string) {
	a.Data = data
	a.require(agentAudioChunkFieldData)
}

func (a *AgentAudioChunk) UnmarshalJSON(data []byte) error {
	type embed AgentAudioChunk
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AgentAudioChunk(unmarshaler.embed)
	if unmarshaler.Type != "agent_audio_chunk" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "agent_audio_chunk", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentAudioChunk) MarshalJSON() ([]byte, error) {
	type embed AgentAudioChunk
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "agent_audio_chunk",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AgentAudioChunk) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Transcribed agent speech
var (
	agentTranscriptFieldEventID = big.NewInt(1 << 0)
	agentTranscriptFieldText    = big.NewInt(1 << 1)
)

type AgentTranscript struct {
	EventID string `json:"eventId" url:"eventId"`
	// Transcribed agent speech
	Text string `json:"text" url:"text"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AgentTranscript) GetEventID() string {
	if a == nil {
		return ""
	}
	return a.EventID
}

func (a *AgentTranscript) GetText() string {
	if a == nil {
		return ""
	}
	return a.Text
}

func (a *AgentTranscript) Type() string {
	return a.type_
}

func (a *AgentTranscript) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentTranscript) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetEventID sets the EventID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentTranscript) SetEventID(eventID string) {
	a.EventID = eventID
	a.require(agentTranscriptFieldEventID)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentTranscript) SetText(text string) {
	a.Text = text
	a.require(agentTranscriptFieldText)
}

func (a *AgentTranscript) UnmarshalJSON(data []byte) error {
	type embed AgentTranscript
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*a = AgentTranscript(unmarshaler.embed)
	if unmarshaler.Type != "agent_transcript" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", a, "agent_transcript", unmarshaler.Type)
	}
	a.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *a, "type")
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentTranscript) MarshalJSON() ([]byte, error) {
	type embed AgentTranscript
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*a),
		Type:  "agent_transcript",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AgentTranscript) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AudioFormat string

const (
	AudioFormatPcm44100  AudioFormat = "PCM_44100"
	AudioFormatPcm16000  AudioFormat = "PCM_16000"
	AudioFormatPcm8000   AudioFormat = "PCM_8000"
	AudioFormatMulaw8000 AudioFormat = "MULAW_8000"
)

func NewAudioFormatFromString(s string) (AudioFormat, error) {
	switch s {
	case "PCM_44100":
		return AudioFormatPcm44100, nil
	case "PCM_16000":
		return AudioFormatPcm16000, nil
	case "PCM_8000":
		return AudioFormatPcm8000, nil
	case "MULAW_8000":
		return AudioFormatMulaw8000, nil
	}
	var t AudioFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AudioFormat) Ptr() *AudioFormat {
	return &a
}

// Initialize conversation with configuration parameters
var (
	configFieldInputFormat    = big.NewInt(1 << 0)
	configFieldOutputFormat   = big.NewInt(1 << 1)
	configFieldConversationID = big.NewInt(1 << 2)
	configFieldAppID          = big.NewInt(1 << 3)
)

type Config struct {
	// The user text to send into the conversation.
	InputFormat AudioFormat `json:"inputFormat" url:"inputFormat"`
	// The user text to send into the conversation.
	OutputFormat AudioFormat `json:"outputFormat" url:"outputFormat"`
	// The conversation ID which was created prior to starting this conversation.
	ConversationID string `json:"conversationId" url:"conversationId"`
	// The app ID this conversation ID is associated with.
	AppID string `json:"appId" url:"appId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *Config) GetInputFormat() AudioFormat {
	if c == nil {
		return ""
	}
	return c.InputFormat
}

func (c *Config) GetOutputFormat() AudioFormat {
	if c == nil {
		return ""
	}
	return c.OutputFormat
}

func (c *Config) GetConversationID() string {
	if c == nil {
		return ""
	}
	return c.ConversationID
}

func (c *Config) GetAppID() string {
	if c == nil {
		return ""
	}
	return c.AppID
}

func (c *Config) Type() string {
	return c.type_
}

func (c *Config) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *Config) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetInputFormat sets the InputFormat field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Config) SetInputFormat(inputFormat AudioFormat) {
	c.InputFormat = inputFormat
	c.require(configFieldInputFormat)
}

// SetOutputFormat sets the OutputFormat field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Config) SetOutputFormat(outputFormat AudioFormat) {
	c.OutputFormat = outputFormat
	c.require(configFieldOutputFormat)
}

// SetConversationID sets the ConversationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Config) SetConversationID(conversationID string) {
	c.ConversationID = conversationID
	c.require(configFieldConversationID)
}

// SetAppID sets the AppID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *Config) SetAppID(appID string) {
	c.AppID = appID
	c.require(configFieldAppID)
}

func (c *Config) UnmarshalJSON(data []byte) error {
	type embed Config
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Config(unmarshaler.embed)
	if unmarshaler.Type != "config" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "config", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *Config) MarshalJSON() ([]byte, error) {
	type embed Config
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "config",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *Config) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// AI ended the conversation
var (
	conversationEndedFieldEventID = big.NewInt(1 << 0)
)

type ConversationEnded struct {
	EventID string `json:"eventId" url:"eventId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationEnded) GetEventID() string {
	if c == nil {
		return ""
	}
	return c.EventID
}

func (c *ConversationEnded) Type() string {
	return c.type_
}

func (c *ConversationEnded) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationEnded) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetEventID sets the EventID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationEnded) SetEventID(eventID string) {
	c.EventID = eventID
	c.require(conversationEndedFieldEventID)
}

func (c *ConversationEnded) UnmarshalJSON(data []byte) error {
	type embed ConversationEnded
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationEnded(unmarshaler.embed)
	if unmarshaler.Type != "conversation_ended" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "conversation_ended", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationEnded) MarshalJSON() ([]byte, error) {
	type embed ConversationEnded
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "conversation_ended",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationEnded) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Conversation created successfully.
type ConversationReady struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationReady) Type() string {
	return c.type_
}

func (c *ConversationReady) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationReady) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

func (c *ConversationReady) UnmarshalJSON(data []byte) error {
	type embed ConversationReady
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationReady(unmarshaler.embed)
	if unmarshaler.Type != "conversation_ready" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", c, "conversation_ready", unmarshaler.Type)
	}
	c.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *c, "type")
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationReady) MarshalJSON() ([]byte, error) {
	type embed ConversationReady
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*c),
		Type:  "conversation_ready",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationReady) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Error occurred during conversation
var (
	errorFieldEventID = big.NewInt(1 << 0)
	errorFieldMessage = big.NewInt(1 << 1)
	errorFieldCode    = big.NewInt(1 << 2)
)

type Error struct {
	EventID string `json:"eventId" url:"eventId"`
	Message string `json:"message" url:"message"`
	Code    string `json:"code" url:"code"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *Error) GetEventID() string {
	if e == nil {
		return ""
	}
	return e.EventID
}

func (e *Error) GetMessage() string {
	if e == nil {
		return ""
	}
	return e.Message
}

func (e *Error) GetCode() string {
	if e == nil {
		return ""
	}
	return e.Code
}

func (e *Error) Type() string {
	return e.type_
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEventID sets the EventID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Error) SetEventID(eventID string) {
	e.EventID = eventID
	e.require(errorFieldEventID)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Error) SetMessage(message string) {
	e.Message = message
	e.require(errorFieldMessage)
}

// SetCode sets the Code field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *Error) SetCode(code string) {
	e.Code = code
	e.require(errorFieldCode)
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type embed Error
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = Error(unmarshaler.embed)
	if unmarshaler.Type != "error" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", e, "error", unmarshaler.Type)
	}
	e.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *e, "type")
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) MarshalJSON() ([]byte, error) {
	type embed Error
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*e),
		Type:  "error",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *Error) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Base event type for all server events.
var (
	serverEventBaseFieldEventID = big.NewInt(1 << 0)
)

type ServerEventBase struct {
	EventID string `json:"eventId" url:"eventId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ServerEventBase) GetEventID() string {
	if s == nil {
		return ""
	}
	return s.EventID
}

func (s *ServerEventBase) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ServerEventBase) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetEventID sets the EventID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ServerEventBase) SetEventID(eventID string) {
	s.EventID = eventID
	s.require(serverEventBaseFieldEventID)
}

func (s *ServerEventBase) UnmarshalJSON(data []byte) error {
	type unmarshaler ServerEventBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ServerEventBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ServerEventBase) MarshalJSON() ([]byte, error) {
	type embed ServerEventBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *ServerEventBase) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Audio chunk to send into the conversation.
var (
	userAudioChunkFieldData = big.NewInt(1 << 0)
)

type UserAudioChunk struct {
	// Base64-encoded AI audio data
	Data string `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserAudioChunk) GetData() string {
	if u == nil {
		return ""
	}
	return u.Data
}

func (u *UserAudioChunk) Type() string {
	return u.type_
}

func (u *UserAudioChunk) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserAudioChunk) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserAudioChunk) SetData(data string) {
	u.Data = data
	u.require(userAudioChunkFieldData)
}

func (u *UserAudioChunk) UnmarshalJSON(data []byte) error {
	type embed UserAudioChunk
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserAudioChunk(unmarshaler.embed)
	if unmarshaler.Type != "user_audio_chunk" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "user_audio_chunk", unmarshaler.Type)
	}
	u.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *u, "type")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserAudioChunk) MarshalJSON() ([]byte, error) {
	type embed UserAudioChunk
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "user_audio_chunk",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserAudioChunk) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// User finished speaking
var (
	userFinishedSpeakingFieldEventID = big.NewInt(1 << 0)
)

type UserFinishedSpeaking struct {
	EventID string `json:"eventId" url:"eventId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserFinishedSpeaking) GetEventID() string {
	if u == nil {
		return ""
	}
	return u.EventID
}

func (u *UserFinishedSpeaking) Type() string {
	return u.type_
}

func (u *UserFinishedSpeaking) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserFinishedSpeaking) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetEventID sets the EventID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserFinishedSpeaking) SetEventID(eventID string) {
	u.EventID = eventID
	u.require(userFinishedSpeakingFieldEventID)
}

func (u *UserFinishedSpeaking) UnmarshalJSON(data []byte) error {
	type embed UserFinishedSpeaking
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserFinishedSpeaking(unmarshaler.embed)
	if unmarshaler.Type != "user_finished_speaking" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "user_finished_speaking", unmarshaler.Type)
	}
	u.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *u, "type")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserFinishedSpeaking) MarshalJSON() ([]byte, error) {
	type embed UserFinishedSpeaking
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "user_finished_speaking",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserFinishedSpeaking) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// User started speaking
var (
	userStartedSpeakingFieldEventID = big.NewInt(1 << 0)
)

type UserStartedSpeaking struct {
	EventID string `json:"eventId" url:"eventId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserStartedSpeaking) GetEventID() string {
	if u == nil {
		return ""
	}
	return u.EventID
}

func (u *UserStartedSpeaking) Type() string {
	return u.type_
}

func (u *UserStartedSpeaking) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserStartedSpeaking) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetEventID sets the EventID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserStartedSpeaking) SetEventID(eventID string) {
	u.EventID = eventID
	u.require(userStartedSpeakingFieldEventID)
}

func (u *UserStartedSpeaking) UnmarshalJSON(data []byte) error {
	type embed UserStartedSpeaking
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserStartedSpeaking(unmarshaler.embed)
	if unmarshaler.Type != "user_started_speaking" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "user_started_speaking", unmarshaler.Type)
	}
	u.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *u, "type")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserStartedSpeaking) MarshalJSON() ([]byte, error) {
	type embed UserStartedSpeaking
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "user_started_speaking",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserStartedSpeaking) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// Transcribed user speech
var (
	userTranscriptFieldEventID = big.NewInt(1 << 0)
	userTranscriptFieldText    = big.NewInt(1 << 1)
)

type UserTranscript struct {
	EventID string `json:"eventId" url:"eventId"`
	// Transcribed user speech
	Text string `json:"text" url:"text"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
	type_          string

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserTranscript) GetEventID() string {
	if u == nil {
		return ""
	}
	return u.EventID
}

func (u *UserTranscript) GetText() string {
	if u == nil {
		return ""
	}
	return u.Text
}

func (u *UserTranscript) Type() string {
	return u.type_
}

func (u *UserTranscript) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserTranscript) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetEventID sets the EventID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserTranscript) SetEventID(eventID string) {
	u.EventID = eventID
	u.require(userTranscriptFieldEventID)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserTranscript) SetText(text string) {
	u.Text = text
	u.require(userTranscriptFieldText)
}

func (u *UserTranscript) UnmarshalJSON(data []byte) error {
	type embed UserTranscript
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserTranscript(unmarshaler.embed)
	if unmarshaler.Type != "user_transcript" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", u, "user_transcript", unmarshaler.Type)
	}
	u.type_ = unmarshaler.Type
	extraProperties, err := internal.ExtractExtraProperties(data, *u, "type")
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserTranscript) MarshalJSON() ([]byte, error) {
	type embed UserTranscript
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*u),
		Type:  "user_transcript",
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserTranscript) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
