// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mavenagi/mavenagi-go/internal"
	big "math/big"
)

var (
	segmentGetRequestFieldAppID = big.NewInt(1 << 0)
)

type SegmentGetRequest struct {
	// The App ID of the segment to get. If not provided, the ID of the calling app will be used.
	AppID *string `json:"-" url:"appId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SegmentGetRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetAppID sets the AppID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentGetRequest) SetAppID(appID *string) {
	s.AppID = appID
	s.require(segmentGetRequestFieldAppID)
}

var (
	segmentBaseFieldName         = big.NewInt(1 << 0)
	segmentBaseFieldPrecondition = big.NewInt(1 << 1)
)

type SegmentBase struct {
	// The name of the segment.
	Name string `json:"name" url:"name"`
	// The precondition that must be met for a conversation message to be included in the segment.
	Precondition *Precondition `json:"precondition" url:"precondition"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SegmentBase) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SegmentBase) GetPrecondition() *Precondition {
	if s == nil {
		return nil
	}
	return s.Precondition
}

func (s *SegmentBase) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SegmentBase) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentBase) SetName(name string) {
	s.Name = name
	s.require(segmentBaseFieldName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentBase) SetPrecondition(precondition *Precondition) {
	s.Precondition = precondition
	s.require(segmentBaseFieldPrecondition)
}

func (s *SegmentBase) UnmarshalJSON(data []byte) error {
	type unmarshaler SegmentBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SegmentBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SegmentBase) MarshalJSON() ([]byte, error) {
	type embed SegmentBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SegmentBase) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SegmentField string

const (
	SegmentFieldCreatedAt SegmentField = "CreatedAt"
	SegmentFieldName      SegmentField = "Name"
)

func NewSegmentFieldFromString(s string) (SegmentField, error) {
	switch s {
	case "CreatedAt":
		return SegmentFieldCreatedAt, nil
	case "Name":
		return SegmentFieldName, nil
	}
	var t SegmentField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SegmentField) Ptr() *SegmentField {
	return &s
}

var (
	segmentPatchRequestFieldAppID        = big.NewInt(1 << 0)
	segmentPatchRequestFieldName         = big.NewInt(1 << 1)
	segmentPatchRequestFieldPrecondition = big.NewInt(1 << 2)
	segmentPatchRequestFieldStatus       = big.NewInt(1 << 3)
)

type SegmentPatchRequest struct {
	// The App ID of the segment to update. If not provided, the ID of the calling app will be used.
	AppID *string `json:"appId,omitempty" url:"appId,omitempty"`
	// The name of the segment.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The precondition that must be met for a conversation message to be included in the segment.
	Precondition *Precondition `json:"precondition,omitempty" url:"precondition,omitempty"`
	// The status of the segment. Segments can only be deactivated if they are not set on any actions or active knowledge bases.
	Status *SegmentStatus `json:"status,omitempty" url:"status,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SegmentPatchRequest) GetAppID() *string {
	if s == nil {
		return nil
	}
	return s.AppID
}

func (s *SegmentPatchRequest) GetName() *string {
	if s == nil {
		return nil
	}
	return s.Name
}

func (s *SegmentPatchRequest) GetPrecondition() *Precondition {
	if s == nil {
		return nil
	}
	return s.Precondition
}

func (s *SegmentPatchRequest) GetStatus() *SegmentStatus {
	if s == nil {
		return nil
	}
	return s.Status
}

func (s *SegmentPatchRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SegmentPatchRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetAppID sets the AppID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentPatchRequest) SetAppID(appID *string) {
	s.AppID = appID
	s.require(segmentPatchRequestFieldAppID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentPatchRequest) SetName(name *string) {
	s.Name = name
	s.require(segmentPatchRequestFieldName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentPatchRequest) SetPrecondition(precondition *Precondition) {
	s.Precondition = precondition
	s.require(segmentPatchRequestFieldPrecondition)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentPatchRequest) SetStatus(status *SegmentStatus) {
	s.Status = status
	s.require(segmentPatchRequestFieldStatus)
}

func (s *SegmentPatchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SegmentPatchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SegmentPatchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SegmentPatchRequest) MarshalJSON() ([]byte, error) {
	type embed SegmentPatchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SegmentPatchRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	segmentRequestFieldName         = big.NewInt(1 << 0)
	segmentRequestFieldPrecondition = big.NewInt(1 << 1)
	segmentRequestFieldSegmentID    = big.NewInt(1 << 2)
)

type SegmentRequest struct {
	// The name of the segment.
	Name string `json:"name" url:"name"`
	// The precondition that must be met for a conversation message to be included in the segment.
	Precondition *Precondition `json:"precondition" url:"precondition"`
	// ID that uniquely identifies this segment
	SegmentID *EntityIDBase `json:"segmentId" url:"segmentId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SegmentRequest) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SegmentRequest) GetPrecondition() *Precondition {
	if s == nil {
		return nil
	}
	return s.Precondition
}

func (s *SegmentRequest) GetSegmentID() *EntityIDBase {
	if s == nil {
		return nil
	}
	return s.SegmentID
}

func (s *SegmentRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SegmentRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentRequest) SetName(name string) {
	s.Name = name
	s.require(segmentRequestFieldName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentRequest) SetPrecondition(precondition *Precondition) {
	s.Precondition = precondition
	s.require(segmentRequestFieldPrecondition)
}

// SetSegmentID sets the SegmentID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentRequest) SetSegmentID(segmentID *EntityIDBase) {
	s.SegmentID = segmentID
	s.require(segmentRequestFieldSegmentID)
}

func (s *SegmentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SegmentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SegmentRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SegmentRequest) MarshalJSON() ([]byte, error) {
	type embed SegmentRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SegmentRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	segmentResponseFieldName         = big.NewInt(1 << 0)
	segmentResponseFieldPrecondition = big.NewInt(1 << 1)
	segmentResponseFieldSegmentID    = big.NewInt(1 << 2)
	segmentResponseFieldStatus       = big.NewInt(1 << 3)
)

type SegmentResponse struct {
	// The name of the segment.
	Name string `json:"name" url:"name"`
	// The precondition that must be met for a conversation message to be included in the segment.
	Precondition *Precondition `json:"precondition" url:"precondition"`
	// ID that uniquely identifies this segment
	SegmentID *EntityID `json:"segmentId" url:"segmentId"`
	// Whether or not the segment is in active use. To preserve historical data, segments can not be deleted.
	//
	// Only active segments will be evaluated for matching user questions.
	Status SegmentStatus `json:"status" url:"status"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SegmentResponse) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *SegmentResponse) GetPrecondition() *Precondition {
	if s == nil {
		return nil
	}
	return s.Precondition
}

func (s *SegmentResponse) GetSegmentID() *EntityID {
	if s == nil {
		return nil
	}
	return s.SegmentID
}

func (s *SegmentResponse) GetStatus() SegmentStatus {
	if s == nil {
		return ""
	}
	return s.Status
}

func (s *SegmentResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SegmentResponse) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentResponse) SetName(name string) {
	s.Name = name
	s.require(segmentResponseFieldName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentResponse) SetPrecondition(precondition *Precondition) {
	s.Precondition = precondition
	s.require(segmentResponseFieldPrecondition)
}

// SetSegmentID sets the SegmentID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentResponse) SetSegmentID(segmentID *EntityID) {
	s.SegmentID = segmentID
	s.require(segmentResponseFieldSegmentID)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentResponse) SetStatus(status SegmentStatus) {
	s.Status = status
	s.require(segmentResponseFieldStatus)
}

func (s *SegmentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SegmentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SegmentResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SegmentResponse) MarshalJSON() ([]byte, error) {
	type embed SegmentResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SegmentResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SegmentStatus string

const (
	SegmentStatusActive   SegmentStatus = "ACTIVE"
	SegmentStatusInactive SegmentStatus = "INACTIVE"
)

func NewSegmentStatusFromString(s string) (SegmentStatus, error) {
	switch s {
	case "ACTIVE":
		return SegmentStatusActive, nil
	case "INACTIVE":
		return SegmentStatusInactive, nil
	}
	var t SegmentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SegmentStatus) Ptr() *SegmentStatus {
	return &s
}

var (
	segmentsSearchRequestFieldPage     = big.NewInt(1 << 0)
	segmentsSearchRequestFieldSize     = big.NewInt(1 << 1)
	segmentsSearchRequestFieldSortDesc = big.NewInt(1 << 2)
	segmentsSearchRequestFieldSort     = big.NewInt(1 << 3)
)

type SegmentsSearchRequest struct {
	// Page number to return, defaults to 0
	Page *int `json:"page,omitempty" url:"page,omitempty"`
	// The size of the page to return, defaults to 20
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Whether to sort descending, defaults to true
	SortDesc *bool `json:"sortDesc,omitempty" url:"sortDesc,omitempty"`
	// The field to sort by, defaults to created timestamp
	Sort *SegmentField `json:"sort,omitempty" url:"sort,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SegmentsSearchRequest) GetPage() *int {
	if s == nil {
		return nil
	}
	return s.Page
}

func (s *SegmentsSearchRequest) GetSize() *int {
	if s == nil {
		return nil
	}
	return s.Size
}

func (s *SegmentsSearchRequest) GetSortDesc() *bool {
	if s == nil {
		return nil
	}
	return s.SortDesc
}

func (s *SegmentsSearchRequest) GetSort() *SegmentField {
	if s == nil {
		return nil
	}
	return s.Sort
}

func (s *SegmentsSearchRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SegmentsSearchRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentsSearchRequest) SetPage(page *int) {
	s.Page = page
	s.require(segmentsSearchRequestFieldPage)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentsSearchRequest) SetSize(size *int) {
	s.Size = size
	s.require(segmentsSearchRequestFieldSize)
}

// SetSortDesc sets the SortDesc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentsSearchRequest) SetSortDesc(sortDesc *bool) {
	s.SortDesc = sortDesc
	s.require(segmentsSearchRequestFieldSortDesc)
}

// SetSort sets the Sort field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentsSearchRequest) SetSort(sort *SegmentField) {
	s.Sort = sort
	s.require(segmentsSearchRequestFieldSort)
}

func (s *SegmentsSearchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SegmentsSearchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SegmentsSearchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SegmentsSearchRequest) MarshalJSON() ([]byte, error) {
	type embed SegmentsSearchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SegmentsSearchRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	segmentsSearchResponseFieldNumber        = big.NewInt(1 << 0)
	segmentsSearchResponseFieldSize          = big.NewInt(1 << 1)
	segmentsSearchResponseFieldTotalElements = big.NewInt(1 << 2)
	segmentsSearchResponseFieldTotalPages    = big.NewInt(1 << 3)
	segmentsSearchResponseFieldSegments      = big.NewInt(1 << 4)
)

type SegmentsSearchResponse struct {
	// The page being returned, starts at 0
	Number int `json:"number" url:"number"`
	// The number of elements in this page
	Size int `json:"size" url:"size"`
	// The total number of elements in the collection
	TotalElements int64 `json:"totalElements" url:"totalElements"`
	// The total number of pages in the collection
	TotalPages int                `json:"totalPages" url:"totalPages"`
	Segments   []*SegmentResponse `json:"segments" url:"segments"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SegmentsSearchResponse) GetNumber() int {
	if s == nil {
		return 0
	}
	return s.Number
}

func (s *SegmentsSearchResponse) GetSize() int {
	if s == nil {
		return 0
	}
	return s.Size
}

func (s *SegmentsSearchResponse) GetTotalElements() int64 {
	if s == nil {
		return 0
	}
	return s.TotalElements
}

func (s *SegmentsSearchResponse) GetTotalPages() int {
	if s == nil {
		return 0
	}
	return s.TotalPages
}

func (s *SegmentsSearchResponse) GetSegments() []*SegmentResponse {
	if s == nil {
		return nil
	}
	return s.Segments
}

func (s *SegmentsSearchResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SegmentsSearchResponse) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetNumber sets the Number field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentsSearchResponse) SetNumber(number int) {
	s.Number = number
	s.require(segmentsSearchResponseFieldNumber)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentsSearchResponse) SetSize(size int) {
	s.Size = size
	s.require(segmentsSearchResponseFieldSize)
}

// SetTotalElements sets the TotalElements field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentsSearchResponse) SetTotalElements(totalElements int64) {
	s.TotalElements = totalElements
	s.require(segmentsSearchResponseFieldTotalElements)
}

// SetTotalPages sets the TotalPages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentsSearchResponse) SetTotalPages(totalPages int) {
	s.TotalPages = totalPages
	s.require(segmentsSearchResponseFieldTotalPages)
}

// SetSegments sets the Segments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SegmentsSearchResponse) SetSegments(segments []*SegmentResponse) {
	s.Segments = segments
	s.require(segmentsSearchResponseFieldSegments)
}

func (s *SegmentsSearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SegmentsSearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SegmentsSearchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SegmentsSearchResponse) MarshalJSON() ([]byte, error) {
	type embed SegmentsSearchResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SegmentsSearchResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}
