// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mavenagi/mavenagi-go/internal"
	big "math/big"
	time "time"
)

var (
	knowledgeBaseGetRequestFieldAppId = big.NewInt(1 << 0)
)

type KnowledgeBaseGetRequest struct {
	// The App ID of the knowledge base to get. If not provided the ID of the calling app will be used.
	AppId *string `json:"-" url:"appId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (k *KnowledgeBaseGetRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseGetRequest) SetAppId(appId *string) {
	k.AppId = appId
	k.require(knowledgeBaseGetRequestFieldAppId)
}

var (
	knowledgeDocumentGetRequestFieldKnowledgeBaseVersionAppId = big.NewInt(1 << 0)
)

type KnowledgeDocumentGetRequest struct {
	// The App ID of the knowledge base version.
	KnowledgeBaseVersionAppId string `json:"-" url:"knowledgeBaseVersionAppId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (k *KnowledgeDocumentGetRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetKnowledgeBaseVersionAppId sets the KnowledgeBaseVersionAppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentGetRequest) SetKnowledgeBaseVersionAppId(knowledgeBaseVersionAppId string) {
	k.KnowledgeBaseVersionAppId = knowledgeBaseVersionAppId
	k.require(knowledgeDocumentGetRequestFieldKnowledgeBaseVersionAppId)
}

var (
	knowledgeBaseVersionsListRequestFieldAppId = big.NewInt(1 << 0)
)

type KnowledgeBaseVersionsListRequest struct {
	// The App ID of the knowledge base. If not provided the ID of the calling app will be used.
	AppId *string `json:"-" url:"appId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (k *KnowledgeBaseVersionsListRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseVersionsListRequest) SetAppId(appId *string) {
	k.AppId = appId
	k.require(knowledgeBaseVersionsListRequestFieldAppId)
}

var (
	knowledgeBasePatchRequestFieldAppId              = big.NewInt(1 << 0)
	knowledgeBasePatchRequestFieldName               = big.NewInt(1 << 1)
	knowledgeBasePatchRequestFieldTags               = big.NewInt(1 << 2)
	knowledgeBasePatchRequestFieldLlmInclusionStatus = big.NewInt(1 << 3)
	knowledgeBasePatchRequestFieldPrecondition       = big.NewInt(1 << 4)
	knowledgeBasePatchRequestFieldSegmentId          = big.NewInt(1 << 5)
	knowledgeBasePatchRequestFieldRefreshFrequency   = big.NewInt(1 << 6)
)

type KnowledgeBasePatchRequest struct {
	// The App ID of the knowledge base to patch. If not provided the ID of the calling app will be used.
	AppId *string `json:"appId,omitempty" url:"-"`
	// The name of the knowledge base.
	Name *string `json:"name,omitempty" url:"-"`
	// The tags of the knowledge base.
	Tags []string `json:"tags,omitempty" url:"-"`
	// Determines whether documents in the knowledge base are sent to the LLM as part of a conversation. Note that at this time knowledge bases can not be set to `ALWAYS`.
	LlmInclusionStatus *LlmInclusionStatus `json:"llmInclusionStatus,omitempty" url:"-"`
	// The preconditions that must be met for a knowledge base to be relevant to a conversation. Can be used to restrict knowledge bases to certain types of users. A null value will remove the precondition from the knowledge base, it will be available on all conversations.
	Precondition *Precondition `json:"precondition,omitempty" url:"-"`
	// The ID of the segment that must be matched for the knowledge base to be relevant to a conversation.
	// A null value will remove the segment from the knowledge base, it will be available on all conversations.
	//
	// Segments are replacing inline preconditions - a knowledge base may not have both an inline precondition and a segment.
	// Inline precondition support will be removed in a future release.
	SegmentId *EntityId `json:"segmentId,omitempty" url:"-"`
	// How often the knowledge base should be refreshed.
	RefreshFrequency *KnowledgeBaseRefreshFrequency `json:"refreshFrequency,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (k *KnowledgeBasePatchRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasePatchRequest) SetAppId(appId *string) {
	k.AppId = appId
	k.require(knowledgeBasePatchRequestFieldAppId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasePatchRequest) SetName(name *string) {
	k.Name = name
	k.require(knowledgeBasePatchRequestFieldName)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasePatchRequest) SetTags(tags []string) {
	k.Tags = tags
	k.require(knowledgeBasePatchRequestFieldTags)
}

// SetLlmInclusionStatus sets the LlmInclusionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasePatchRequest) SetLlmInclusionStatus(llmInclusionStatus *LlmInclusionStatus) {
	k.LlmInclusionStatus = llmInclusionStatus
	k.require(knowledgeBasePatchRequestFieldLlmInclusionStatus)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasePatchRequest) SetPrecondition(precondition *Precondition) {
	k.Precondition = precondition
	k.require(knowledgeBasePatchRequestFieldPrecondition)
}

// SetSegmentId sets the SegmentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasePatchRequest) SetSegmentId(segmentId *EntityId) {
	k.SegmentId = segmentId
	k.require(knowledgeBasePatchRequestFieldSegmentId)
}

// SetRefreshFrequency sets the RefreshFrequency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasePatchRequest) SetRefreshFrequency(refreshFrequency *KnowledgeBaseRefreshFrequency) {
	k.RefreshFrequency = refreshFrequency
	k.require(knowledgeBasePatchRequestFieldRefreshFrequency)
}

var (
	knowledgeDocumentPatchRequestFieldKnowledgeBaseAppId = big.NewInt(1 << 0)
	knowledgeDocumentPatchRequestFieldLlmInclusionStatus = big.NewInt(1 << 1)
)

type KnowledgeDocumentPatchRequest struct {
	// The App ID of the knowledge base that contains the knowledge document to patch. If not provided the ID of the calling app will be used.
	KnowledgeBaseAppId *string `json:"knowledgeBaseAppId,omitempty" url:"-"`
	// Determines whether this document is sent to the LLM as part of a conversation.
	LlmInclusionStatus *LlmInclusionStatus `json:"llmInclusionStatus,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (k *KnowledgeDocumentPatchRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetKnowledgeBaseAppId sets the KnowledgeBaseAppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentPatchRequest) SetKnowledgeBaseAppId(knowledgeBaseAppId *string) {
	k.KnowledgeBaseAppId = knowledgeBaseAppId
	k.require(knowledgeDocumentPatchRequestFieldKnowledgeBaseAppId)
}

// SetLlmInclusionStatus sets the LlmInclusionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentPatchRequest) SetLlmInclusionStatus(llmInclusionStatus *LlmInclusionStatus) {
	k.LlmInclusionStatus = llmInclusionStatus
	k.require(knowledgeDocumentPatchRequestFieldLlmInclusionStatus)
}

var (
	baseKnowledgeDocumentFieldUrl      = big.NewInt(1 << 0)
	baseKnowledgeDocumentFieldLanguage = big.NewInt(1 << 1)
	baseKnowledgeDocumentFieldAuthor   = big.NewInt(1 << 2)
)

type BaseKnowledgeDocument struct {
	// The URL of the document. Should be visible to end users. Will be shown as part of answers. Not used for crawling.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The document language. Must be a valid ISO 639-1 language code.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The name of the author who created this document.
	Author *string `json:"author,omitempty" url:"author,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseKnowledgeDocument) GetUrl() *string {
	if b == nil {
		return nil
	}
	return b.Url
}

func (b *BaseKnowledgeDocument) GetLanguage() *string {
	if b == nil {
		return nil
	}
	return b.Language
}

func (b *BaseKnowledgeDocument) GetAuthor() *string {
	if b == nil {
		return nil
	}
	return b.Author
}

func (b *BaseKnowledgeDocument) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseKnowledgeDocument) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseKnowledgeDocument) SetUrl(url *string) {
	b.Url = url
	b.require(baseKnowledgeDocumentFieldUrl)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseKnowledgeDocument) SetLanguage(language *string) {
	b.Language = language
	b.require(baseKnowledgeDocumentFieldLanguage)
}

// SetAuthor sets the Author field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseKnowledgeDocument) SetAuthor(author *string) {
	b.Author = author
	b.require(baseKnowledgeDocumentFieldAuthor)
}

func (b *BaseKnowledgeDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseKnowledgeDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseKnowledgeDocument(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseKnowledgeDocument) MarshalJSON() ([]byte, error) {
	type embed BaseKnowledgeDocument
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseKnowledgeDocument) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	finalizeKnowledgeBaseVersionRequestFieldVersionId    = big.NewInt(1 << 0)
	finalizeKnowledgeBaseVersionRequestFieldStatus       = big.NewInt(1 << 1)
	finalizeKnowledgeBaseVersionRequestFieldErrorMessage = big.NewInt(1 << 2)
)

type FinalizeKnowledgeBaseVersionRequest struct {
	// ID that uniquely identifies which knowledge base version to finalize. If not provided will use the most recent version of the knowledge base.
	VersionId *EntityIdWithoutAgent `json:"versionId,omitempty" url:"versionId,omitempty"`
	// Whether the knowledge base version processing was successful or not.
	Status *KnowledgeBaseVersionFinalizeStatus `json:"status,omitempty" url:"status,omitempty"`
	// A user-facing error message that provides more details about a version failure.
	ErrorMessage *string `json:"errorMessage,omitempty" url:"errorMessage,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FinalizeKnowledgeBaseVersionRequest) GetVersionId() *EntityIdWithoutAgent {
	if f == nil {
		return nil
	}
	return f.VersionId
}

func (f *FinalizeKnowledgeBaseVersionRequest) GetStatus() *KnowledgeBaseVersionFinalizeStatus {
	if f == nil {
		return nil
	}
	return f.Status
}

func (f *FinalizeKnowledgeBaseVersionRequest) GetErrorMessage() *string {
	if f == nil {
		return nil
	}
	return f.ErrorMessage
}

func (f *FinalizeKnowledgeBaseVersionRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FinalizeKnowledgeBaseVersionRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetVersionId sets the VersionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FinalizeKnowledgeBaseVersionRequest) SetVersionId(versionId *EntityIdWithoutAgent) {
	f.VersionId = versionId
	f.require(finalizeKnowledgeBaseVersionRequestFieldVersionId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FinalizeKnowledgeBaseVersionRequest) SetStatus(status *KnowledgeBaseVersionFinalizeStatus) {
	f.Status = status
	f.require(finalizeKnowledgeBaseVersionRequestFieldStatus)
}

// SetErrorMessage sets the ErrorMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FinalizeKnowledgeBaseVersionRequest) SetErrorMessage(errorMessage *string) {
	f.ErrorMessage = errorMessage
	f.require(finalizeKnowledgeBaseVersionRequestFieldErrorMessage)
}

func (f *FinalizeKnowledgeBaseVersionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FinalizeKnowledgeBaseVersionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FinalizeKnowledgeBaseVersionRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FinalizeKnowledgeBaseVersionRequest) MarshalJSON() ([]byte, error) {
	type embed FinalizeKnowledgeBaseVersionRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FinalizeKnowledgeBaseVersionRequest) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type KnowledgeBaseField string

const (
	KnowledgeBaseFieldTitle     KnowledgeBaseField = "Title"
	KnowledgeBaseFieldCreatedAt KnowledgeBaseField = "CreatedAt"
	KnowledgeBaseFieldUpdatedAt KnowledgeBaseField = "UpdatedAt"
)

func NewKnowledgeBaseFieldFromString(s string) (KnowledgeBaseField, error) {
	switch s {
	case "Title":
		return KnowledgeBaseFieldTitle, nil
	case "CreatedAt":
		return KnowledgeBaseFieldCreatedAt, nil
	case "UpdatedAt":
		return KnowledgeBaseFieldUpdatedAt, nil
	}
	var t KnowledgeBaseField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KnowledgeBaseField) Ptr() *KnowledgeBaseField {
	return &k
}

var (
	knowledgeBaseFilterFieldSearch                  = big.NewInt(1 << 0)
	knowledgeBaseFilterFieldTitle                   = big.NewInt(1 << 1)
	knowledgeBaseFilterFieldCreatedAfter            = big.NewInt(1 << 2)
	knowledgeBaseFilterFieldCreatedBefore           = big.NewInt(1 << 3)
	knowledgeBaseFilterFieldAppIds                  = big.NewInt(1 << 4)
	knowledgeBaseFilterFieldMostRecentVersionStatus = big.NewInt(1 << 5)
	knowledgeBaseFilterFieldLlmInclusionStatus      = big.NewInt(1 << 6)
)

type KnowledgeBaseFilter struct {
	// Full-text search query for matching knowledge bases by content.
	// When you search with this parameter, you're performing a full-text search across the knowledge title, tags and metadata.
	//
	// This field also supports a syntax for advanced filtering the `metadata` field.
	//
	// Metadata examples:
	// - `metadata:myvalue` - matches knowledge bases with any metadata field set to `myvalue`
	// - `metadata.mykey:myvalue` - matches knowledge bases with a metadata field `mykey` set to `myvalue`
	// - `metadata.mykey:myvalue OR anothervalue` - matches knowledge bases with a metadata field `mykey` set to `myvalue` or `anothervalue`
	// - `metadata.mykey:*` - matches knowledge bases with a metadata field `mykey`
	// - `-metadata:myvalue` - matches knowledge bases that do not have any metadata field set to `myvalue`
	// - `_exists_:metadata` - matches knowledge bases that have any metadata field set
	Search *string `json:"search,omitempty" url:"search,omitempty"`
	// Filter by title
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Filter knowledge bases created on or after this timestamp
	CreatedAfter *time.Time `json:"createdAfter,omitempty" url:"createdAfter,omitempty"`
	// Filter knowledge bases created on or before this timestamp
	CreatedBefore *time.Time `json:"createdBefore,omitempty" url:"createdBefore,omitempty"`
	// Filter by app IDs
	AppIds []string `json:"appIds,omitempty" url:"appIds,omitempty"`
	// Filter knowledge bases by the most recent version status
	MostRecentVersionStatus []KnowledgeBaseVersionStatus `json:"mostRecentVersionStatus,omitempty" url:"mostRecentVersionStatus,omitempty"`
	// Filter knowledge bases by the LLM inclusion status
	LlmInclusionStatus *LlmInclusionStatus `json:"llmInclusionStatus,omitempty" url:"llmInclusionStatus,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBaseFilter) GetSearch() *string {
	if k == nil {
		return nil
	}
	return k.Search
}

func (k *KnowledgeBaseFilter) GetTitle() *string {
	if k == nil {
		return nil
	}
	return k.Title
}

func (k *KnowledgeBaseFilter) GetCreatedAfter() *time.Time {
	if k == nil {
		return nil
	}
	return k.CreatedAfter
}

func (k *KnowledgeBaseFilter) GetCreatedBefore() *time.Time {
	if k == nil {
		return nil
	}
	return k.CreatedBefore
}

func (k *KnowledgeBaseFilter) GetAppIds() []string {
	if k == nil {
		return nil
	}
	return k.AppIds
}

func (k *KnowledgeBaseFilter) GetMostRecentVersionStatus() []KnowledgeBaseVersionStatus {
	if k == nil {
		return nil
	}
	return k.MostRecentVersionStatus
}

func (k *KnowledgeBaseFilter) GetLlmInclusionStatus() *LlmInclusionStatus {
	if k == nil {
		return nil
	}
	return k.LlmInclusionStatus
}

func (k *KnowledgeBaseFilter) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBaseFilter) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetSearch sets the Search field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseFilter) SetSearch(search *string) {
	k.Search = search
	k.require(knowledgeBaseFilterFieldSearch)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseFilter) SetTitle(title *string) {
	k.Title = title
	k.require(knowledgeBaseFilterFieldTitle)
}

// SetCreatedAfter sets the CreatedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseFilter) SetCreatedAfter(createdAfter *time.Time) {
	k.CreatedAfter = createdAfter
	k.require(knowledgeBaseFilterFieldCreatedAfter)
}

// SetCreatedBefore sets the CreatedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseFilter) SetCreatedBefore(createdBefore *time.Time) {
	k.CreatedBefore = createdBefore
	k.require(knowledgeBaseFilterFieldCreatedBefore)
}

// SetAppIds sets the AppIds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseFilter) SetAppIds(appIds []string) {
	k.AppIds = appIds
	k.require(knowledgeBaseFilterFieldAppIds)
}

// SetMostRecentVersionStatus sets the MostRecentVersionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseFilter) SetMostRecentVersionStatus(mostRecentVersionStatus []KnowledgeBaseVersionStatus) {
	k.MostRecentVersionStatus = mostRecentVersionStatus
	k.require(knowledgeBaseFilterFieldMostRecentVersionStatus)
}

// SetLlmInclusionStatus sets the LlmInclusionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseFilter) SetLlmInclusionStatus(llmInclusionStatus *LlmInclusionStatus) {
	k.LlmInclusionStatus = llmInclusionStatus
	k.require(knowledgeBaseFilterFieldLlmInclusionStatus)
}

func (k *KnowledgeBaseFilter) UnmarshalJSON(data []byte) error {
	type embed KnowledgeBaseFilter
	var unmarshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed: embed(*k),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*k = KnowledgeBaseFilter(unmarshaler.embed)
	k.CreatedAfter = unmarshaler.CreatedAfter.TimePtr()
	k.CreatedBefore = unmarshaler.CreatedBefore.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBaseFilter) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBaseFilter
	var marshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed:         embed(*k),
		CreatedAfter:  internal.NewOptionalDateTime(k.CreatedAfter),
		CreatedBefore: internal.NewOptionalDateTime(k.CreatedBefore),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeBaseFilter) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	knowledgeBasePropertiesFieldName         = big.NewInt(1 << 0)
	knowledgeBasePropertiesFieldPrecondition = big.NewInt(1 << 1)
)

type KnowledgeBaseProperties struct {
	// The name of the knowledge base
	Name string `json:"name" url:"name"`
	// The preconditions that must be met for knowledge base be relevant to a conversation. Can be used to restrict knowledge bases to certain types of users.
	Precondition *Precondition `json:"precondition,omitempty" url:"precondition,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBaseProperties) GetName() string {
	if k == nil {
		return ""
	}
	return k.Name
}

func (k *KnowledgeBaseProperties) GetPrecondition() *Precondition {
	if k == nil {
		return nil
	}
	return k.Precondition
}

func (k *KnowledgeBaseProperties) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBaseProperties) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseProperties) SetName(name string) {
	k.Name = name
	k.require(knowledgeBasePropertiesFieldName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseProperties) SetPrecondition(precondition *Precondition) {
	k.Precondition = precondition
	k.require(knowledgeBasePropertiesFieldPrecondition)
}

func (k *KnowledgeBaseProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeBaseProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeBaseProperties(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBaseProperties) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBaseProperties
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeBaseProperties) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

type KnowledgeBaseRefreshFrequency string

const (
	KnowledgeBaseRefreshFrequencyNone    KnowledgeBaseRefreshFrequency = "NONE"
	KnowledgeBaseRefreshFrequencyDaily   KnowledgeBaseRefreshFrequency = "DAILY"
	KnowledgeBaseRefreshFrequencyWeekly  KnowledgeBaseRefreshFrequency = "WEEKLY"
	KnowledgeBaseRefreshFrequencyMonthly KnowledgeBaseRefreshFrequency = "MONTHLY"
)

func NewKnowledgeBaseRefreshFrequencyFromString(s string) (KnowledgeBaseRefreshFrequency, error) {
	switch s {
	case "NONE":
		return KnowledgeBaseRefreshFrequencyNone, nil
	case "DAILY":
		return KnowledgeBaseRefreshFrequencyDaily, nil
	case "WEEKLY":
		return KnowledgeBaseRefreshFrequencyWeekly, nil
	case "MONTHLY":
		return KnowledgeBaseRefreshFrequencyMonthly, nil
	}
	var t KnowledgeBaseRefreshFrequency
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KnowledgeBaseRefreshFrequency) Ptr() *KnowledgeBaseRefreshFrequency {
	return &k
}

var (
	knowledgeBaseRefreshRequestFieldAppId = big.NewInt(1 << 0)
)

type KnowledgeBaseRefreshRequest struct {
	// The App ID of the knowledge base to refresh. If not provided the ID of the calling app will be used.
	AppId *string `json:"appId,omitempty" url:"appId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBaseRefreshRequest) GetAppId() *string {
	if k == nil {
		return nil
	}
	return k.AppId
}

func (k *KnowledgeBaseRefreshRequest) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBaseRefreshRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseRefreshRequest) SetAppId(appId *string) {
	k.AppId = appId
	k.require(knowledgeBaseRefreshRequestFieldAppId)
}

func (k *KnowledgeBaseRefreshRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeBaseRefreshRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeBaseRefreshRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBaseRefreshRequest) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBaseRefreshRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeBaseRefreshRequest) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	knowledgeBaseRequestFieldName            = big.NewInt(1 << 0)
	knowledgeBaseRequestFieldPrecondition    = big.NewInt(1 << 1)
	knowledgeBaseRequestFieldKnowledgeBaseId = big.NewInt(1 << 2)
	knowledgeBaseRequestFieldMetadata        = big.NewInt(1 << 3)
)

type KnowledgeBaseRequest struct {
	// The name of the knowledge base
	Name string `json:"name" url:"name"`
	// The preconditions that must be met for knowledge base be relevant to a conversation. Can be used to restrict knowledge bases to certain types of users.
	Precondition *Precondition `json:"precondition,omitempty" url:"precondition,omitempty"`
	// ID that uniquely identifies this knowledge base
	KnowledgeBaseId *EntityIdBase `json:"knowledgeBaseId" url:"knowledgeBaseId"`
	// Metadata for the knowledge base.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBaseRequest) GetName() string {
	if k == nil {
		return ""
	}
	return k.Name
}

func (k *KnowledgeBaseRequest) GetPrecondition() *Precondition {
	if k == nil {
		return nil
	}
	return k.Precondition
}

func (k *KnowledgeBaseRequest) GetKnowledgeBaseId() *EntityIdBase {
	if k == nil {
		return nil
	}
	return k.KnowledgeBaseId
}

func (k *KnowledgeBaseRequest) GetMetadata() map[string]string {
	if k == nil {
		return nil
	}
	return k.Metadata
}

func (k *KnowledgeBaseRequest) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBaseRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseRequest) SetName(name string) {
	k.Name = name
	k.require(knowledgeBaseRequestFieldName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseRequest) SetPrecondition(precondition *Precondition) {
	k.Precondition = precondition
	k.require(knowledgeBaseRequestFieldPrecondition)
}

// SetKnowledgeBaseId sets the KnowledgeBaseId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseRequest) SetKnowledgeBaseId(knowledgeBaseId *EntityIdBase) {
	k.KnowledgeBaseId = knowledgeBaseId
	k.require(knowledgeBaseRequestFieldKnowledgeBaseId)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseRequest) SetMetadata(metadata map[string]string) {
	k.Metadata = metadata
	k.require(knowledgeBaseRequestFieldMetadata)
}

func (k *KnowledgeBaseRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeBaseRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeBaseRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBaseRequest) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBaseRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeBaseRequest) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	knowledgeBaseResponseFieldName                    = big.NewInt(1 << 0)
	knowledgeBaseResponseFieldPrecondition            = big.NewInt(1 << 1)
	knowledgeBaseResponseFieldCreatedAt               = big.NewInt(1 << 2)
	knowledgeBaseResponseFieldUpdatedAt               = big.NewInt(1 << 3)
	knowledgeBaseResponseFieldKnowledgeBaseId         = big.NewInt(1 << 4)
	knowledgeBaseResponseFieldActiveVersionId         = big.NewInt(1 << 5)
	knowledgeBaseResponseFieldMostRecentVersionStatus = big.NewInt(1 << 6)
	knowledgeBaseResponseFieldType                    = big.NewInt(1 << 7)
	knowledgeBaseResponseFieldMetadata                = big.NewInt(1 << 8)
	knowledgeBaseResponseFieldTags                    = big.NewInt(1 << 9)
	knowledgeBaseResponseFieldLlmInclusionStatus      = big.NewInt(1 << 10)
	knowledgeBaseResponseFieldRefreshFrequency        = big.NewInt(1 << 11)
	knowledgeBaseResponseFieldSegmentId               = big.NewInt(1 << 12)
)

type KnowledgeBaseResponse struct {
	// The name of the knowledge base
	Name string `json:"name" url:"name"`
	// The preconditions that must be met for knowledge base be relevant to a conversation. Can be used to restrict knowledge bases to certain types of users.
	Precondition *Precondition `json:"precondition,omitempty" url:"precondition,omitempty"`
	// The date and time when the knowledge base was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The date and time when the knowledge base was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// ID that uniquely identifies this knowledge base
	KnowledgeBaseId *EntityId `json:"knowledgeBaseId" url:"knowledgeBaseId"`
	// ID of the knowledge base version that is currently active. Documents can be fetched using this version ID.
	ActiveVersionId *EntityId `json:"activeVersionId,omitempty" url:"activeVersionId,omitempty"`
	// The status of the most recent version of the knowledge base.
	// The `activeVersionId` will only be populated if this status is `SUCCEEDED`.
	// Use the `listKnowledgeBaseVersions` endpoint to get the full list of versions.
	MostRecentVersionStatus KnowledgeBaseVersionStatus `json:"mostRecentVersionStatus" url:"mostRecentVersionStatus"`
	// The type of the knowledge base. Can not be changed once created.
	Type KnowledgeBaseType `json:"type" url:"type"`
	// Metadata for the knowledge base.
	Metadata map[string]string `json:"metadata" url:"metadata"`
	// The tags of the knowledge base.
	Tags []string `json:"tags" url:"tags"`
	// Determines whether documents in the knowledge base are sent to the LLM as part of a conversation.
	LlmInclusionStatus LlmInclusionStatus `json:"llmInclusionStatus" url:"llmInclusionStatus"`
	// How often the knowledge base should be refreshed.
	RefreshFrequency KnowledgeBaseRefreshFrequency `json:"refreshFrequency" url:"refreshFrequency"`
	// The IDs of the segment that must be matched for the knowledge base to be relevant to a conversation.
	// Segments are replacing inline preconditions - a Knowledge Base may not have both an inline precondition and a segment.
	// Inline precondition support will be removed in a future release.
	SegmentId *EntityId `json:"segmentId,omitempty" url:"segmentId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBaseResponse) GetName() string {
	if k == nil {
		return ""
	}
	return k.Name
}

func (k *KnowledgeBaseResponse) GetPrecondition() *Precondition {
	if k == nil {
		return nil
	}
	return k.Precondition
}

func (k *KnowledgeBaseResponse) GetCreatedAt() time.Time {
	if k == nil {
		return time.Time{}
	}
	return k.CreatedAt
}

func (k *KnowledgeBaseResponse) GetUpdatedAt() time.Time {
	if k == nil {
		return time.Time{}
	}
	return k.UpdatedAt
}

func (k *KnowledgeBaseResponse) GetKnowledgeBaseId() *EntityId {
	if k == nil {
		return nil
	}
	return k.KnowledgeBaseId
}

func (k *KnowledgeBaseResponse) GetActiveVersionId() *EntityId {
	if k == nil {
		return nil
	}
	return k.ActiveVersionId
}

func (k *KnowledgeBaseResponse) GetMostRecentVersionStatus() KnowledgeBaseVersionStatus {
	if k == nil {
		return ""
	}
	return k.MostRecentVersionStatus
}

func (k *KnowledgeBaseResponse) GetType() KnowledgeBaseType {
	if k == nil {
		return ""
	}
	return k.Type
}

func (k *KnowledgeBaseResponse) GetMetadata() map[string]string {
	if k == nil {
		return nil
	}
	return k.Metadata
}

func (k *KnowledgeBaseResponse) GetTags() []string {
	if k == nil {
		return nil
	}
	return k.Tags
}

func (k *KnowledgeBaseResponse) GetLlmInclusionStatus() LlmInclusionStatus {
	if k == nil {
		return ""
	}
	return k.LlmInclusionStatus
}

func (k *KnowledgeBaseResponse) GetRefreshFrequency() KnowledgeBaseRefreshFrequency {
	if k == nil {
		return ""
	}
	return k.RefreshFrequency
}

func (k *KnowledgeBaseResponse) GetSegmentId() *EntityId {
	if k == nil {
		return nil
	}
	return k.SegmentId
}

func (k *KnowledgeBaseResponse) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBaseResponse) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetName(name string) {
	k.Name = name
	k.require(knowledgeBaseResponseFieldName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetPrecondition(precondition *Precondition) {
	k.Precondition = precondition
	k.require(knowledgeBaseResponseFieldPrecondition)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetCreatedAt(createdAt time.Time) {
	k.CreatedAt = createdAt
	k.require(knowledgeBaseResponseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetUpdatedAt(updatedAt time.Time) {
	k.UpdatedAt = updatedAt
	k.require(knowledgeBaseResponseFieldUpdatedAt)
}

// SetKnowledgeBaseId sets the KnowledgeBaseId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetKnowledgeBaseId(knowledgeBaseId *EntityId) {
	k.KnowledgeBaseId = knowledgeBaseId
	k.require(knowledgeBaseResponseFieldKnowledgeBaseId)
}

// SetActiveVersionId sets the ActiveVersionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetActiveVersionId(activeVersionId *EntityId) {
	k.ActiveVersionId = activeVersionId
	k.require(knowledgeBaseResponseFieldActiveVersionId)
}

// SetMostRecentVersionStatus sets the MostRecentVersionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetMostRecentVersionStatus(mostRecentVersionStatus KnowledgeBaseVersionStatus) {
	k.MostRecentVersionStatus = mostRecentVersionStatus
	k.require(knowledgeBaseResponseFieldMostRecentVersionStatus)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetType(type_ KnowledgeBaseType) {
	k.Type = type_
	k.require(knowledgeBaseResponseFieldType)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetMetadata(metadata map[string]string) {
	k.Metadata = metadata
	k.require(knowledgeBaseResponseFieldMetadata)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetTags(tags []string) {
	k.Tags = tags
	k.require(knowledgeBaseResponseFieldTags)
}

// SetLlmInclusionStatus sets the LlmInclusionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetLlmInclusionStatus(llmInclusionStatus LlmInclusionStatus) {
	k.LlmInclusionStatus = llmInclusionStatus
	k.require(knowledgeBaseResponseFieldLlmInclusionStatus)
}

// SetRefreshFrequency sets the RefreshFrequency field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetRefreshFrequency(refreshFrequency KnowledgeBaseRefreshFrequency) {
	k.RefreshFrequency = refreshFrequency
	k.require(knowledgeBaseResponseFieldRefreshFrequency)
}

// SetSegmentId sets the SegmentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseResponse) SetSegmentId(segmentId *EntityId) {
	k.SegmentId = segmentId
	k.require(knowledgeBaseResponseFieldSegmentId)
}

func (k *KnowledgeBaseResponse) UnmarshalJSON(data []byte) error {
	type embed KnowledgeBaseResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*k),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*k = KnowledgeBaseResponse(unmarshaler.embed)
	k.CreatedAt = unmarshaler.CreatedAt.Time()
	k.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBaseResponse) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBaseResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*k),
		CreatedAt: internal.NewDateTime(k.CreatedAt),
		UpdatedAt: internal.NewDateTime(k.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeBaseResponse) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	knowledgeBaseSearchRequestFieldPage     = big.NewInt(1 << 0)
	knowledgeBaseSearchRequestFieldSize     = big.NewInt(1 << 1)
	knowledgeBaseSearchRequestFieldSortDesc = big.NewInt(1 << 2)
	knowledgeBaseSearchRequestFieldSort     = big.NewInt(1 << 3)
	knowledgeBaseSearchRequestFieldFilter   = big.NewInt(1 << 4)
)

type KnowledgeBaseSearchRequest struct {
	// Page number to return, defaults to 0
	Page *int `json:"page,omitempty" url:"page,omitempty"`
	// The size of the page to return, defaults to 20
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Whether to sort descending, defaults to true
	SortDesc *bool                `json:"sortDesc,omitempty" url:"sortDesc,omitempty"`
	Sort     *KnowledgeBaseField  `json:"sort,omitempty" url:"sort,omitempty"`
	Filter   *KnowledgeBaseFilter `json:"filter,omitempty" url:"filter,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBaseSearchRequest) GetPage() *int {
	if k == nil {
		return nil
	}
	return k.Page
}

func (k *KnowledgeBaseSearchRequest) GetSize() *int {
	if k == nil {
		return nil
	}
	return k.Size
}

func (k *KnowledgeBaseSearchRequest) GetSortDesc() *bool {
	if k == nil {
		return nil
	}
	return k.SortDesc
}

func (k *KnowledgeBaseSearchRequest) GetSort() *KnowledgeBaseField {
	if k == nil {
		return nil
	}
	return k.Sort
}

func (k *KnowledgeBaseSearchRequest) GetFilter() *KnowledgeBaseFilter {
	if k == nil {
		return nil
	}
	return k.Filter
}

func (k *KnowledgeBaseSearchRequest) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBaseSearchRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseSearchRequest) SetPage(page *int) {
	k.Page = page
	k.require(knowledgeBaseSearchRequestFieldPage)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseSearchRequest) SetSize(size *int) {
	k.Size = size
	k.require(knowledgeBaseSearchRequestFieldSize)
}

// SetSortDesc sets the SortDesc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseSearchRequest) SetSortDesc(sortDesc *bool) {
	k.SortDesc = sortDesc
	k.require(knowledgeBaseSearchRequestFieldSortDesc)
}

// SetSort sets the Sort field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseSearchRequest) SetSort(sort *KnowledgeBaseField) {
	k.Sort = sort
	k.require(knowledgeBaseSearchRequestFieldSort)
}

// SetFilter sets the Filter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseSearchRequest) SetFilter(filter *KnowledgeBaseFilter) {
	k.Filter = filter
	k.require(knowledgeBaseSearchRequestFieldFilter)
}

func (k *KnowledgeBaseSearchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeBaseSearchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeBaseSearchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBaseSearchRequest) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBaseSearchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeBaseSearchRequest) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// API knowledge bases are managed by a Maven App.
// All other knowledge base types are deprecated and can not be created.
type KnowledgeBaseType string

const (
	KnowledgeBaseTypeApi    KnowledgeBaseType = "API"
	KnowledgeBaseTypeUrl    KnowledgeBaseType = "URL"
	KnowledgeBaseTypeManual KnowledgeBaseType = "MANUAL"
	KnowledgeBaseTypeRss    KnowledgeBaseType = "RSS"
	KnowledgeBaseTypeLegacy KnowledgeBaseType = "LEGACY"
)

func NewKnowledgeBaseTypeFromString(s string) (KnowledgeBaseType, error) {
	switch s {
	case "API":
		return KnowledgeBaseTypeApi, nil
	case "URL":
		return KnowledgeBaseTypeUrl, nil
	case "MANUAL":
		return KnowledgeBaseTypeManual, nil
	case "RSS":
		return KnowledgeBaseTypeRss, nil
	case "LEGACY":
		return KnowledgeBaseTypeLegacy, nil
	}
	var t KnowledgeBaseType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KnowledgeBaseType) Ptr() *KnowledgeBaseType {
	return &k
}

var (
	knowledgeBaseVersionFieldType         = big.NewInt(1 << 0)
	knowledgeBaseVersionFieldVersionId    = big.NewInt(1 << 1)
	knowledgeBaseVersionFieldStatus       = big.NewInt(1 << 2)
	knowledgeBaseVersionFieldErrorMessage = big.NewInt(1 << 3)
	knowledgeBaseVersionFieldCreatedAt    = big.NewInt(1 << 4)
	knowledgeBaseVersionFieldUpdatedAt    = big.NewInt(1 << 5)
)

type KnowledgeBaseVersion struct {
	// Indicates whether the completed version constitutes a full or partial refresh of the knowledge base. Deleting and updating documents is only supported for partial refreshes.
	Type KnowledgeBaseVersionType `json:"type" url:"type"`
	// The unique ID of the knowledge base version.
	VersionId *EntityId `json:"versionId" url:"versionId"`
	// The status of the knowledge base version
	Status KnowledgeBaseVersionStatus `json:"status" url:"status"`
	// A user-facing error message that provides more details about a version failure.
	ErrorMessage *string `json:"errorMessage,omitempty" url:"errorMessage,omitempty"`
	// The date and time the knowledge base version was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The date and time the knowledge base version was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBaseVersion) GetType() KnowledgeBaseVersionType {
	if k == nil {
		return ""
	}
	return k.Type
}

func (k *KnowledgeBaseVersion) GetVersionId() *EntityId {
	if k == nil {
		return nil
	}
	return k.VersionId
}

func (k *KnowledgeBaseVersion) GetStatus() KnowledgeBaseVersionStatus {
	if k == nil {
		return ""
	}
	return k.Status
}

func (k *KnowledgeBaseVersion) GetErrorMessage() *string {
	if k == nil {
		return nil
	}
	return k.ErrorMessage
}

func (k *KnowledgeBaseVersion) GetCreatedAt() time.Time {
	if k == nil {
		return time.Time{}
	}
	return k.CreatedAt
}

func (k *KnowledgeBaseVersion) GetUpdatedAt() time.Time {
	if k == nil {
		return time.Time{}
	}
	return k.UpdatedAt
}

func (k *KnowledgeBaseVersion) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBaseVersion) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseVersion) SetType(type_ KnowledgeBaseVersionType) {
	k.Type = type_
	k.require(knowledgeBaseVersionFieldType)
}

// SetVersionId sets the VersionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseVersion) SetVersionId(versionId *EntityId) {
	k.VersionId = versionId
	k.require(knowledgeBaseVersionFieldVersionId)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseVersion) SetStatus(status KnowledgeBaseVersionStatus) {
	k.Status = status
	k.require(knowledgeBaseVersionFieldStatus)
}

// SetErrorMessage sets the ErrorMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseVersion) SetErrorMessage(errorMessage *string) {
	k.ErrorMessage = errorMessage
	k.require(knowledgeBaseVersionFieldErrorMessage)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseVersion) SetCreatedAt(createdAt time.Time) {
	k.CreatedAt = createdAt
	k.require(knowledgeBaseVersionFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseVersion) SetUpdatedAt(updatedAt time.Time) {
	k.UpdatedAt = updatedAt
	k.require(knowledgeBaseVersionFieldUpdatedAt)
}

func (k *KnowledgeBaseVersion) UnmarshalJSON(data []byte) error {
	type embed KnowledgeBaseVersion
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*k),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*k = KnowledgeBaseVersion(unmarshaler.embed)
	k.CreatedAt = unmarshaler.CreatedAt.Time()
	k.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBaseVersion) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBaseVersion
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*k),
		CreatedAt: internal.NewDateTime(k.CreatedAt),
		UpdatedAt: internal.NewDateTime(k.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeBaseVersion) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// Whether the knowledge base version processing was successful or not.
type KnowledgeBaseVersionFinalizeStatus string

const (
	KnowledgeBaseVersionFinalizeStatusSucceeded KnowledgeBaseVersionFinalizeStatus = "SUCCEEDED"
	KnowledgeBaseVersionFinalizeStatusFailed    KnowledgeBaseVersionFinalizeStatus = "FAILED"
)

func NewKnowledgeBaseVersionFinalizeStatusFromString(s string) (KnowledgeBaseVersionFinalizeStatus, error) {
	switch s {
	case "SUCCEEDED":
		return KnowledgeBaseVersionFinalizeStatusSucceeded, nil
	case "FAILED":
		return KnowledgeBaseVersionFinalizeStatusFailed, nil
	}
	var t KnowledgeBaseVersionFinalizeStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KnowledgeBaseVersionFinalizeStatus) Ptr() *KnowledgeBaseVersionFinalizeStatus {
	return &k
}

var (
	knowledgeBaseVersionRequestFieldType = big.NewInt(1 << 0)
)

type KnowledgeBaseVersionRequest struct {
	// Indicates whether the completed version constitutes a full or partial refresh of the knowledge base. Deleting and updating documents is only supported for partial refreshes.
	Type KnowledgeBaseVersionType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBaseVersionRequest) GetType() KnowledgeBaseVersionType {
	if k == nil {
		return ""
	}
	return k.Type
}

func (k *KnowledgeBaseVersionRequest) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBaseVersionRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseVersionRequest) SetType(type_ KnowledgeBaseVersionType) {
	k.Type = type_
	k.require(knowledgeBaseVersionRequestFieldType)
}

func (k *KnowledgeBaseVersionRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeBaseVersionRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeBaseVersionRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBaseVersionRequest) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBaseVersionRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeBaseVersionRequest) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// The status of the knowledge base version
type KnowledgeBaseVersionStatus string

const (
	KnowledgeBaseVersionStatusSucceeded  KnowledgeBaseVersionStatus = "SUCCEEDED"
	KnowledgeBaseVersionStatusFailed     KnowledgeBaseVersionStatus = "FAILED"
	KnowledgeBaseVersionStatusInProgress KnowledgeBaseVersionStatus = "IN_PROGRESS"
)

func NewKnowledgeBaseVersionStatusFromString(s string) (KnowledgeBaseVersionStatus, error) {
	switch s {
	case "SUCCEEDED":
		return KnowledgeBaseVersionStatusSucceeded, nil
	case "FAILED":
		return KnowledgeBaseVersionStatusFailed, nil
	case "IN_PROGRESS":
		return KnowledgeBaseVersionStatusInProgress, nil
	}
	var t KnowledgeBaseVersionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KnowledgeBaseVersionStatus) Ptr() *KnowledgeBaseVersionStatus {
	return &k
}

// The type of knowledge base version
type KnowledgeBaseVersionType string

const (
	KnowledgeBaseVersionTypeFull    KnowledgeBaseVersionType = "FULL"
	KnowledgeBaseVersionTypePartial KnowledgeBaseVersionType = "PARTIAL"
)

func NewKnowledgeBaseVersionTypeFromString(s string) (KnowledgeBaseVersionType, error) {
	switch s {
	case "FULL":
		return KnowledgeBaseVersionTypeFull, nil
	case "PARTIAL":
		return KnowledgeBaseVersionTypePartial, nil
	}
	var t KnowledgeBaseVersionType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KnowledgeBaseVersionType) Ptr() *KnowledgeBaseVersionType {
	return &k
}

var (
	knowledgeBaseVersionsListResponseFieldKnowledgeBaseVersions = big.NewInt(1 << 0)
)

type KnowledgeBaseVersionsListResponse struct {
	// The active knowledge base versions for the knowledge base. Includes all versions within the last 90 days or the last 10, whichever is greater.
	KnowledgeBaseVersions []*KnowledgeBaseVersion `json:"knowledgeBaseVersions" url:"knowledgeBaseVersions"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBaseVersionsListResponse) GetKnowledgeBaseVersions() []*KnowledgeBaseVersion {
	if k == nil {
		return nil
	}
	return k.KnowledgeBaseVersions
}

func (k *KnowledgeBaseVersionsListResponse) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBaseVersionsListResponse) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetKnowledgeBaseVersions sets the KnowledgeBaseVersions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBaseVersionsListResponse) SetKnowledgeBaseVersions(knowledgeBaseVersions []*KnowledgeBaseVersion) {
	k.KnowledgeBaseVersions = knowledgeBaseVersions
	k.require(knowledgeBaseVersionsListResponseFieldKnowledgeBaseVersions)
}

func (k *KnowledgeBaseVersionsListResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeBaseVersionsListResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeBaseVersionsListResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBaseVersionsListResponse) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBaseVersionsListResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeBaseVersionsListResponse) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	knowledgeBasesResponseFieldNumber         = big.NewInt(1 << 0)
	knowledgeBasesResponseFieldSize           = big.NewInt(1 << 1)
	knowledgeBasesResponseFieldTotalElements  = big.NewInt(1 << 2)
	knowledgeBasesResponseFieldTotalPages     = big.NewInt(1 << 3)
	knowledgeBasesResponseFieldKnowledgeBases = big.NewInt(1 << 4)
)

type KnowledgeBasesResponse struct {
	// The page being returned, starts at 0
	Number int `json:"number" url:"number"`
	// The number of elements in this page
	Size int `json:"size" url:"size"`
	// The total number of elements in the collection
	TotalElements int64 `json:"totalElements" url:"totalElements"`
	// The total number of pages in the collection
	TotalPages int `json:"totalPages" url:"totalPages"`
	// The knowledge bases that match the search criteria
	KnowledgeBases []*KnowledgeBaseResponse `json:"knowledgeBases" url:"knowledgeBases"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeBasesResponse) GetNumber() int {
	if k == nil {
		return 0
	}
	return k.Number
}

func (k *KnowledgeBasesResponse) GetSize() int {
	if k == nil {
		return 0
	}
	return k.Size
}

func (k *KnowledgeBasesResponse) GetTotalElements() int64 {
	if k == nil {
		return 0
	}
	return k.TotalElements
}

func (k *KnowledgeBasesResponse) GetTotalPages() int {
	if k == nil {
		return 0
	}
	return k.TotalPages
}

func (k *KnowledgeBasesResponse) GetKnowledgeBases() []*KnowledgeBaseResponse {
	if k == nil {
		return nil
	}
	return k.KnowledgeBases
}

func (k *KnowledgeBasesResponse) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeBasesResponse) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetNumber sets the Number field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasesResponse) SetNumber(number int) {
	k.Number = number
	k.require(knowledgeBasesResponseFieldNumber)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasesResponse) SetSize(size int) {
	k.Size = size
	k.require(knowledgeBasesResponseFieldSize)
}

// SetTotalElements sets the TotalElements field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasesResponse) SetTotalElements(totalElements int64) {
	k.TotalElements = totalElements
	k.require(knowledgeBasesResponseFieldTotalElements)
}

// SetTotalPages sets the TotalPages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasesResponse) SetTotalPages(totalPages int) {
	k.TotalPages = totalPages
	k.require(knowledgeBasesResponseFieldTotalPages)
}

// SetKnowledgeBases sets the KnowledgeBases field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeBasesResponse) SetKnowledgeBases(knowledgeBases []*KnowledgeBaseResponse) {
	k.KnowledgeBases = knowledgeBases
	k.require(knowledgeBasesResponseFieldKnowledgeBases)
}

func (k *KnowledgeBasesResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeBasesResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeBasesResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeBasesResponse) MarshalJSON() ([]byte, error) {
	type embed KnowledgeBasesResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeBasesResponse) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	knowledgeDeleteRequestFieldVersionId = big.NewInt(1 << 0)
)

type KnowledgeDeleteRequest struct {
	// ID that uniquely identifies which knowledge base version to delete the document from.
	VersionId *EntityIdWithoutAgent `json:"versionId" url:"versionId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeDeleteRequest) GetVersionId() *EntityIdWithoutAgent {
	if k == nil {
		return nil
	}
	return k.VersionId
}

func (k *KnowledgeDeleteRequest) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeDeleteRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetVersionId sets the VersionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDeleteRequest) SetVersionId(versionId *EntityIdWithoutAgent) {
	k.VersionId = versionId
	k.require(knowledgeDeleteRequestFieldVersionId)
}

func (k *KnowledgeDeleteRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeDeleteRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeDeleteRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeDeleteRequest) MarshalJSON() ([]byte, error) {
	type embed KnowledgeDeleteRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeDeleteRequest) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// The type of the knowledge document content. Markdown preferred.
type KnowledgeDocumentContentType string

const (
	KnowledgeDocumentContentTypeHtml     KnowledgeDocumentContentType = "HTML"
	KnowledgeDocumentContentTypeMarkdown KnowledgeDocumentContentType = "MARKDOWN"
)

func NewKnowledgeDocumentContentTypeFromString(s string) (KnowledgeDocumentContentType, error) {
	switch s {
	case "HTML":
		return KnowledgeDocumentContentTypeHtml, nil
	case "MARKDOWN":
		return KnowledgeDocumentContentTypeMarkdown, nil
	}
	var t KnowledgeDocumentContentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KnowledgeDocumentContentType) Ptr() *KnowledgeDocumentContentType {
	return &k
}

type KnowledgeDocumentField string

const (
	KnowledgeDocumentFieldTitle     KnowledgeDocumentField = "Title"
	KnowledgeDocumentFieldCreatedAt KnowledgeDocumentField = "CreatedAt"
	KnowledgeDocumentFieldUpdatedAt KnowledgeDocumentField = "UpdatedAt"
	KnowledgeDocumentFieldLanguage  KnowledgeDocumentField = "Language"
)

func NewKnowledgeDocumentFieldFromString(s string) (KnowledgeDocumentField, error) {
	switch s {
	case "Title":
		return KnowledgeDocumentFieldTitle, nil
	case "CreatedAt":
		return KnowledgeDocumentFieldCreatedAt, nil
	case "UpdatedAt":
		return KnowledgeDocumentFieldUpdatedAt, nil
	case "Language":
		return KnowledgeDocumentFieldLanguage, nil
	}
	var t KnowledgeDocumentField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KnowledgeDocumentField) Ptr() *KnowledgeDocumentField {
	return &k
}

var (
	knowledgeDocumentFilterFieldSearch                 = big.NewInt(1 << 0)
	knowledgeDocumentFilterFieldTitle                  = big.NewInt(1 << 1)
	knowledgeDocumentFilterFieldUrl                    = big.NewInt(1 << 2)
	knowledgeDocumentFilterFieldCreatedAfter           = big.NewInt(1 << 3)
	knowledgeDocumentFilterFieldCreatedBefore          = big.NewInt(1 << 4)
	knowledgeDocumentFilterFieldAppIds                 = big.NewInt(1 << 5)
	knowledgeDocumentFilterFieldKnowledgeBaseVersionId = big.NewInt(1 << 6)
	knowledgeDocumentFilterFieldLlmInclusionStatus     = big.NewInt(1 << 7)
)

type KnowledgeDocumentFilter struct {
	// Full-text search query for matching knowledge documents by content.
	// When you search with this parameter, you're performing a full-text search across the knowledge document title and metadata.
	//
	// This field also supports a syntax for advanced filtering the `metadata` field.
	//
	// Metadata examples:
	// - `metadata:myvalue` - matches knowledge documents with any metadata field set to `myvalue`
	// - `metadata.mykey:myvalue` - matches knowledge documents with a metadata field `mykey` set to `myvalue`
	// - `metadata.mykey:myvalue OR anothervalue` - matches knowledge documents with a metadata field `mykey` set to `myvalue` or `anothervalue`
	// - `metadata.mykey:*` - matches knowledge documents with a metadata field `mykey`
	// - `-metadata:myvalue` - matches knowledge documents that do not have any metadata field set to `myvalue`
	// - `_exists_:metadata` - matches knowledge documents that have any metadata field set
	Search *string `json:"search,omitempty" url:"search,omitempty"`
	// Filter by title
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Filter by url
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// Filter knowledge documents created on or after this timestamp
	CreatedAfter *time.Time `json:"createdAfter,omitempty" url:"createdAfter,omitempty"`
	// Filter knowledge documents created on or before this timestamp
	CreatedBefore *time.Time `json:"createdBefore,omitempty" url:"createdBefore,omitempty"`
	// Filter by app IDs
	AppIds []string `json:"appIds,omitempty" url:"appIds,omitempty"`
	// Filter documents within the specified knowledge base version.
	// If not provided all active knowledge base versions within the agent will be searched.
	KnowledgeBaseVersionId *EntityIdWithoutAgent `json:"knowledgeBaseVersionId,omitempty" url:"knowledgeBaseVersionId,omitempty"`
	// Filter by the LLM inclusion status
	LlmInclusionStatus []LlmInclusionStatus `json:"llmInclusionStatus,omitempty" url:"llmInclusionStatus,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeDocumentFilter) GetSearch() *string {
	if k == nil {
		return nil
	}
	return k.Search
}

func (k *KnowledgeDocumentFilter) GetTitle() *string {
	if k == nil {
		return nil
	}
	return k.Title
}

func (k *KnowledgeDocumentFilter) GetUrl() *string {
	if k == nil {
		return nil
	}
	return k.Url
}

func (k *KnowledgeDocumentFilter) GetCreatedAfter() *time.Time {
	if k == nil {
		return nil
	}
	return k.CreatedAfter
}

func (k *KnowledgeDocumentFilter) GetCreatedBefore() *time.Time {
	if k == nil {
		return nil
	}
	return k.CreatedBefore
}

func (k *KnowledgeDocumentFilter) GetAppIds() []string {
	if k == nil {
		return nil
	}
	return k.AppIds
}

func (k *KnowledgeDocumentFilter) GetKnowledgeBaseVersionId() *EntityIdWithoutAgent {
	if k == nil {
		return nil
	}
	return k.KnowledgeBaseVersionId
}

func (k *KnowledgeDocumentFilter) GetLlmInclusionStatus() []LlmInclusionStatus {
	if k == nil {
		return nil
	}
	return k.LlmInclusionStatus
}

func (k *KnowledgeDocumentFilter) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeDocumentFilter) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetSearch sets the Search field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentFilter) SetSearch(search *string) {
	k.Search = search
	k.require(knowledgeDocumentFilterFieldSearch)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentFilter) SetTitle(title *string) {
	k.Title = title
	k.require(knowledgeDocumentFilterFieldTitle)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentFilter) SetUrl(url *string) {
	k.Url = url
	k.require(knowledgeDocumentFilterFieldUrl)
}

// SetCreatedAfter sets the CreatedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentFilter) SetCreatedAfter(createdAfter *time.Time) {
	k.CreatedAfter = createdAfter
	k.require(knowledgeDocumentFilterFieldCreatedAfter)
}

// SetCreatedBefore sets the CreatedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentFilter) SetCreatedBefore(createdBefore *time.Time) {
	k.CreatedBefore = createdBefore
	k.require(knowledgeDocumentFilterFieldCreatedBefore)
}

// SetAppIds sets the AppIds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentFilter) SetAppIds(appIds []string) {
	k.AppIds = appIds
	k.require(knowledgeDocumentFilterFieldAppIds)
}

// SetKnowledgeBaseVersionId sets the KnowledgeBaseVersionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentFilter) SetKnowledgeBaseVersionId(knowledgeBaseVersionId *EntityIdWithoutAgent) {
	k.KnowledgeBaseVersionId = knowledgeBaseVersionId
	k.require(knowledgeDocumentFilterFieldKnowledgeBaseVersionId)
}

// SetLlmInclusionStatus sets the LlmInclusionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentFilter) SetLlmInclusionStatus(llmInclusionStatus []LlmInclusionStatus) {
	k.LlmInclusionStatus = llmInclusionStatus
	k.require(knowledgeDocumentFilterFieldLlmInclusionStatus)
}

func (k *KnowledgeDocumentFilter) UnmarshalJSON(data []byte) error {
	type embed KnowledgeDocumentFilter
	var unmarshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed: embed(*k),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*k = KnowledgeDocumentFilter(unmarshaler.embed)
	k.CreatedAfter = unmarshaler.CreatedAfter.TimePtr()
	k.CreatedBefore = unmarshaler.CreatedBefore.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeDocumentFilter) MarshalJSON() ([]byte, error) {
	type embed KnowledgeDocumentFilter
	var marshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed:         embed(*k),
		CreatedAfter:  internal.NewOptionalDateTime(k.CreatedAfter),
		CreatedBefore: internal.NewOptionalDateTime(k.CreatedBefore),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeDocumentFilter) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	knowledgeDocumentRequestFieldUrl                 = big.NewInt(1 << 0)
	knowledgeDocumentRequestFieldLanguage            = big.NewInt(1 << 1)
	knowledgeDocumentRequestFieldAuthor              = big.NewInt(1 << 2)
	knowledgeDocumentRequestFieldKnowledgeDocumentId = big.NewInt(1 << 3)
	knowledgeDocumentRequestFieldVersionId           = big.NewInt(1 << 4)
	knowledgeDocumentRequestFieldContentType         = big.NewInt(1 << 5)
	knowledgeDocumentRequestFieldTitle               = big.NewInt(1 << 6)
	knowledgeDocumentRequestFieldAssetId             = big.NewInt(1 << 7)
	knowledgeDocumentRequestFieldContent             = big.NewInt(1 << 8)
	knowledgeDocumentRequestFieldMetadata            = big.NewInt(1 << 9)
	knowledgeDocumentRequestFieldCreatedAt           = big.NewInt(1 << 10)
	knowledgeDocumentRequestFieldUpdatedAt           = big.NewInt(1 << 11)
)

type KnowledgeDocumentRequest struct {
	// The URL of the document. Should be visible to end users. Will be shown as part of answers. Not used for crawling.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The document language. Must be a valid ISO 639-1 language code.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The name of the author who created this document.
	Author *string `json:"author,omitempty" url:"author,omitempty"`
	// ID that uniquely identifies this knowledge document within its knowledge base
	KnowledgeDocumentId *EntityIdBase `json:"knowledgeDocumentId" url:"knowledgeDocumentId"`
	// ID that uniquely identifies which knowledge base version to create the document in. If not provided will use the most recent version of the knowledge base.
	VersionId *EntityIdWithoutAgent `json:"versionId,omitempty" url:"versionId,omitempty"`
	// Type of knowledge document content, if content is provided. This does not need to be set if content is not provided
	ContentType KnowledgeDocumentContentType `json:"contentType" url:"contentType"`
	// The title of the document. Will be shown as part of answers.
	Title string `json:"title" url:"title"`
	// ID of the asset associated with this document. This asset will be transformed into text and set as the content of the document. The following types are supported: `application/pdf`, `text/plain`.  Either this or content is required, but not both
	AssetId *EntityIdBase `json:"assetId,omitempty" url:"assetId,omitempty"`
	// The content of the document. Not shown directly to users. May be provided in HTML or markdown. HTML will be converted to markdown automatically. Images are not currently supported and will be ignored. Either this or assetId is required, but not both
	Content *string `json:"content,omitempty" url:"content,omitempty"`
	// Metadata for the knowledge document.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The time at which this document was created.
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The time at which this document was last modified.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeDocumentRequest) GetUrl() *string {
	if k == nil {
		return nil
	}
	return k.Url
}

func (k *KnowledgeDocumentRequest) GetLanguage() *string {
	if k == nil {
		return nil
	}
	return k.Language
}

func (k *KnowledgeDocumentRequest) GetAuthor() *string {
	if k == nil {
		return nil
	}
	return k.Author
}

func (k *KnowledgeDocumentRequest) GetKnowledgeDocumentId() *EntityIdBase {
	if k == nil {
		return nil
	}
	return k.KnowledgeDocumentId
}

func (k *KnowledgeDocumentRequest) GetVersionId() *EntityIdWithoutAgent {
	if k == nil {
		return nil
	}
	return k.VersionId
}

func (k *KnowledgeDocumentRequest) GetContentType() KnowledgeDocumentContentType {
	if k == nil {
		return ""
	}
	return k.ContentType
}

func (k *KnowledgeDocumentRequest) GetTitle() string {
	if k == nil {
		return ""
	}
	return k.Title
}

func (k *KnowledgeDocumentRequest) GetAssetId() *EntityIdBase {
	if k == nil {
		return nil
	}
	return k.AssetId
}

func (k *KnowledgeDocumentRequest) GetContent() *string {
	if k == nil {
		return nil
	}
	return k.Content
}

func (k *KnowledgeDocumentRequest) GetMetadata() map[string]string {
	if k == nil {
		return nil
	}
	return k.Metadata
}

func (k *KnowledgeDocumentRequest) GetCreatedAt() *time.Time {
	if k == nil {
		return nil
	}
	return k.CreatedAt
}

func (k *KnowledgeDocumentRequest) GetUpdatedAt() *time.Time {
	if k == nil {
		return nil
	}
	return k.UpdatedAt
}

func (k *KnowledgeDocumentRequest) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeDocumentRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetUrl(url *string) {
	k.Url = url
	k.require(knowledgeDocumentRequestFieldUrl)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetLanguage(language *string) {
	k.Language = language
	k.require(knowledgeDocumentRequestFieldLanguage)
}

// SetAuthor sets the Author field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetAuthor(author *string) {
	k.Author = author
	k.require(knowledgeDocumentRequestFieldAuthor)
}

// SetKnowledgeDocumentId sets the KnowledgeDocumentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetKnowledgeDocumentId(knowledgeDocumentId *EntityIdBase) {
	k.KnowledgeDocumentId = knowledgeDocumentId
	k.require(knowledgeDocumentRequestFieldKnowledgeDocumentId)
}

// SetVersionId sets the VersionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetVersionId(versionId *EntityIdWithoutAgent) {
	k.VersionId = versionId
	k.require(knowledgeDocumentRequestFieldVersionId)
}

// SetContentType sets the ContentType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetContentType(contentType KnowledgeDocumentContentType) {
	k.ContentType = contentType
	k.require(knowledgeDocumentRequestFieldContentType)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetTitle(title string) {
	k.Title = title
	k.require(knowledgeDocumentRequestFieldTitle)
}

// SetAssetId sets the AssetId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetAssetId(assetId *EntityIdBase) {
	k.AssetId = assetId
	k.require(knowledgeDocumentRequestFieldAssetId)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetContent(content *string) {
	k.Content = content
	k.require(knowledgeDocumentRequestFieldContent)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetMetadata(metadata map[string]string) {
	k.Metadata = metadata
	k.require(knowledgeDocumentRequestFieldMetadata)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetCreatedAt(createdAt *time.Time) {
	k.CreatedAt = createdAt
	k.require(knowledgeDocumentRequestFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentRequest) SetUpdatedAt(updatedAt *time.Time) {
	k.UpdatedAt = updatedAt
	k.require(knowledgeDocumentRequestFieldUpdatedAt)
}

func (k *KnowledgeDocumentRequest) UnmarshalJSON(data []byte) error {
	type embed KnowledgeDocumentRequest
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*k),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*k = KnowledgeDocumentRequest(unmarshaler.embed)
	k.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	k.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeDocumentRequest) MarshalJSON() ([]byte, error) {
	type embed KnowledgeDocumentRequest
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*k),
		CreatedAt: internal.NewOptionalDateTime(k.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(k.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeDocumentRequest) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	knowledgeDocumentResponseFieldUrl                             = big.NewInt(1 << 0)
	knowledgeDocumentResponseFieldLanguage                        = big.NewInt(1 << 1)
	knowledgeDocumentResponseFieldAuthor                          = big.NewInt(1 << 2)
	knowledgeDocumentResponseFieldKnowledgeDocumentId             = big.NewInt(1 << 3)
	knowledgeDocumentResponseFieldKnowledgeBaseVersionId          = big.NewInt(1 << 4)
	knowledgeDocumentResponseFieldKnowledgeBaseId                 = big.NewInt(1 << 5)
	knowledgeDocumentResponseFieldTitle                           = big.NewInt(1 << 6)
	knowledgeDocumentResponseFieldLlmInclusionStatus              = big.NewInt(1 << 7)
	knowledgeDocumentResponseFieldKnowledgeBaseLlmInclusionStatus = big.NewInt(1 << 8)
	knowledgeDocumentResponseFieldCreatedAt                       = big.NewInt(1 << 9)
	knowledgeDocumentResponseFieldUpdatedAt                       = big.NewInt(1 << 10)
	knowledgeDocumentResponseFieldProcessingStatus                = big.NewInt(1 << 11)
	knowledgeDocumentResponseFieldContent                         = big.NewInt(1 << 12)
	knowledgeDocumentResponseFieldAsset                           = big.NewInt(1 << 13)
	knowledgeDocumentResponseFieldMetadata                        = big.NewInt(1 << 14)
)

type KnowledgeDocumentResponse struct {
	// The URL of the document. Should be visible to end users. Will be shown as part of answers. Not used for crawling.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The document language. Must be a valid ISO 639-1 language code.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The name of the author who created this document.
	Author *string `json:"author,omitempty" url:"author,omitempty"`
	// ID that uniquely identifies this knowledge document within its knowledge base
	KnowledgeDocumentId *EntityId `json:"knowledgeDocumentId" url:"knowledgeDocumentId"`
	// ID that uniquely identifies the knowledge base version that contains this document.
	// This may be missing on legacy documents.
	KnowledgeBaseVersionId *EntityId `json:"knowledgeBaseVersionId,omitempty" url:"knowledgeBaseVersionId,omitempty"`
	// ID that uniquely identifies the knowledge base that contains this document.
	KnowledgeBaseId *EntityId `json:"knowledgeBaseId" url:"knowledgeBaseId"`
	// The title of the document. Will be shown as part of answers. May be missing on legacy documents.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Whether the document is included in the agent's knowledge.
	LlmInclusionStatus LlmInclusionStatus `json:"llmInclusionStatus" url:"llmInclusionStatus"`
	// Whether the knowledge base is included in the agent's knowledge.
	KnowledgeBaseLlmInclusionStatus LlmInclusionStatus `json:"knowledgeBaseLlmInclusionStatus" url:"knowledgeBaseLlmInclusionStatus"`
	// The time at which this document was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The time at which this document was last modified.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// The current processing status of the knowledge document
	ProcessingStatus *KnowledgeDocumentStatus `json:"processingStatus,omitempty" url:"processingStatus,omitempty"`
	// The content of the document in markdown format. Not shown directly to users.
	Content string `json:"content" url:"content"`
	// If the document is associated with an asset, this will contain the asset metadata
	Asset *AttachmentResponse `json:"asset,omitempty" url:"asset,omitempty"`
	// Metadata for the knowledge document.
	Metadata map[string]string `json:"metadata" url:"metadata"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeDocumentResponse) GetUrl() *string {
	if k == nil {
		return nil
	}
	return k.Url
}

func (k *KnowledgeDocumentResponse) GetLanguage() *string {
	if k == nil {
		return nil
	}
	return k.Language
}

func (k *KnowledgeDocumentResponse) GetAuthor() *string {
	if k == nil {
		return nil
	}
	return k.Author
}

func (k *KnowledgeDocumentResponse) GetKnowledgeDocumentId() *EntityId {
	if k == nil {
		return nil
	}
	return k.KnowledgeDocumentId
}

func (k *KnowledgeDocumentResponse) GetKnowledgeBaseVersionId() *EntityId {
	if k == nil {
		return nil
	}
	return k.KnowledgeBaseVersionId
}

func (k *KnowledgeDocumentResponse) GetKnowledgeBaseId() *EntityId {
	if k == nil {
		return nil
	}
	return k.KnowledgeBaseId
}

func (k *KnowledgeDocumentResponse) GetTitle() *string {
	if k == nil {
		return nil
	}
	return k.Title
}

func (k *KnowledgeDocumentResponse) GetLlmInclusionStatus() LlmInclusionStatus {
	if k == nil {
		return ""
	}
	return k.LlmInclusionStatus
}

func (k *KnowledgeDocumentResponse) GetKnowledgeBaseLlmInclusionStatus() LlmInclusionStatus {
	if k == nil {
		return ""
	}
	return k.KnowledgeBaseLlmInclusionStatus
}

func (k *KnowledgeDocumentResponse) GetCreatedAt() time.Time {
	if k == nil {
		return time.Time{}
	}
	return k.CreatedAt
}

func (k *KnowledgeDocumentResponse) GetUpdatedAt() time.Time {
	if k == nil {
		return time.Time{}
	}
	return k.UpdatedAt
}

func (k *KnowledgeDocumentResponse) GetProcessingStatus() *KnowledgeDocumentStatus {
	if k == nil {
		return nil
	}
	return k.ProcessingStatus
}

func (k *KnowledgeDocumentResponse) GetContent() string {
	if k == nil {
		return ""
	}
	return k.Content
}

func (k *KnowledgeDocumentResponse) GetAsset() *AttachmentResponse {
	if k == nil {
		return nil
	}
	return k.Asset
}

func (k *KnowledgeDocumentResponse) GetMetadata() map[string]string {
	if k == nil {
		return nil
	}
	return k.Metadata
}

func (k *KnowledgeDocumentResponse) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeDocumentResponse) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetUrl(url *string) {
	k.Url = url
	k.require(knowledgeDocumentResponseFieldUrl)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetLanguage(language *string) {
	k.Language = language
	k.require(knowledgeDocumentResponseFieldLanguage)
}

// SetAuthor sets the Author field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetAuthor(author *string) {
	k.Author = author
	k.require(knowledgeDocumentResponseFieldAuthor)
}

// SetKnowledgeDocumentId sets the KnowledgeDocumentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetKnowledgeDocumentId(knowledgeDocumentId *EntityId) {
	k.KnowledgeDocumentId = knowledgeDocumentId
	k.require(knowledgeDocumentResponseFieldKnowledgeDocumentId)
}

// SetKnowledgeBaseVersionId sets the KnowledgeBaseVersionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetKnowledgeBaseVersionId(knowledgeBaseVersionId *EntityId) {
	k.KnowledgeBaseVersionId = knowledgeBaseVersionId
	k.require(knowledgeDocumentResponseFieldKnowledgeBaseVersionId)
}

// SetKnowledgeBaseId sets the KnowledgeBaseId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetKnowledgeBaseId(knowledgeBaseId *EntityId) {
	k.KnowledgeBaseId = knowledgeBaseId
	k.require(knowledgeDocumentResponseFieldKnowledgeBaseId)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetTitle(title *string) {
	k.Title = title
	k.require(knowledgeDocumentResponseFieldTitle)
}

// SetLlmInclusionStatus sets the LlmInclusionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetLlmInclusionStatus(llmInclusionStatus LlmInclusionStatus) {
	k.LlmInclusionStatus = llmInclusionStatus
	k.require(knowledgeDocumentResponseFieldLlmInclusionStatus)
}

// SetKnowledgeBaseLlmInclusionStatus sets the KnowledgeBaseLlmInclusionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetKnowledgeBaseLlmInclusionStatus(knowledgeBaseLlmInclusionStatus LlmInclusionStatus) {
	k.KnowledgeBaseLlmInclusionStatus = knowledgeBaseLlmInclusionStatus
	k.require(knowledgeDocumentResponseFieldKnowledgeBaseLlmInclusionStatus)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetCreatedAt(createdAt time.Time) {
	k.CreatedAt = createdAt
	k.require(knowledgeDocumentResponseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetUpdatedAt(updatedAt time.Time) {
	k.UpdatedAt = updatedAt
	k.require(knowledgeDocumentResponseFieldUpdatedAt)
}

// SetProcessingStatus sets the ProcessingStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetProcessingStatus(processingStatus *KnowledgeDocumentStatus) {
	k.ProcessingStatus = processingStatus
	k.require(knowledgeDocumentResponseFieldProcessingStatus)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetContent(content string) {
	k.Content = content
	k.require(knowledgeDocumentResponseFieldContent)
}

// SetAsset sets the Asset field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetAsset(asset *AttachmentResponse) {
	k.Asset = asset
	k.require(knowledgeDocumentResponseFieldAsset)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentResponse) SetMetadata(metadata map[string]string) {
	k.Metadata = metadata
	k.require(knowledgeDocumentResponseFieldMetadata)
}

func (k *KnowledgeDocumentResponse) UnmarshalJSON(data []byte) error {
	type embed KnowledgeDocumentResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*k),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*k = KnowledgeDocumentResponse(unmarshaler.embed)
	k.CreatedAt = unmarshaler.CreatedAt.Time()
	k.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeDocumentResponse) MarshalJSON() ([]byte, error) {
	type embed KnowledgeDocumentResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*k),
		CreatedAt: internal.NewDateTime(k.CreatedAt),
		UpdatedAt: internal.NewDateTime(k.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeDocumentResponse) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	knowledgeDocumentSearchRequestFieldPage     = big.NewInt(1 << 0)
	knowledgeDocumentSearchRequestFieldSize     = big.NewInt(1 << 1)
	knowledgeDocumentSearchRequestFieldSortDesc = big.NewInt(1 << 2)
	knowledgeDocumentSearchRequestFieldSort     = big.NewInt(1 << 3)
	knowledgeDocumentSearchRequestFieldFilter   = big.NewInt(1 << 4)
)

type KnowledgeDocumentSearchRequest struct {
	// Page number to return, defaults to 0
	Page *int `json:"page,omitempty" url:"page,omitempty"`
	// The size of the page to return, defaults to 20
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Whether to sort descending, defaults to true
	SortDesc *bool                    `json:"sortDesc,omitempty" url:"sortDesc,omitempty"`
	Sort     *KnowledgeDocumentField  `json:"sort,omitempty" url:"sort,omitempty"`
	Filter   *KnowledgeDocumentFilter `json:"filter,omitempty" url:"filter,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeDocumentSearchRequest) GetPage() *int {
	if k == nil {
		return nil
	}
	return k.Page
}

func (k *KnowledgeDocumentSearchRequest) GetSize() *int {
	if k == nil {
		return nil
	}
	return k.Size
}

func (k *KnowledgeDocumentSearchRequest) GetSortDesc() *bool {
	if k == nil {
		return nil
	}
	return k.SortDesc
}

func (k *KnowledgeDocumentSearchRequest) GetSort() *KnowledgeDocumentField {
	if k == nil {
		return nil
	}
	return k.Sort
}

func (k *KnowledgeDocumentSearchRequest) GetFilter() *KnowledgeDocumentFilter {
	if k == nil {
		return nil
	}
	return k.Filter
}

func (k *KnowledgeDocumentSearchRequest) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeDocumentSearchRequest) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchRequest) SetPage(page *int) {
	k.Page = page
	k.require(knowledgeDocumentSearchRequestFieldPage)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchRequest) SetSize(size *int) {
	k.Size = size
	k.require(knowledgeDocumentSearchRequestFieldSize)
}

// SetSortDesc sets the SortDesc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchRequest) SetSortDesc(sortDesc *bool) {
	k.SortDesc = sortDesc
	k.require(knowledgeDocumentSearchRequestFieldSortDesc)
}

// SetSort sets the Sort field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchRequest) SetSort(sort *KnowledgeDocumentField) {
	k.Sort = sort
	k.require(knowledgeDocumentSearchRequestFieldSort)
}

// SetFilter sets the Filter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchRequest) SetFilter(filter *KnowledgeDocumentFilter) {
	k.Filter = filter
	k.require(knowledgeDocumentSearchRequestFieldFilter)
}

func (k *KnowledgeDocumentSearchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeDocumentSearchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeDocumentSearchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeDocumentSearchRequest) MarshalJSON() ([]byte, error) {
	type embed KnowledgeDocumentSearchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeDocumentSearchRequest) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	knowledgeDocumentSearchResponseFieldUrl                             = big.NewInt(1 << 0)
	knowledgeDocumentSearchResponseFieldLanguage                        = big.NewInt(1 << 1)
	knowledgeDocumentSearchResponseFieldAuthor                          = big.NewInt(1 << 2)
	knowledgeDocumentSearchResponseFieldKnowledgeDocumentId             = big.NewInt(1 << 3)
	knowledgeDocumentSearchResponseFieldKnowledgeBaseVersionId          = big.NewInt(1 << 4)
	knowledgeDocumentSearchResponseFieldKnowledgeBaseId                 = big.NewInt(1 << 5)
	knowledgeDocumentSearchResponseFieldTitle                           = big.NewInt(1 << 6)
	knowledgeDocumentSearchResponseFieldLlmInclusionStatus              = big.NewInt(1 << 7)
	knowledgeDocumentSearchResponseFieldKnowledgeBaseLlmInclusionStatus = big.NewInt(1 << 8)
	knowledgeDocumentSearchResponseFieldCreatedAt                       = big.NewInt(1 << 9)
	knowledgeDocumentSearchResponseFieldUpdatedAt                       = big.NewInt(1 << 10)
)

type KnowledgeDocumentSearchResponse struct {
	// The URL of the document. Should be visible to end users. Will be shown as part of answers. Not used for crawling.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The document language. Must be a valid ISO 639-1 language code.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The name of the author who created this document.
	Author *string `json:"author,omitempty" url:"author,omitempty"`
	// ID that uniquely identifies this knowledge document within its knowledge base
	KnowledgeDocumentId *EntityId `json:"knowledgeDocumentId" url:"knowledgeDocumentId"`
	// ID that uniquely identifies the knowledge base version that contains this document.
	// This may be missing on legacy documents.
	KnowledgeBaseVersionId *EntityId `json:"knowledgeBaseVersionId,omitempty" url:"knowledgeBaseVersionId,omitempty"`
	// ID that uniquely identifies the knowledge base that contains this document.
	KnowledgeBaseId *EntityId `json:"knowledgeBaseId" url:"knowledgeBaseId"`
	// The title of the document. Will be shown as part of answers. May be missing on legacy documents.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Whether the document is included in the agent's knowledge.
	LlmInclusionStatus LlmInclusionStatus `json:"llmInclusionStatus" url:"llmInclusionStatus"`
	// Whether the knowledge base is included in the agent's knowledge.
	KnowledgeBaseLlmInclusionStatus LlmInclusionStatus `json:"knowledgeBaseLlmInclusionStatus" url:"knowledgeBaseLlmInclusionStatus"`
	// The time at which this document was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// The time at which this document was last modified.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeDocumentSearchResponse) GetUrl() *string {
	if k == nil {
		return nil
	}
	return k.Url
}

func (k *KnowledgeDocumentSearchResponse) GetLanguage() *string {
	if k == nil {
		return nil
	}
	return k.Language
}

func (k *KnowledgeDocumentSearchResponse) GetAuthor() *string {
	if k == nil {
		return nil
	}
	return k.Author
}

func (k *KnowledgeDocumentSearchResponse) GetKnowledgeDocumentId() *EntityId {
	if k == nil {
		return nil
	}
	return k.KnowledgeDocumentId
}

func (k *KnowledgeDocumentSearchResponse) GetKnowledgeBaseVersionId() *EntityId {
	if k == nil {
		return nil
	}
	return k.KnowledgeBaseVersionId
}

func (k *KnowledgeDocumentSearchResponse) GetKnowledgeBaseId() *EntityId {
	if k == nil {
		return nil
	}
	return k.KnowledgeBaseId
}

func (k *KnowledgeDocumentSearchResponse) GetTitle() *string {
	if k == nil {
		return nil
	}
	return k.Title
}

func (k *KnowledgeDocumentSearchResponse) GetLlmInclusionStatus() LlmInclusionStatus {
	if k == nil {
		return ""
	}
	return k.LlmInclusionStatus
}

func (k *KnowledgeDocumentSearchResponse) GetKnowledgeBaseLlmInclusionStatus() LlmInclusionStatus {
	if k == nil {
		return ""
	}
	return k.KnowledgeBaseLlmInclusionStatus
}

func (k *KnowledgeDocumentSearchResponse) GetCreatedAt() time.Time {
	if k == nil {
		return time.Time{}
	}
	return k.CreatedAt
}

func (k *KnowledgeDocumentSearchResponse) GetUpdatedAt() time.Time {
	if k == nil {
		return time.Time{}
	}
	return k.UpdatedAt
}

func (k *KnowledgeDocumentSearchResponse) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeDocumentSearchResponse) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchResponse) SetUrl(url *string) {
	k.Url = url
	k.require(knowledgeDocumentSearchResponseFieldUrl)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchResponse) SetLanguage(language *string) {
	k.Language = language
	k.require(knowledgeDocumentSearchResponseFieldLanguage)
}

// SetAuthor sets the Author field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchResponse) SetAuthor(author *string) {
	k.Author = author
	k.require(knowledgeDocumentSearchResponseFieldAuthor)
}

// SetKnowledgeDocumentId sets the KnowledgeDocumentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchResponse) SetKnowledgeDocumentId(knowledgeDocumentId *EntityId) {
	k.KnowledgeDocumentId = knowledgeDocumentId
	k.require(knowledgeDocumentSearchResponseFieldKnowledgeDocumentId)
}

// SetKnowledgeBaseVersionId sets the KnowledgeBaseVersionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchResponse) SetKnowledgeBaseVersionId(knowledgeBaseVersionId *EntityId) {
	k.KnowledgeBaseVersionId = knowledgeBaseVersionId
	k.require(knowledgeDocumentSearchResponseFieldKnowledgeBaseVersionId)
}

// SetKnowledgeBaseId sets the KnowledgeBaseId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchResponse) SetKnowledgeBaseId(knowledgeBaseId *EntityId) {
	k.KnowledgeBaseId = knowledgeBaseId
	k.require(knowledgeDocumentSearchResponseFieldKnowledgeBaseId)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchResponse) SetTitle(title *string) {
	k.Title = title
	k.require(knowledgeDocumentSearchResponseFieldTitle)
}

// SetLlmInclusionStatus sets the LlmInclusionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchResponse) SetLlmInclusionStatus(llmInclusionStatus LlmInclusionStatus) {
	k.LlmInclusionStatus = llmInclusionStatus
	k.require(knowledgeDocumentSearchResponseFieldLlmInclusionStatus)
}

// SetKnowledgeBaseLlmInclusionStatus sets the KnowledgeBaseLlmInclusionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchResponse) SetKnowledgeBaseLlmInclusionStatus(knowledgeBaseLlmInclusionStatus LlmInclusionStatus) {
	k.KnowledgeBaseLlmInclusionStatus = knowledgeBaseLlmInclusionStatus
	k.require(knowledgeDocumentSearchResponseFieldKnowledgeBaseLlmInclusionStatus)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchResponse) SetCreatedAt(createdAt time.Time) {
	k.CreatedAt = createdAt
	k.require(knowledgeDocumentSearchResponseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentSearchResponse) SetUpdatedAt(updatedAt time.Time) {
	k.UpdatedAt = updatedAt
	k.require(knowledgeDocumentSearchResponseFieldUpdatedAt)
}

func (k *KnowledgeDocumentSearchResponse) UnmarshalJSON(data []byte) error {
	type embed KnowledgeDocumentSearchResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*k),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*k = KnowledgeDocumentSearchResponse(unmarshaler.embed)
	k.CreatedAt = unmarshaler.CreatedAt.Time()
	k.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeDocumentSearchResponse) MarshalJSON() ([]byte, error) {
	type embed KnowledgeDocumentSearchResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*k),
		CreatedAt: internal.NewDateTime(k.CreatedAt),
		UpdatedAt: internal.NewDateTime(k.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeDocumentSearchResponse) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

// The current processing status of the knowledge document
type KnowledgeDocumentStatus string

const (
	KnowledgeDocumentStatusSucceeded  KnowledgeDocumentStatus = "SUCCEEDED"
	KnowledgeDocumentStatusInProgress KnowledgeDocumentStatus = "IN_PROGRESS"
)

func NewKnowledgeDocumentStatusFromString(s string) (KnowledgeDocumentStatus, error) {
	switch s {
	case "SUCCEEDED":
		return KnowledgeDocumentStatusSucceeded, nil
	case "IN_PROGRESS":
		return KnowledgeDocumentStatusInProgress, nil
	}
	var t KnowledgeDocumentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (k KnowledgeDocumentStatus) Ptr() *KnowledgeDocumentStatus {
	return &k
}

var (
	knowledgeDocumentsResponseFieldNumber             = big.NewInt(1 << 0)
	knowledgeDocumentsResponseFieldSize               = big.NewInt(1 << 1)
	knowledgeDocumentsResponseFieldTotalElements      = big.NewInt(1 << 2)
	knowledgeDocumentsResponseFieldTotalPages         = big.NewInt(1 << 3)
	knowledgeDocumentsResponseFieldKnowledgeDocuments = big.NewInt(1 << 4)
)

type KnowledgeDocumentsResponse struct {
	// The page being returned, starts at 0
	Number int `json:"number" url:"number"`
	// The number of elements in this page
	Size int `json:"size" url:"size"`
	// The total number of elements in the collection
	TotalElements int64 `json:"totalElements" url:"totalElements"`
	// The total number of pages in the collection
	TotalPages int `json:"totalPages" url:"totalPages"`
	// The knowledge documents that match the search criteria. Content will not be included.
	KnowledgeDocuments []*KnowledgeDocumentSearchResponse `json:"knowledgeDocuments" url:"knowledgeDocuments"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeDocumentsResponse) GetNumber() int {
	if k == nil {
		return 0
	}
	return k.Number
}

func (k *KnowledgeDocumentsResponse) GetSize() int {
	if k == nil {
		return 0
	}
	return k.Size
}

func (k *KnowledgeDocumentsResponse) GetTotalElements() int64 {
	if k == nil {
		return 0
	}
	return k.TotalElements
}

func (k *KnowledgeDocumentsResponse) GetTotalPages() int {
	if k == nil {
		return 0
	}
	return k.TotalPages
}

func (k *KnowledgeDocumentsResponse) GetKnowledgeDocuments() []*KnowledgeDocumentSearchResponse {
	if k == nil {
		return nil
	}
	return k.KnowledgeDocuments
}

func (k *KnowledgeDocumentsResponse) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeDocumentsResponse) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetNumber sets the Number field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentsResponse) SetNumber(number int) {
	k.Number = number
	k.require(knowledgeDocumentsResponseFieldNumber)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentsResponse) SetSize(size int) {
	k.Size = size
	k.require(knowledgeDocumentsResponseFieldSize)
}

// SetTotalElements sets the TotalElements field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentsResponse) SetTotalElements(totalElements int64) {
	k.TotalElements = totalElements
	k.require(knowledgeDocumentsResponseFieldTotalElements)
}

// SetTotalPages sets the TotalPages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentsResponse) SetTotalPages(totalPages int) {
	k.TotalPages = totalPages
	k.require(knowledgeDocumentsResponseFieldTotalPages)
}

// SetKnowledgeDocuments sets the KnowledgeDocuments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeDocumentsResponse) SetKnowledgeDocuments(knowledgeDocuments []*KnowledgeDocumentSearchResponse) {
	k.KnowledgeDocuments = knowledgeDocuments
	k.require(knowledgeDocumentsResponseFieldKnowledgeDocuments)
}

func (k *KnowledgeDocumentsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeDocumentsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeDocumentsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeDocumentsResponse) MarshalJSON() ([]byte, error) {
	type embed KnowledgeDocumentsResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeDocumentsResponse) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}
