// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mavenagi/mavenagi-go/internal"
	io "io"
	big "math/big"
	time "time"
)

var (
	conversationDeleteRequestFieldAppId  = big.NewInt(1 << 0)
	conversationDeleteRequestFieldReason = big.NewInt(1 << 1)
)

type ConversationDeleteRequest struct {
	// The App ID of the conversation to delete. If not provided the ID of the calling app will be used.
	AppId *string `json:"-" url:"appId,omitempty"`
	// The reason for deleting the conversation. This message will replace all user messages in the conversation.
	Reason string `json:"-" url:"reason"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *ConversationDeleteRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationDeleteRequest) SetAppId(appId *string) {
	c.AppId = appId
	c.require(conversationDeleteRequestFieldAppId)
}

// SetReason sets the Reason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationDeleteRequest) SetReason(reason string) {
	c.Reason = reason
	c.require(conversationDeleteRequestFieldReason)
}

var (
	conversationGetRequestFieldAppId               = big.NewInt(1 << 0)
	conversationGetRequestFieldTranslationLanguage = big.NewInt(1 << 1)
)

type ConversationGetRequest struct {
	// The App ID of the conversation to get. If not provided the ID of the calling app will be used.
	AppId *string `json:"-" url:"appId,omitempty"`
	// The language to translate the conversation analysis into
	TranslationLanguage *string `json:"-" url:"translationLanguage,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (c *ConversationGetRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationGetRequest) SetAppId(appId *string) {
	c.AppId = appId
	c.require(conversationGetRequestFieldAppId)
}

// SetTranslationLanguage sets the TranslationLanguage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationGetRequest) SetTranslationLanguage(translationLanguage *string) {
	c.TranslationLanguage = translationLanguage
	c.require(conversationGetRequestFieldTranslationLanguage)
}

type SimulationImportRequest struct {
	File io.Reader `json:"-" url:"-"`
	// The response config to use for all of the created simulations.
	ResponseConfig *ResponseConfig `json:"responseConfig,omitempty" url:"-"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`
}

func (s *SimulationImportRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

var (
	actionFormAttachmentFieldAssetId = big.NewInt(1 << 0)
)

type ActionFormAttachment struct {
	// The asset ID of the attachment.
	AssetId *EntityIdBase `json:"assetId" url:"assetId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionFormAttachment) GetAssetId() *EntityIdBase {
	if a == nil {
		return nil
	}
	return a.AssetId
}

func (a *ActionFormAttachment) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionFormAttachment) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAssetId sets the AssetId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormAttachment) SetAssetId(assetId *EntityIdBase) {
	a.AssetId = assetId
	a.require(actionFormAttachmentFieldAssetId)
}

func (a *ActionFormAttachment) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionFormAttachment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionFormAttachment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionFormAttachment) MarshalJSON() ([]byte, error) {
	type embed ActionFormAttachment
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionFormAttachment) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionFormRequestParamValue struct {
	Unknown              interface{}
	ActionFormAttachment *ActionFormAttachment

	typ string
}

func (a *ActionFormRequestParamValue) GetUnknown() interface{} {
	if a == nil {
		return nil
	}
	return a.Unknown
}

func (a *ActionFormRequestParamValue) GetActionFormAttachment() *ActionFormAttachment {
	if a == nil {
		return nil
	}
	return a.ActionFormAttachment
}

func (a *ActionFormRequestParamValue) UnmarshalJSON(data []byte) error {
	var valueUnknown interface{}
	if err := json.Unmarshal(data, &valueUnknown); err == nil {
		a.typ = "Unknown"
		a.Unknown = valueUnknown
		return nil
	}
	valueActionFormAttachment := new(ActionFormAttachment)
	if err := json.Unmarshal(data, &valueActionFormAttachment); err == nil {
		a.typ = "ActionFormAttachment"
		a.ActionFormAttachment = valueActionFormAttachment
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, a)
}

func (a ActionFormRequestParamValue) MarshalJSON() ([]byte, error) {
	if a.typ == "Unknown" || a.Unknown != nil {
		return json.Marshal(a.Unknown)
	}
	if a.typ == "ActionFormAttachment" || a.ActionFormAttachment != nil {
		return json.Marshal(a.ActionFormAttachment)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", a)
}

type ActionFormRequestParamValueVisitor interface {
	VisitUnknown(interface{}) error
	VisitActionFormAttachment(*ActionFormAttachment) error
}

func (a *ActionFormRequestParamValue) Accept(visitor ActionFormRequestParamValueVisitor) error {
	if a.typ == "Unknown" || a.Unknown != nil {
		return visitor.VisitUnknown(a.Unknown)
	}
	if a.typ == "ActionFormAttachment" || a.ActionFormAttachment != nil {
		return visitor.VisitActionFormAttachment(a.ActionFormAttachment)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", a)
}

var (
	askObjectRequestFieldConversationMessageId = big.NewInt(1 << 0)
	askObjectRequestFieldUserId                = big.NewInt(1 << 1)
	askObjectRequestFieldText                  = big.NewInt(1 << 2)
	askObjectRequestFieldAttachments           = big.NewInt(1 << 3)
	askObjectRequestFieldTransientData         = big.NewInt(1 << 4)
	askObjectRequestFieldTimezone              = big.NewInt(1 << 5)
	askObjectRequestFieldSchema                = big.NewInt(1 << 6)
)

type AskObjectRequest struct {
	// Externally supplied ID to uniquely identify this message within the conversation. If a message with this ID already exists it will be reused and will not be updated.
	ConversationMessageId *EntityIdBase `json:"conversationMessageId" url:"conversationMessageId"`
	// Externally supplied ID to uniquely identify the user that created this message
	UserId *EntityIdBase `json:"userId" url:"userId"`
	// The text of the message
	Text string `json:"text" url:"text"`
	// The attachments to the message. Image attachments will be sent to the LLM as additional data.
	// Non-image attachments can be stored and downloaded from the API but will not be sent to the LLM.
	Attachments []*AttachmentRequest `json:"attachments,omitempty" url:"attachments,omitempty"`
	// Transient data which the Maven platform will not persist. This data will only be forwarded to actions taken by this ask request. For example, one may put in user tokens as transient data.
	TransientData map[string]string `json:"transientData,omitempty" url:"transientData,omitempty"`
	// IANA timezone identifier (e.g. "America/New_York", "Europe/London") to be used for time-based operations in the conversation.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// JSON schema string defining the expected object shape.
	Schema string `json:"schema" url:"schema"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AskObjectRequest) GetConversationMessageId() *EntityIdBase {
	if a == nil {
		return nil
	}
	return a.ConversationMessageId
}

func (a *AskObjectRequest) GetUserId() *EntityIdBase {
	if a == nil {
		return nil
	}
	return a.UserId
}

func (a *AskObjectRequest) GetText() string {
	if a == nil {
		return ""
	}
	return a.Text
}

func (a *AskObjectRequest) GetAttachments() []*AttachmentRequest {
	if a == nil {
		return nil
	}
	return a.Attachments
}

func (a *AskObjectRequest) GetTransientData() map[string]string {
	if a == nil {
		return nil
	}
	return a.TransientData
}

func (a *AskObjectRequest) GetTimezone() *string {
	if a == nil {
		return nil
	}
	return a.Timezone
}

func (a *AskObjectRequest) GetSchema() string {
	if a == nil {
		return ""
	}
	return a.Schema
}

func (a *AskObjectRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AskObjectRequest) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetConversationMessageId sets the ConversationMessageId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskObjectRequest) SetConversationMessageId(conversationMessageId *EntityIdBase) {
	a.ConversationMessageId = conversationMessageId
	a.require(askObjectRequestFieldConversationMessageId)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskObjectRequest) SetUserId(userId *EntityIdBase) {
	a.UserId = userId
	a.require(askObjectRequestFieldUserId)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskObjectRequest) SetText(text string) {
	a.Text = text
	a.require(askObjectRequestFieldText)
}

// SetAttachments sets the Attachments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskObjectRequest) SetAttachments(attachments []*AttachmentRequest) {
	a.Attachments = attachments
	a.require(askObjectRequestFieldAttachments)
}

// SetTransientData sets the TransientData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskObjectRequest) SetTransientData(transientData map[string]string) {
	a.TransientData = transientData
	a.require(askObjectRequestFieldTransientData)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskObjectRequest) SetTimezone(timezone *string) {
	a.Timezone = timezone
	a.require(askObjectRequestFieldTimezone)
}

// SetSchema sets the Schema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskObjectRequest) SetSchema(schema string) {
	a.Schema = schema
	a.require(askObjectRequestFieldSchema)
}

func (a *AskObjectRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AskObjectRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AskObjectRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AskObjectRequest) MarshalJSON() ([]byte, error) {
	type embed AskObjectRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AskObjectRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	askRequestFieldConversationMessageId = big.NewInt(1 << 0)
	askRequestFieldUserId                = big.NewInt(1 << 1)
	askRequestFieldText                  = big.NewInt(1 << 2)
	askRequestFieldAttachments           = big.NewInt(1 << 3)
	askRequestFieldTransientData         = big.NewInt(1 << 4)
	askRequestFieldTimezone              = big.NewInt(1 << 5)
)

type AskRequest struct {
	// Externally supplied ID to uniquely identify this message within the conversation. If a message with this ID already exists it will be reused and will not be updated.
	ConversationMessageId *EntityIdBase `json:"conversationMessageId" url:"conversationMessageId"`
	// Externally supplied ID to uniquely identify the user that created this message
	UserId *EntityIdBase `json:"userId" url:"userId"`
	// The text of the message
	Text string `json:"text" url:"text"`
	// The attachments to the message. Image attachments will be sent to the LLM as additional data.
	// Non-image attachments can be stored and downloaded from the API but will not be sent to the LLM.
	Attachments []*AttachmentRequest `json:"attachments,omitempty" url:"attachments,omitempty"`
	// Transient data which the Maven platform will not persist. This data will only be forwarded to actions taken by this ask request. For example, one may put in user tokens as transient data.
	TransientData map[string]string `json:"transientData,omitempty" url:"transientData,omitempty"`
	// IANA timezone identifier (e.g. "America/New_York", "Europe/London") to be used for time-based operations in the conversation.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AskRequest) GetConversationMessageId() *EntityIdBase {
	if a == nil {
		return nil
	}
	return a.ConversationMessageId
}

func (a *AskRequest) GetUserId() *EntityIdBase {
	if a == nil {
		return nil
	}
	return a.UserId
}

func (a *AskRequest) GetText() string {
	if a == nil {
		return ""
	}
	return a.Text
}

func (a *AskRequest) GetAttachments() []*AttachmentRequest {
	if a == nil {
		return nil
	}
	return a.Attachments
}

func (a *AskRequest) GetTransientData() map[string]string {
	if a == nil {
		return nil
	}
	return a.TransientData
}

func (a *AskRequest) GetTimezone() *string {
	if a == nil {
		return nil
	}
	return a.Timezone
}

func (a *AskRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AskRequest) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetConversationMessageId sets the ConversationMessageId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskRequest) SetConversationMessageId(conversationMessageId *EntityIdBase) {
	a.ConversationMessageId = conversationMessageId
	a.require(askRequestFieldConversationMessageId)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskRequest) SetUserId(userId *EntityIdBase) {
	a.UserId = userId
	a.require(askRequestFieldUserId)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskRequest) SetText(text string) {
	a.Text = text
	a.require(askRequestFieldText)
}

// SetAttachments sets the Attachments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskRequest) SetAttachments(attachments []*AttachmentRequest) {
	a.Attachments = attachments
	a.require(askRequestFieldAttachments)
}

// SetTransientData sets the TransientData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskRequest) SetTransientData(transientData map[string]string) {
	a.TransientData = transientData
	a.require(askRequestFieldTransientData)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskRequest) SetTimezone(timezone *string) {
	a.Timezone = timezone
	a.require(askRequestFieldTimezone)
}

func (a *AskRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AskRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AskRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AskRequest) MarshalJSON() ([]byte, error) {
	type embed AskRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AskRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	askStreamActionEventFieldId          = big.NewInt(1 << 0)
	askStreamActionEventFieldActionId    = big.NewInt(1 << 1)
	askStreamActionEventFieldFormLabel   = big.NewInt(1 << 2)
	askStreamActionEventFieldFields      = big.NewInt(1 << 3)
	askStreamActionEventFieldSubmitLabel = big.NewInt(1 << 4)
)

type AskStreamActionEvent struct {
	// The ID to use when submitting the form via the `submitActionForm` API.
	Id string `json:"id" url:"id"`
	// The ID of the action that will be executed when the form is submitted.
	ActionId *EntityIdWithoutAgent `json:"actionId" url:"actionId"`
	// Text which should be displayed to the user at the top of the form. Provided in the user's language.
	FormLabel string `json:"formLabel" url:"formLabel"`
	// The fields that should be displayed within the form.
	Fields []*ActionFormField `json:"fields" url:"fields"`
	// Text that should be displayed to the user on the submit button. Provided in the user's language.
	SubmitLabel string `json:"submitLabel" url:"submitLabel"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AskStreamActionEvent) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *AskStreamActionEvent) GetActionId() *EntityIdWithoutAgent {
	if a == nil {
		return nil
	}
	return a.ActionId
}

func (a *AskStreamActionEvent) GetFormLabel() string {
	if a == nil {
		return ""
	}
	return a.FormLabel
}

func (a *AskStreamActionEvent) GetFields() []*ActionFormField {
	if a == nil {
		return nil
	}
	return a.Fields
}

func (a *AskStreamActionEvent) GetSubmitLabel() string {
	if a == nil {
		return ""
	}
	return a.SubmitLabel
}

func (a *AskStreamActionEvent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AskStreamActionEvent) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamActionEvent) SetId(id string) {
	a.Id = id
	a.require(askStreamActionEventFieldId)
}

// SetActionId sets the ActionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamActionEvent) SetActionId(actionId *EntityIdWithoutAgent) {
	a.ActionId = actionId
	a.require(askStreamActionEventFieldActionId)
}

// SetFormLabel sets the FormLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamActionEvent) SetFormLabel(formLabel string) {
	a.FormLabel = formLabel
	a.require(askStreamActionEventFieldFormLabel)
}

// SetFields sets the Fields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamActionEvent) SetFields(fields []*ActionFormField) {
	a.Fields = fields
	a.require(askStreamActionEventFieldFields)
}

// SetSubmitLabel sets the SubmitLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamActionEvent) SetSubmitLabel(submitLabel string) {
	a.SubmitLabel = submitLabel
	a.require(askStreamActionEventFieldSubmitLabel)
}

func (a *AskStreamActionEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler AskStreamActionEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AskStreamActionEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AskStreamActionEvent) MarshalJSON() ([]byte, error) {
	type embed AskStreamActionEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AskStreamActionEvent) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	askStreamChartEventFieldLabel      = big.NewInt(1 << 0)
	askStreamChartEventFieldSpecSchema = big.NewInt(1 << 1)
	askStreamChartEventFieldSpec       = big.NewInt(1 << 2)
)

type AskStreamChartEvent struct {
	// The label of the chart
	Label      string          `json:"label" url:"label"`
	SpecSchema ChartSpecSchema `json:"specSchema" url:"specSchema"`
	// The spec string for the chart. For HIGHCHARTS_TS charts, the spec is the json object that represents the chart options.
	Spec string `json:"spec" url:"spec"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AskStreamChartEvent) GetLabel() string {
	if a == nil {
		return ""
	}
	return a.Label
}

func (a *AskStreamChartEvent) GetSpecSchema() ChartSpecSchema {
	if a == nil {
		return ""
	}
	return a.SpecSchema
}

func (a *AskStreamChartEvent) GetSpec() string {
	if a == nil {
		return ""
	}
	return a.Spec
}

func (a *AskStreamChartEvent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AskStreamChartEvent) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamChartEvent) SetLabel(label string) {
	a.Label = label
	a.require(askStreamChartEventFieldLabel)
}

// SetSpecSchema sets the SpecSchema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamChartEvent) SetSpecSchema(specSchema ChartSpecSchema) {
	a.SpecSchema = specSchema
	a.require(askStreamChartEventFieldSpecSchema)
}

// SetSpec sets the Spec field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamChartEvent) SetSpec(spec string) {
	a.Spec = spec
	a.require(askStreamChartEventFieldSpec)
}

func (a *AskStreamChartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler AskStreamChartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AskStreamChartEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AskStreamChartEvent) MarshalJSON() ([]byte, error) {
	type embed AskStreamChartEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AskStreamChartEvent) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	askStreamEndEventFieldError = big.NewInt(1 << 0)
)

type AskStreamEndEvent struct {
	Error *ErrorMessage `json:"error,omitempty" url:"error,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AskStreamEndEvent) GetError() *ErrorMessage {
	if a == nil {
		return nil
	}
	return a.Error
}

func (a *AskStreamEndEvent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AskStreamEndEvent) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetError sets the Error field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamEndEvent) SetError(error_ *ErrorMessage) {
	a.Error = error_
	a.require(askStreamEndEventFieldError)
}

func (a *AskStreamEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler AskStreamEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AskStreamEndEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AskStreamEndEvent) MarshalJSON() ([]byte, error) {
	type embed AskStreamEndEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AskStreamEndEvent) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	askStreamMetadataEventFieldFollowupQuestions = big.NewInt(1 << 0)
	askStreamMetadataEventFieldSources           = big.NewInt(1 << 1)
	askStreamMetadataEventFieldLanguage          = big.NewInt(1 << 2)
)

type AskStreamMetadataEvent struct {
	FollowupQuestions []string  `json:"followupQuestions" url:"followupQuestions"`
	Sources           []*Source `json:"sources" url:"sources"`
	// The language of the message in ISO 639-1 code format
	Language *string `json:"language,omitempty" url:"language,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AskStreamMetadataEvent) GetFollowupQuestions() []string {
	if a == nil {
		return nil
	}
	return a.FollowupQuestions
}

func (a *AskStreamMetadataEvent) GetSources() []*Source {
	if a == nil {
		return nil
	}
	return a.Sources
}

func (a *AskStreamMetadataEvent) GetLanguage() *string {
	if a == nil {
		return nil
	}
	return a.Language
}

func (a *AskStreamMetadataEvent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AskStreamMetadataEvent) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetFollowupQuestions sets the FollowupQuestions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamMetadataEvent) SetFollowupQuestions(followupQuestions []string) {
	a.FollowupQuestions = followupQuestions
	a.require(askStreamMetadataEventFieldFollowupQuestions)
}

// SetSources sets the Sources field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamMetadataEvent) SetSources(sources []*Source) {
	a.Sources = sources
	a.require(askStreamMetadataEventFieldSources)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamMetadataEvent) SetLanguage(language *string) {
	a.Language = language
	a.require(askStreamMetadataEventFieldLanguage)
}

func (a *AskStreamMetadataEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler AskStreamMetadataEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AskStreamMetadataEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AskStreamMetadataEvent) MarshalJSON() ([]byte, error) {
	type embed AskStreamMetadataEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AskStreamMetadataEvent) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	askStreamOAuthButtonEventFieldButtonName = big.NewInt(1 << 0)
	askStreamOAuthButtonEventFieldUrl        = big.NewInt(1 << 1)
)

type AskStreamOAuthButtonEvent struct {
	// Text that should be displayed to the user on the button.
	ButtonName string `json:"buttonName" url:"buttonName"`
	// The OAuth authorization URL to open when the button is clicked. Will only be provided on ask responses.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AskStreamOAuthButtonEvent) GetButtonName() string {
	if a == nil {
		return ""
	}
	return a.ButtonName
}

func (a *AskStreamOAuthButtonEvent) GetUrl() *string {
	if a == nil {
		return nil
	}
	return a.Url
}

func (a *AskStreamOAuthButtonEvent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AskStreamOAuthButtonEvent) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetButtonName sets the ButtonName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamOAuthButtonEvent) SetButtonName(buttonName string) {
	a.ButtonName = buttonName
	a.require(askStreamOAuthButtonEventFieldButtonName)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamOAuthButtonEvent) SetUrl(url *string) {
	a.Url = url
	a.require(askStreamOAuthButtonEventFieldUrl)
}

func (a *AskStreamOAuthButtonEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler AskStreamOAuthButtonEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AskStreamOAuthButtonEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AskStreamOAuthButtonEvent) MarshalJSON() ([]byte, error) {
	type embed AskStreamOAuthButtonEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AskStreamOAuthButtonEvent) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	askStreamStartEventFieldConversationMessageId = big.NewInt(1 << 0)
)

type AskStreamStartEvent struct {
	ConversationMessageId *EntityId `json:"conversationMessageId" url:"conversationMessageId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AskStreamStartEvent) GetConversationMessageId() *EntityId {
	if a == nil {
		return nil
	}
	return a.ConversationMessageId
}

func (a *AskStreamStartEvent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AskStreamStartEvent) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetConversationMessageId sets the ConversationMessageId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamStartEvent) SetConversationMessageId(conversationMessageId *EntityId) {
	a.ConversationMessageId = conversationMessageId
	a.require(askStreamStartEventFieldConversationMessageId)
}

func (a *AskStreamStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler AskStreamStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AskStreamStartEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AskStreamStartEvent) MarshalJSON() ([]byte, error) {
	type embed AskStreamStartEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AskStreamStartEvent) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	askStreamTextEventFieldContents = big.NewInt(1 << 0)
)

type AskStreamTextEvent struct {
	// A partial response to the question. All stream text events should be concatenated to form the full response.
	Contents string `json:"contents" url:"contents"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AskStreamTextEvent) GetContents() string {
	if a == nil {
		return ""
	}
	return a.Contents
}

func (a *AskStreamTextEvent) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AskStreamTextEvent) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetContents sets the Contents field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AskStreamTextEvent) SetContents(contents string) {
	a.Contents = contents
	a.require(askStreamTextEventFieldContents)
}

func (a *AskStreamTextEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler AskStreamTextEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AskStreamTextEvent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AskStreamTextEvent) MarshalJSON() ([]byte, error) {
	type embed AskStreamTextEvent
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AskStreamTextEvent) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	categorizationResponseFieldCategory = big.NewInt(1 << 0)
)

type CategorizationResponse struct {
	Category *string `json:"category,omitempty" url:"category,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CategorizationResponse) GetCategory() *string {
	if c == nil {
		return nil
	}
	return c.Category
}

func (c *CategorizationResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CategorizationResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetCategory sets the Category field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CategorizationResponse) SetCategory(category *string) {
	c.Category = category
	c.require(categorizationResponseFieldCategory)
}

func (c *CategorizationResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CategorizationResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CategorizationResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CategorizationResponse) MarshalJSON() ([]byte, error) {
	type embed CategorizationResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CategorizationResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConversationField string

const (
	ConversationFieldCategory               ConversationField = "Category"
	ConversationFieldFirstResponseTime      ConversationField = "FirstResponseTime"
	ConversationFieldHandleTime             ConversationField = "HandleTime"
	ConversationFieldHumanAgents            ConversationField = "HumanAgents"
	ConversationFieldHumanAgentsWithInserts ConversationField = "HumanAgentsWithInserts"
	ConversationFieldApp                    ConversationField = "App"
	ConversationFieldSentiment              ConversationField = "Sentiment"
	ConversationFieldQualityReason          ConversationField = "QualityReason"
	ConversationFieldResolutionStatus       ConversationField = "ResolutionStatus"
	ConversationFieldResolvedByMaven        ConversationField = "ResolvedByMaven"
	ConversationFieldQuality                ConversationField = "Quality"
	ConversationFieldUsers                  ConversationField = "Users"
	ConversationFieldResponseLength         ConversationField = "ResponseLength"
	ConversationFieldThumbsUpCount          ConversationField = "ThumbsUpCount"
	ConversationFieldThumbsDownCount        ConversationField = "ThumbsDownCount"
	ConversationFieldInsertCount            ConversationField = "InsertCount"
	ConversationFieldTags                   ConversationField = "Tags"
	ConversationFieldUserMessageCount       ConversationField = "UserMessageCount"
	ConversationFieldLanguages              ConversationField = "Languages"
	ConversationFieldActions                ConversationField = "Actions"
	ConversationFieldIncompleteActions      ConversationField = "IncompleteActions"
	ConversationFieldSources                ConversationField = "Sources"
	ConversationFieldCreatedAt              ConversationField = "CreatedAt"
	ConversationFieldPredictedNps           ConversationField = "PredictedNPS"
	ConversationFieldOrganizationId         ConversationField = "OrganizationId"
	ConversationFieldAgentId                ConversationField = "AgentId"
	ConversationFieldInboxItems             ConversationField = "InboxItems"
)

func NewConversationFieldFromString(s string) (ConversationField, error) {
	switch s {
	case "Category":
		return ConversationFieldCategory, nil
	case "FirstResponseTime":
		return ConversationFieldFirstResponseTime, nil
	case "HandleTime":
		return ConversationFieldHandleTime, nil
	case "HumanAgents":
		return ConversationFieldHumanAgents, nil
	case "HumanAgentsWithInserts":
		return ConversationFieldHumanAgentsWithInserts, nil
	case "App":
		return ConversationFieldApp, nil
	case "Sentiment":
		return ConversationFieldSentiment, nil
	case "QualityReason":
		return ConversationFieldQualityReason, nil
	case "ResolutionStatus":
		return ConversationFieldResolutionStatus, nil
	case "ResolvedByMaven":
		return ConversationFieldResolvedByMaven, nil
	case "Quality":
		return ConversationFieldQuality, nil
	case "Users":
		return ConversationFieldUsers, nil
	case "ResponseLength":
		return ConversationFieldResponseLength, nil
	case "ThumbsUpCount":
		return ConversationFieldThumbsUpCount, nil
	case "ThumbsDownCount":
		return ConversationFieldThumbsDownCount, nil
	case "InsertCount":
		return ConversationFieldInsertCount, nil
	case "Tags":
		return ConversationFieldTags, nil
	case "UserMessageCount":
		return ConversationFieldUserMessageCount, nil
	case "Languages":
		return ConversationFieldLanguages, nil
	case "Actions":
		return ConversationFieldActions, nil
	case "IncompleteActions":
		return ConversationFieldIncompleteActions, nil
	case "Sources":
		return ConversationFieldSources, nil
	case "CreatedAt":
		return ConversationFieldCreatedAt, nil
	case "PredictedNPS":
		return ConversationFieldPredictedNps, nil
	case "OrganizationId":
		return ConversationFieldOrganizationId, nil
	case "AgentId":
		return ConversationFieldAgentId, nil
	case "InboxItems":
		return ConversationFieldInboxItems, nil
	}
	var t ConversationField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConversationField) Ptr() *ConversationField {
	return &c
}

var (
	conversationFilterFieldSearch                 = big.NewInt(1 << 0)
	conversationFilterFieldCreatedAfter           = big.NewInt(1 << 1)
	conversationFilterFieldCreatedBefore          = big.NewInt(1 << 2)
	conversationFilterFieldApps                   = big.NewInt(1 << 3)
	conversationFilterFieldCategories             = big.NewInt(1 << 4)
	conversationFilterFieldActions                = big.NewInt(1 << 5)
	conversationFilterFieldIncompleteActions      = big.NewInt(1 << 6)
	conversationFilterFieldFeedback               = big.NewInt(1 << 7)
	conversationFilterFieldHumanAgents            = big.NewInt(1 << 8)
	conversationFilterFieldHumanAgentsWithInserts = big.NewInt(1 << 9)
	conversationFilterFieldLanguages              = big.NewInt(1 << 10)
	conversationFilterFieldQuality                = big.NewInt(1 << 11)
	conversationFilterFieldQualityReason          = big.NewInt(1 << 12)
	conversationFilterFieldResponseLength         = big.NewInt(1 << 13)
	conversationFilterFieldSentiment              = big.NewInt(1 << 14)
	conversationFilterFieldTags                   = big.NewInt(1 << 15)
	conversationFilterFieldAgentUserIds           = big.NewInt(1 << 16)
	conversationFilterFieldResolutionStatus       = big.NewInt(1 << 17)
	conversationFilterFieldResolvedByMaven        = big.NewInt(1 << 18)
	conversationFilterFieldUserMessageCount       = big.NewInt(1 << 19)
	conversationFilterFieldHasAttachment          = big.NewInt(1 << 20)
	conversationFilterFieldMatchedSegmentIds      = big.NewInt(1 << 21)
	conversationFilterFieldInboxItemIds           = big.NewInt(1 << 22)
	conversationFilterFieldSimulationFilter       = big.NewInt(1 << 23)
)

type ConversationFilter struct {
	// Full-text search query for matching conversations by content.
	// When you search with this parameter, you're performing a full-text search across all textual content
	// in the conversations, including both the user's messages and the AI's responses.
	//
	// This field also supports a syntax for advanced filtering the `metadata` and `tags` fields.
	//
	// Metadata examples:
	// - `metadata:myvalue` - matches conversations with any metadata field set to `myvalue`
	// - `metadata.mykey:myvalue` - matches conversations with a metadata field `mykey` set to `myvalue`
	// - `metadata.mykey:myvalue OR anothervalue` - matches conversations with a metadata field `mykey` set to `myvalue` or `anothervalue`
	// - `metadata.mykey:*` - matches conversations with a metadata field `mykey`
	// - `-metadata:myvalue` - matches conversations that do not have any metadata field set to `myvalue`
	// - `_exists_:metadata` - matches conversations that have any metadata field set
	//
	// Tags examples:
	// - `tags:myvalue` - matches conversations with a tag of `myvalue`
	// - `tags:myvalue OR anothervalue` - matches conversations with a tag of `myvalue` or `anothervalue`
	// - `-tags:myvalue` - matches conversations that do not have the tag `myvalue`
	// - `_exists_:tags` - matches conversations that have any tags field set
	Search *string `json:"search,omitempty" url:"search,omitempty"`
	// Filter conversations created on or after this timestamp
	CreatedAfter *time.Time `json:"createdAfter,omitempty" url:"createdAfter,omitempty"`
	// Filter conversations created on or before this timestamp
	CreatedBefore *time.Time `json:"createdBefore,omitempty" url:"createdBefore,omitempty"`
	// Filter by app IDs
	Apps []string `json:"apps,omitempty" url:"apps,omitempty"`
	// Filter by conversation categories
	Categories []string `json:"categories,omitempty" url:"categories,omitempty"`
	// Filter by actions that were executed in the conversation
	Actions []*EntityIdFilter `json:"actions,omitempty" url:"actions,omitempty"`
	// Filter by actions that were suggested but not completed by the AI agent
	IncompleteActions []*EntityIdFilter `json:"incompleteActions,omitempty" url:"incompleteActions,omitempty"`
	// Filter by feedback types received in the conversation.
	// This is a legacy field that maps to Events saved in the system for `ThumbsUp`, `ThumbsDown`, and `Insert`.
	// The `Handoff` filter will pass if any bot responses on the conversation returned the system fallback message; there are no corresponding handoff events.
	Feedback []FeedbackType `json:"feedback,omitempty" url:"feedback,omitempty"`
	// Filter by human agents who participated in the conversation
	HumanAgents []string `json:"humanAgents,omitempty" url:"humanAgents,omitempty"`
	// Filter by human agents who inserted a maven AI generated suggestion in the conversation
	HumanAgentsWithInserts []string `json:"humanAgentsWithInserts,omitempty" url:"humanAgentsWithInserts,omitempty"`
	// Filter by conversation languages
	Languages []string `json:"languages,omitempty" url:"languages,omitempty"`
	// Filter by AI assessed conversation quality classification
	Quality []Quality `json:"quality,omitempty" url:"quality,omitempty"`
	// Filter by AI assessed quality reason classification
	QualityReason []QualityReason `json:"qualityReason,omitempty" url:"qualityReason,omitempty"`
	// Filter by AI response length classification
	ResponseLength []ResponseLength `json:"responseLength,omitempty" url:"responseLength,omitempty"`
	// Filter by AI assessed sentiment analysis
	Sentiment []Sentiment `json:"sentiment,omitempty" url:"sentiment,omitempty"`
	// Filter by tags applied to the conversation
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// Filter by agent user IDs associated with the conversation
	AgentUserIds []string `json:"agentUserIds,omitempty" url:"agentUserIds,omitempty"`
	// Filter by conversation resolution status which is determined by AI based on the conversation content.
	ResolutionStatus []ResolutionStatus `json:"resolutionStatus,omitempty" url:"resolutionStatus,omitempty"`
	// Filter conversations based on whether they were resolved by Maven AI
	ResolvedByMaven *bool `json:"resolvedByMaven,omitempty" url:"resolvedByMaven,omitempty"`
	// Filter by the number of messages sent by the user in the conversation
	UserMessageCount *NumberRange `json:"userMessageCount,omitempty" url:"userMessageCount,omitempty"`
	// Filter by whether any message in the conversation has an attachment
	HasAttachment *bool `json:"hasAttachment,omitempty" url:"hasAttachment,omitempty"`
	// Filter by the segments that any message on a conversation matched.
	MatchedSegmentIds []*EntityIdFilter `json:"matchedSegmentIds,omitempty" url:"matchedSegmentIds,omitempty"`
	// Filter by inbox item IDs associated with the conversation
	InboxItemIds []*EntityIdFilter `json:"inboxItemIds,omitempty" url:"inboxItemIds,omitempty"`
	// Whether to include simulation conversations in search results. Defaults to only non-simulation conversations.
	SimulationFilter *SimulationFilter `json:"simulationFilter,omitempty" url:"simulationFilter,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationFilter) GetSearch() *string {
	if c == nil {
		return nil
	}
	return c.Search
}

func (c *ConversationFilter) GetCreatedAfter() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAfter
}

func (c *ConversationFilter) GetCreatedBefore() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedBefore
}

func (c *ConversationFilter) GetApps() []string {
	if c == nil {
		return nil
	}
	return c.Apps
}

func (c *ConversationFilter) GetCategories() []string {
	if c == nil {
		return nil
	}
	return c.Categories
}

func (c *ConversationFilter) GetActions() []*EntityIdFilter {
	if c == nil {
		return nil
	}
	return c.Actions
}

func (c *ConversationFilter) GetIncompleteActions() []*EntityIdFilter {
	if c == nil {
		return nil
	}
	return c.IncompleteActions
}

func (c *ConversationFilter) GetFeedback() []FeedbackType {
	if c == nil {
		return nil
	}
	return c.Feedback
}

func (c *ConversationFilter) GetHumanAgents() []string {
	if c == nil {
		return nil
	}
	return c.HumanAgents
}

func (c *ConversationFilter) GetHumanAgentsWithInserts() []string {
	if c == nil {
		return nil
	}
	return c.HumanAgentsWithInserts
}

func (c *ConversationFilter) GetLanguages() []string {
	if c == nil {
		return nil
	}
	return c.Languages
}

func (c *ConversationFilter) GetQuality() []Quality {
	if c == nil {
		return nil
	}
	return c.Quality
}

func (c *ConversationFilter) GetQualityReason() []QualityReason {
	if c == nil {
		return nil
	}
	return c.QualityReason
}

func (c *ConversationFilter) GetResponseLength() []ResponseLength {
	if c == nil {
		return nil
	}
	return c.ResponseLength
}

func (c *ConversationFilter) GetSentiment() []Sentiment {
	if c == nil {
		return nil
	}
	return c.Sentiment
}

func (c *ConversationFilter) GetTags() []string {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *ConversationFilter) GetAgentUserIds() []string {
	if c == nil {
		return nil
	}
	return c.AgentUserIds
}

func (c *ConversationFilter) GetResolutionStatus() []ResolutionStatus {
	if c == nil {
		return nil
	}
	return c.ResolutionStatus
}

func (c *ConversationFilter) GetResolvedByMaven() *bool {
	if c == nil {
		return nil
	}
	return c.ResolvedByMaven
}

func (c *ConversationFilter) GetUserMessageCount() *NumberRange {
	if c == nil {
		return nil
	}
	return c.UserMessageCount
}

func (c *ConversationFilter) GetHasAttachment() *bool {
	if c == nil {
		return nil
	}
	return c.HasAttachment
}

func (c *ConversationFilter) GetMatchedSegmentIds() []*EntityIdFilter {
	if c == nil {
		return nil
	}
	return c.MatchedSegmentIds
}

func (c *ConversationFilter) GetInboxItemIds() []*EntityIdFilter {
	if c == nil {
		return nil
	}
	return c.InboxItemIds
}

func (c *ConversationFilter) GetSimulationFilter() *SimulationFilter {
	if c == nil {
		return nil
	}
	return c.SimulationFilter
}

func (c *ConversationFilter) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationFilter) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetSearch sets the Search field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetSearch(search *string) {
	c.Search = search
	c.require(conversationFilterFieldSearch)
}

// SetCreatedAfter sets the CreatedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetCreatedAfter(createdAfter *time.Time) {
	c.CreatedAfter = createdAfter
	c.require(conversationFilterFieldCreatedAfter)
}

// SetCreatedBefore sets the CreatedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetCreatedBefore(createdBefore *time.Time) {
	c.CreatedBefore = createdBefore
	c.require(conversationFilterFieldCreatedBefore)
}

// SetApps sets the Apps field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetApps(apps []string) {
	c.Apps = apps
	c.require(conversationFilterFieldApps)
}

// SetCategories sets the Categories field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetCategories(categories []string) {
	c.Categories = categories
	c.require(conversationFilterFieldCategories)
}

// SetActions sets the Actions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetActions(actions []*EntityIdFilter) {
	c.Actions = actions
	c.require(conversationFilterFieldActions)
}

// SetIncompleteActions sets the IncompleteActions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetIncompleteActions(incompleteActions []*EntityIdFilter) {
	c.IncompleteActions = incompleteActions
	c.require(conversationFilterFieldIncompleteActions)
}

// SetFeedback sets the Feedback field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetFeedback(feedback []FeedbackType) {
	c.Feedback = feedback
	c.require(conversationFilterFieldFeedback)
}

// SetHumanAgents sets the HumanAgents field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetHumanAgents(humanAgents []string) {
	c.HumanAgents = humanAgents
	c.require(conversationFilterFieldHumanAgents)
}

// SetHumanAgentsWithInserts sets the HumanAgentsWithInserts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetHumanAgentsWithInserts(humanAgentsWithInserts []string) {
	c.HumanAgentsWithInserts = humanAgentsWithInserts
	c.require(conversationFilterFieldHumanAgentsWithInserts)
}

// SetLanguages sets the Languages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetLanguages(languages []string) {
	c.Languages = languages
	c.require(conversationFilterFieldLanguages)
}

// SetQuality sets the Quality field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetQuality(quality []Quality) {
	c.Quality = quality
	c.require(conversationFilterFieldQuality)
}

// SetQualityReason sets the QualityReason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetQualityReason(qualityReason []QualityReason) {
	c.QualityReason = qualityReason
	c.require(conversationFilterFieldQualityReason)
}

// SetResponseLength sets the ResponseLength field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetResponseLength(responseLength []ResponseLength) {
	c.ResponseLength = responseLength
	c.require(conversationFilterFieldResponseLength)
}

// SetSentiment sets the Sentiment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetSentiment(sentiment []Sentiment) {
	c.Sentiment = sentiment
	c.require(conversationFilterFieldSentiment)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetTags(tags []string) {
	c.Tags = tags
	c.require(conversationFilterFieldTags)
}

// SetAgentUserIds sets the AgentUserIds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetAgentUserIds(agentUserIds []string) {
	c.AgentUserIds = agentUserIds
	c.require(conversationFilterFieldAgentUserIds)
}

// SetResolutionStatus sets the ResolutionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetResolutionStatus(resolutionStatus []ResolutionStatus) {
	c.ResolutionStatus = resolutionStatus
	c.require(conversationFilterFieldResolutionStatus)
}

// SetResolvedByMaven sets the ResolvedByMaven field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetResolvedByMaven(resolvedByMaven *bool) {
	c.ResolvedByMaven = resolvedByMaven
	c.require(conversationFilterFieldResolvedByMaven)
}

// SetUserMessageCount sets the UserMessageCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetUserMessageCount(userMessageCount *NumberRange) {
	c.UserMessageCount = userMessageCount
	c.require(conversationFilterFieldUserMessageCount)
}

// SetHasAttachment sets the HasAttachment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetHasAttachment(hasAttachment *bool) {
	c.HasAttachment = hasAttachment
	c.require(conversationFilterFieldHasAttachment)
}

// SetMatchedSegmentIds sets the MatchedSegmentIds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetMatchedSegmentIds(matchedSegmentIds []*EntityIdFilter) {
	c.MatchedSegmentIds = matchedSegmentIds
	c.require(conversationFilterFieldMatchedSegmentIds)
}

// SetInboxItemIds sets the InboxItemIds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetInboxItemIds(inboxItemIds []*EntityIdFilter) {
	c.InboxItemIds = inboxItemIds
	c.require(conversationFilterFieldInboxItemIds)
}

// SetSimulationFilter sets the SimulationFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationFilter) SetSimulationFilter(simulationFilter *SimulationFilter) {
	c.SimulationFilter = simulationFilter
	c.require(conversationFilterFieldSimulationFilter)
}

func (c *ConversationFilter) UnmarshalJSON(data []byte) error {
	type embed ConversationFilter
	var unmarshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationFilter(unmarshaler.embed)
	c.CreatedAfter = unmarshaler.CreatedAfter.TimePtr()
	c.CreatedBefore = unmarshaler.CreatedBefore.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationFilter) MarshalJSON() ([]byte, error) {
	type embed ConversationFilter
	var marshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed:         embed(*c),
		CreatedAfter:  internal.NewOptionalDateTime(c.CreatedAfter),
		CreatedBefore: internal.NewOptionalDateTime(c.CreatedBefore),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationFilter) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationMessageRequestFieldCreatedAt             = big.NewInt(1 << 0)
	conversationMessageRequestFieldUpdatedAt             = big.NewInt(1 << 1)
	conversationMessageRequestFieldUserId                = big.NewInt(1 << 2)
	conversationMessageRequestFieldText                  = big.NewInt(1 << 3)
	conversationMessageRequestFieldUserMessageType       = big.NewInt(1 << 4)
	conversationMessageRequestFieldConversationMessageId = big.NewInt(1 << 5)
	conversationMessageRequestFieldAttachments           = big.NewInt(1 << 6)
)

type ConversationMessageRequest struct {
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// ID that uniquely identifies the user that created this message
	UserId *EntityIdBase `json:"userId" url:"userId"`
	// The text of the message. Cannot be empty
	Text            string                      `json:"text" url:"text"`
	UserMessageType UserConversationMessageType `json:"userMessageType" url:"userMessageType"`
	// The ID that uniquely identifies this message within the conversation
	ConversationMessageId *EntityIdBase `json:"conversationMessageId" url:"conversationMessageId"`
	// The attachments to the message.
	Attachments []*AttachmentRequest `json:"attachments,omitempty" url:"attachments,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationMessageRequest) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *ConversationMessageRequest) GetUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *ConversationMessageRequest) GetUserId() *EntityIdBase {
	if c == nil {
		return nil
	}
	return c.UserId
}

func (c *ConversationMessageRequest) GetText() string {
	if c == nil {
		return ""
	}
	return c.Text
}

func (c *ConversationMessageRequest) GetUserMessageType() UserConversationMessageType {
	if c == nil {
		return ""
	}
	return c.UserMessageType
}

func (c *ConversationMessageRequest) GetConversationMessageId() *EntityIdBase {
	if c == nil {
		return nil
	}
	return c.ConversationMessageId
}

func (c *ConversationMessageRequest) GetAttachments() []*AttachmentRequest {
	if c == nil {
		return nil
	}
	return c.Attachments
}

func (c *ConversationMessageRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationMessageRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMessageRequest) SetCreatedAt(createdAt *time.Time) {
	c.CreatedAt = createdAt
	c.require(conversationMessageRequestFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMessageRequest) SetUpdatedAt(updatedAt *time.Time) {
	c.UpdatedAt = updatedAt
	c.require(conversationMessageRequestFieldUpdatedAt)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMessageRequest) SetUserId(userId *EntityIdBase) {
	c.UserId = userId
	c.require(conversationMessageRequestFieldUserId)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMessageRequest) SetText(text string) {
	c.Text = text
	c.require(conversationMessageRequestFieldText)
}

// SetUserMessageType sets the UserMessageType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMessageRequest) SetUserMessageType(userMessageType UserConversationMessageType) {
	c.UserMessageType = userMessageType
	c.require(conversationMessageRequestFieldUserMessageType)
}

// SetConversationMessageId sets the ConversationMessageId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMessageRequest) SetConversationMessageId(conversationMessageId *EntityIdBase) {
	c.ConversationMessageId = conversationMessageId
	c.require(conversationMessageRequestFieldConversationMessageId)
}

// SetAttachments sets the Attachments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMessageRequest) SetAttachments(attachments []*AttachmentRequest) {
	c.Attachments = attachments
	c.require(conversationMessageRequestFieldAttachments)
}

func (c *ConversationMessageRequest) UnmarshalJSON(data []byte) error {
	type embed ConversationMessageRequest
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationMessageRequest(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationMessageRequest) MarshalJSON() ([]byte, error) {
	type embed ConversationMessageRequest
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewOptionalDateTime(c.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationMessageRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationMetadataFieldMetadata = big.NewInt(1 << 0)
)

type ConversationMetadata struct {
	// All metadata for the conversation. Keyed by appId.
	Metadata map[string]map[string]string `json:"metadata" url:"metadata"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationMetadata) GetMetadata() map[string]map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ConversationMetadata) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationMetadata) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMetadata) SetMetadata(metadata map[string]map[string]string) {
	c.Metadata = metadata
	c.require(conversationMetadataFieldMetadata)
}

func (c *ConversationMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationMetadata) MarshalJSON() ([]byte, error) {
	type embed ConversationMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationMetadata) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationPatchRequestFieldAppId       = big.NewInt(1 << 0)
	conversationPatchRequestFieldOpen        = big.NewInt(1 << 1)
	conversationPatchRequestFieldLlmEnabled  = big.NewInt(1 << 2)
	conversationPatchRequestFieldAttachments = big.NewInt(1 << 3)
)

type ConversationPatchRequest struct {
	// The App ID of the conversation to patch. If not provided the ID of the calling app will be used.
	AppId *string `json:"appId,omitempty" url:"appId,omitempty"`
	// Whether the conversation is able to receive asynchronous messages. Only valid for conversations with the `ASYNC` capability.
	Open *bool `json:"open,omitempty" url:"open,omitempty"`
	// Whether the LLM is enabled for this conversation.
	LlmEnabled *bool `json:"llmEnabled,omitempty" url:"llmEnabled,omitempty"`
	// A list of attachments to add to the conversation. Attachments can only be appended. Removal is not allowed.
	Attachments []*AttachmentRequest `json:"attachments,omitempty" url:"attachments,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationPatchRequest) GetAppId() *string {
	if c == nil {
		return nil
	}
	return c.AppId
}

func (c *ConversationPatchRequest) GetOpen() *bool {
	if c == nil {
		return nil
	}
	return c.Open
}

func (c *ConversationPatchRequest) GetLlmEnabled() *bool {
	if c == nil {
		return nil
	}
	return c.LlmEnabled
}

func (c *ConversationPatchRequest) GetAttachments() []*AttachmentRequest {
	if c == nil {
		return nil
	}
	return c.Attachments
}

func (c *ConversationPatchRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationPatchRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPatchRequest) SetAppId(appId *string) {
	c.AppId = appId
	c.require(conversationPatchRequestFieldAppId)
}

// SetOpen sets the Open field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPatchRequest) SetOpen(open *bool) {
	c.Open = open
	c.require(conversationPatchRequestFieldOpen)
}

// SetLlmEnabled sets the LlmEnabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPatchRequest) SetLlmEnabled(llmEnabled *bool) {
	c.LlmEnabled = llmEnabled
	c.require(conversationPatchRequestFieldLlmEnabled)
}

// SetAttachments sets the Attachments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPatchRequest) SetAttachments(attachments []*AttachmentRequest) {
	c.Attachments = attachments
	c.require(conversationPatchRequestFieldAttachments)
}

func (c *ConversationPatchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationPatchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationPatchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationPatchRequest) MarshalJSON() ([]byte, error) {
	type embed ConversationPatchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationPatchRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationRequestFieldConversationId    = big.NewInt(1 << 0)
	conversationRequestFieldSimulationContext = big.NewInt(1 << 1)
	conversationRequestFieldResponseConfig    = big.NewInt(1 << 2)
	conversationRequestFieldSubject           = big.NewInt(1 << 3)
	conversationRequestFieldUrl               = big.NewInt(1 << 4)
	conversationRequestFieldCreatedAt         = big.NewInt(1 << 5)
	conversationRequestFieldUpdatedAt         = big.NewInt(1 << 6)
	conversationRequestFieldTags              = big.NewInt(1 << 7)
	conversationRequestFieldMetadata          = big.NewInt(1 << 8)
	conversationRequestFieldMessages          = big.NewInt(1 << 9)
)

type ConversationRequest struct {
	// An externally supplied ID to uniquely identify this conversation
	ConversationId *EntityIdBase `json:"conversationId" url:"conversationId"`
	// Additional context used for simulation runs. When provided, this conversation will be treated as a simulation and
	// may only be created by apps with the appropriate permission. Simulation conversations are excluded from normal
	// search results unless explicitly included via the `simulationFilter` field.
	SimulationContext *SimulationContext `json:"simulationContext,omitempty" url:"simulationContext,omitempty"`
	// Optional configurations for responses to this conversation
	ResponseConfig *ResponseConfig `json:"responseConfig,omitempty" url:"responseConfig,omitempty"`
	// The subject of the conversation
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The url of the conversation
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// The tags of the conversation. Used for filtering in Agent Designer.
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// The metadata of the conversation supplied by the app which created the conversation.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// The messages in the conversation
	Messages []*ConversationMessageRequest `json:"messages" url:"messages"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationRequest) GetConversationId() *EntityIdBase {
	if c == nil {
		return nil
	}
	return c.ConversationId
}

func (c *ConversationRequest) GetSimulationContext() *SimulationContext {
	if c == nil {
		return nil
	}
	return c.SimulationContext
}

func (c *ConversationRequest) GetResponseConfig() *ResponseConfig {
	if c == nil {
		return nil
	}
	return c.ResponseConfig
}

func (c *ConversationRequest) GetSubject() *string {
	if c == nil {
		return nil
	}
	return c.Subject
}

func (c *ConversationRequest) GetUrl() *string {
	if c == nil {
		return nil
	}
	return c.Url
}

func (c *ConversationRequest) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *ConversationRequest) GetUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *ConversationRequest) GetTags() []string {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *ConversationRequest) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ConversationRequest) GetMessages() []*ConversationMessageRequest {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *ConversationRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetConversationId sets the ConversationId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRequest) SetConversationId(conversationId *EntityIdBase) {
	c.ConversationId = conversationId
	c.require(conversationRequestFieldConversationId)
}

// SetSimulationContext sets the SimulationContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRequest) SetSimulationContext(simulationContext *SimulationContext) {
	c.SimulationContext = simulationContext
	c.require(conversationRequestFieldSimulationContext)
}

// SetResponseConfig sets the ResponseConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRequest) SetResponseConfig(responseConfig *ResponseConfig) {
	c.ResponseConfig = responseConfig
	c.require(conversationRequestFieldResponseConfig)
}

// SetSubject sets the Subject field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRequest) SetSubject(subject *string) {
	c.Subject = subject
	c.require(conversationRequestFieldSubject)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRequest) SetUrl(url *string) {
	c.Url = url
	c.require(conversationRequestFieldUrl)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRequest) SetCreatedAt(createdAt *time.Time) {
	c.CreatedAt = createdAt
	c.require(conversationRequestFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRequest) SetUpdatedAt(updatedAt *time.Time) {
	c.UpdatedAt = updatedAt
	c.require(conversationRequestFieldUpdatedAt)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRequest) SetTags(tags []string) {
	c.Tags = tags
	c.require(conversationRequestFieldTags)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRequest) SetMetadata(metadata map[string]string) {
	c.Metadata = metadata
	c.require(conversationRequestFieldMetadata)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRequest) SetMessages(messages []*ConversationMessageRequest) {
	c.Messages = messages
	c.require(conversationRequestFieldMessages)
}

func (c *ConversationRequest) UnmarshalJSON(data []byte) error {
	type embed ConversationRequest
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationRequest(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationRequest) MarshalJSON() ([]byte, error) {
	type embed ConversationRequest
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewOptionalDateTime(c.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationsResponseFieldNumber        = big.NewInt(1 << 0)
	conversationsResponseFieldSize          = big.NewInt(1 << 1)
	conversationsResponseFieldTotalElements = big.NewInt(1 << 2)
	conversationsResponseFieldTotalPages    = big.NewInt(1 << 3)
	conversationsResponseFieldConversations = big.NewInt(1 << 4)
)

type ConversationsResponse struct {
	// The page being returned, starts at 0
	Number int `json:"number" url:"number"`
	// The number of elements in this page
	Size int `json:"size" url:"size"`
	// The total number of elements in the collection
	TotalElements int64 `json:"totalElements" url:"totalElements"`
	// The total number of pages in the collection
	TotalPages int `json:"totalPages" url:"totalPages"`
	// The conversations that match the search criteria
	Conversations []*ConversationPreview `json:"conversations" url:"conversations"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationsResponse) GetNumber() int {
	if c == nil {
		return 0
	}
	return c.Number
}

func (c *ConversationsResponse) GetSize() int {
	if c == nil {
		return 0
	}
	return c.Size
}

func (c *ConversationsResponse) GetTotalElements() int64 {
	if c == nil {
		return 0
	}
	return c.TotalElements
}

func (c *ConversationsResponse) GetTotalPages() int {
	if c == nil {
		return 0
	}
	return c.TotalPages
}

func (c *ConversationsResponse) GetConversations() []*ConversationPreview {
	if c == nil {
		return nil
	}
	return c.Conversations
}

func (c *ConversationsResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationsResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetNumber sets the Number field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationsResponse) SetNumber(number int) {
	c.Number = number
	c.require(conversationsResponseFieldNumber)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationsResponse) SetSize(size int) {
	c.Size = size
	c.require(conversationsResponseFieldSize)
}

// SetTotalElements sets the TotalElements field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationsResponse) SetTotalElements(totalElements int64) {
	c.TotalElements = totalElements
	c.require(conversationsResponseFieldTotalElements)
}

// SetTotalPages sets the TotalPages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationsResponse) SetTotalPages(totalPages int) {
	c.TotalPages = totalPages
	c.require(conversationsResponseFieldTotalPages)
}

// SetConversations sets the Conversations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationsResponse) SetConversations(conversations []*ConversationPreview) {
	c.Conversations = conversations
	c.require(conversationsResponseFieldConversations)
}

func (c *ConversationsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationsResponse) MarshalJSON() ([]byte, error) {
	type embed ConversationsResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationsResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationsSearchRequestFieldPage     = big.NewInt(1 << 0)
	conversationsSearchRequestFieldSize     = big.NewInt(1 << 1)
	conversationsSearchRequestFieldSortDesc = big.NewInt(1 << 2)
	conversationsSearchRequestFieldSort     = big.NewInt(1 << 3)
	conversationsSearchRequestFieldFilter   = big.NewInt(1 << 4)
)

type ConversationsSearchRequest struct {
	// Page number to return, defaults to 0
	Page *int `json:"page,omitempty" url:"page,omitempty"`
	// The size of the page to return, defaults to 20
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Whether to sort descending, defaults to true
	SortDesc *bool               `json:"sortDesc,omitempty" url:"sortDesc,omitempty"`
	Sort     *ConversationField  `json:"sort,omitempty" url:"sort,omitempty"`
	Filter   *ConversationFilter `json:"filter,omitempty" url:"filter,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationsSearchRequest) GetPage() *int {
	if c == nil {
		return nil
	}
	return c.Page
}

func (c *ConversationsSearchRequest) GetSize() *int {
	if c == nil {
		return nil
	}
	return c.Size
}

func (c *ConversationsSearchRequest) GetSortDesc() *bool {
	if c == nil {
		return nil
	}
	return c.SortDesc
}

func (c *ConversationsSearchRequest) GetSort() *ConversationField {
	if c == nil {
		return nil
	}
	return c.Sort
}

func (c *ConversationsSearchRequest) GetFilter() *ConversationFilter {
	if c == nil {
		return nil
	}
	return c.Filter
}

func (c *ConversationsSearchRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationsSearchRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationsSearchRequest) SetPage(page *int) {
	c.Page = page
	c.require(conversationsSearchRequestFieldPage)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationsSearchRequest) SetSize(size *int) {
	c.Size = size
	c.require(conversationsSearchRequestFieldSize)
}

// SetSortDesc sets the SortDesc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationsSearchRequest) SetSortDesc(sortDesc *bool) {
	c.SortDesc = sortDesc
	c.require(conversationsSearchRequestFieldSortDesc)
}

// SetSort sets the Sort field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationsSearchRequest) SetSort(sort *ConversationField) {
	c.Sort = sort
	c.require(conversationsSearchRequestFieldSort)
}

// SetFilter sets the Filter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationsSearchRequest) SetFilter(filter *ConversationFilter) {
	c.Filter = filter
	c.require(conversationsSearchRequestFieldFilter)
}

func (c *ConversationsSearchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationsSearchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationsSearchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationsSearchRequest) MarshalJSON() ([]byte, error) {
	type embed ConversationsSearchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationsSearchRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	deliverConversationMessageRequestFieldConversationId = big.NewInt(1 << 0)
	deliverConversationMessageRequestFieldMessage        = big.NewInt(1 << 1)
)

type DeliverConversationMessageRequest struct {
	// The ID of the conversation to deliver the message to. Message delivery will fail if the conversation does not have the `ASYNC` capability or if it is not `open`.
	ConversationId *EntityIdWithoutAgent `json:"conversationId" url:"conversationId"`
	// The message to deliver.
	Message *ConversationMessageRequest `json:"message" url:"message"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeliverConversationMessageRequest) GetConversationId() *EntityIdWithoutAgent {
	if d == nil {
		return nil
	}
	return d.ConversationId
}

func (d *DeliverConversationMessageRequest) GetMessage() *ConversationMessageRequest {
	if d == nil {
		return nil
	}
	return d.Message
}

func (d *DeliverConversationMessageRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeliverConversationMessageRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetConversationId sets the ConversationId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeliverConversationMessageRequest) SetConversationId(conversationId *EntityIdWithoutAgent) {
	d.ConversationId = conversationId
	d.require(deliverConversationMessageRequestFieldConversationId)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeliverConversationMessageRequest) SetMessage(message *ConversationMessageRequest) {
	d.Message = message
	d.require(deliverConversationMessageRequestFieldMessage)
}

func (d *DeliverConversationMessageRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeliverConversationMessageRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeliverConversationMessageRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeliverConversationMessageRequest) MarshalJSON() ([]byte, error) {
	type embed DeliverConversationMessageRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeliverConversationMessageRequest) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeliverMessageRequest struct {
	Type         string
	User         *DeliverUserMessageRequest
	Conversation *DeliverConversationMessageRequest
}

func (d *DeliverMessageRequest) GetType() string {
	if d == nil {
		return ""
	}
	return d.Type
}

func (d *DeliverMessageRequest) GetUser() *DeliverUserMessageRequest {
	if d == nil {
		return nil
	}
	return d.User
}

func (d *DeliverMessageRequest) GetConversation() *DeliverConversationMessageRequest {
	if d == nil {
		return nil
	}
	return d.Conversation
}

func (d *DeliverMessageRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	d.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", d)
	}
	switch unmarshaler.Type {
	case "user":
		value := new(DeliverUserMessageRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.User = value
	case "conversation":
		value := new(DeliverConversationMessageRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.Conversation = value
	}
	return nil
}

func (d DeliverMessageRequest) MarshalJSON() ([]byte, error) {
	if err := d.validate(); err != nil {
		return nil, err
	}
	if d.User != nil {
		return internal.MarshalJSONWithExtraProperty(d.User, "type", "user")
	}
	if d.Conversation != nil {
		return internal.MarshalJSONWithExtraProperty(d.Conversation, "type", "conversation")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", d)
}

type DeliverMessageRequestVisitor interface {
	VisitUser(*DeliverUserMessageRequest) error
	VisitConversation(*DeliverConversationMessageRequest) error
}

func (d *DeliverMessageRequest) Accept(visitor DeliverMessageRequestVisitor) error {
	if d.User != nil {
		return visitor.VisitUser(d.User)
	}
	if d.Conversation != nil {
		return visitor.VisitConversation(d.Conversation)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", d)
}

func (d *DeliverMessageRequest) validate() error {
	if d == nil {
		return fmt.Errorf("type %T is nil", d)
	}
	var fields []string
	if d.User != nil {
		fields = append(fields, "user")
	}
	if d.Conversation != nil {
		fields = append(fields, "conversation")
	}
	if len(fields) == 0 {
		if d.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", d, d.Type)
		}
		return fmt.Errorf("type %T is empty", d)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", d, fields)
	}
	if d.Type != "" {
		field := fields[0]
		if d.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				d,
				d.Type,
				d,
			)
		}
	}
	return nil
}

var (
	deliverMessageResponseFieldStatus = big.NewInt(1 << 0)
)

type DeliverMessageResponse struct {
	Status DeliveryStatus `json:"status" url:"status"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeliverMessageResponse) GetStatus() DeliveryStatus {
	if d == nil {
		return ""
	}
	return d.Status
}

func (d *DeliverMessageResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeliverMessageResponse) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeliverMessageResponse) SetStatus(status DeliveryStatus) {
	d.Status = status
	d.require(deliverMessageResponseFieldStatus)
}

func (d *DeliverMessageResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DeliverMessageResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeliverMessageResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeliverMessageResponse) MarshalJSON() ([]byte, error) {
	type embed DeliverMessageResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeliverMessageResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	deliverUserMessageRequestFieldUserId  = big.NewInt(1 << 0)
	deliverUserMessageRequestFieldMessage = big.NewInt(1 << 1)
)

type DeliverUserMessageRequest struct {
	// The ID of the user to deliver the message to.
	UserId *EntityIdWithoutAgent `json:"userId" url:"userId"`
	// The message to deliver.
	Message *ConversationMessageRequest `json:"message" url:"message"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeliverUserMessageRequest) GetUserId() *EntityIdWithoutAgent {
	if d == nil {
		return nil
	}
	return d.UserId
}

func (d *DeliverUserMessageRequest) GetMessage() *ConversationMessageRequest {
	if d == nil {
		return nil
	}
	return d.Message
}

func (d *DeliverUserMessageRequest) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeliverUserMessageRequest) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeliverUserMessageRequest) SetUserId(userId *EntityIdWithoutAgent) {
	d.UserId = userId
	d.require(deliverUserMessageRequestFieldUserId)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeliverUserMessageRequest) SetMessage(message *ConversationMessageRequest) {
	d.Message = message
	d.require(deliverUserMessageRequestFieldMessage)
}

func (d *DeliverUserMessageRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler DeliverUserMessageRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeliverUserMessageRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeliverUserMessageRequest) MarshalJSON() ([]byte, error) {
	type embed DeliverUserMessageRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeliverUserMessageRequest) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeliveryStatus string

const (
	DeliveryStatusDelivered DeliveryStatus = "DELIVERED"
	DeliveryStatusFailed    DeliveryStatus = "FAILED"
	DeliveryStatusQueued    DeliveryStatus = "QUEUED"
)

func NewDeliveryStatusFromString(s string) (DeliveryStatus, error) {
	switch s {
	case "DELIVERED":
		return DeliveryStatusDelivered, nil
	case "FAILED":
		return DeliveryStatusFailed, nil
	case "QUEUED":
		return DeliveryStatusQueued, nil
	}
	var t DeliveryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeliveryStatus) Ptr() *DeliveryStatus {
	return &d
}

type FeedbackField string

const (
	FeedbackFieldType      FeedbackField = "Type"
	FeedbackFieldCreatedBy FeedbackField = "CreatedBy"
	FeedbackFieldCreatedAt FeedbackField = "CreatedAt"
	FeedbackFieldApp       FeedbackField = "App"
)

func NewFeedbackFieldFromString(s string) (FeedbackField, error) {
	switch s {
	case "Type":
		return FeedbackFieldType, nil
	case "CreatedBy":
		return FeedbackFieldCreatedBy, nil
	case "CreatedAt":
		return FeedbackFieldCreatedAt, nil
	case "App":
		return FeedbackFieldApp, nil
	}
	var t FeedbackField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FeedbackField) Ptr() *FeedbackField {
	return &f
}

var (
	feedbackFilterFieldSearch        = big.NewInt(1 << 0)
	feedbackFilterFieldCreatedAfter  = big.NewInt(1 << 1)
	feedbackFilterFieldCreatedBefore = big.NewInt(1 << 2)
	feedbackFilterFieldUsers         = big.NewInt(1 << 3)
	feedbackFilterFieldApps          = big.NewInt(1 << 4)
	feedbackFilterFieldTypes         = big.NewInt(1 << 5)
)

type FeedbackFilter struct {
	Search        *string        `json:"search,omitempty" url:"search,omitempty"`
	CreatedAfter  *time.Time     `json:"createdAfter,omitempty" url:"createdAfter,omitempty"`
	CreatedBefore *time.Time     `json:"createdBefore,omitempty" url:"createdBefore,omitempty"`
	Users         []string       `json:"users,omitempty" url:"users,omitempty"`
	Apps          []string       `json:"apps,omitempty" url:"apps,omitempty"`
	Types         []FeedbackType `json:"types,omitempty" url:"types,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackFilter) GetSearch() *string {
	if f == nil {
		return nil
	}
	return f.Search
}

func (f *FeedbackFilter) GetCreatedAfter() *time.Time {
	if f == nil {
		return nil
	}
	return f.CreatedAfter
}

func (f *FeedbackFilter) GetCreatedBefore() *time.Time {
	if f == nil {
		return nil
	}
	return f.CreatedBefore
}

func (f *FeedbackFilter) GetUsers() []string {
	if f == nil {
		return nil
	}
	return f.Users
}

func (f *FeedbackFilter) GetApps() []string {
	if f == nil {
		return nil
	}
	return f.Apps
}

func (f *FeedbackFilter) GetTypes() []FeedbackType {
	if f == nil {
		return nil
	}
	return f.Types
}

func (f *FeedbackFilter) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackFilter) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetSearch sets the Search field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackFilter) SetSearch(search *string) {
	f.Search = search
	f.require(feedbackFilterFieldSearch)
}

// SetCreatedAfter sets the CreatedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackFilter) SetCreatedAfter(createdAfter *time.Time) {
	f.CreatedAfter = createdAfter
	f.require(feedbackFilterFieldCreatedAfter)
}

// SetCreatedBefore sets the CreatedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackFilter) SetCreatedBefore(createdBefore *time.Time) {
	f.CreatedBefore = createdBefore
	f.require(feedbackFilterFieldCreatedBefore)
}

// SetUsers sets the Users field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackFilter) SetUsers(users []string) {
	f.Users = users
	f.require(feedbackFilterFieldUsers)
}

// SetApps sets the Apps field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackFilter) SetApps(apps []string) {
	f.Apps = apps
	f.require(feedbackFilterFieldApps)
}

// SetTypes sets the Types field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackFilter) SetTypes(types []FeedbackType) {
	f.Types = types
	f.require(feedbackFilterFieldTypes)
}

func (f *FeedbackFilter) UnmarshalJSON(data []byte) error {
	type embed FeedbackFilter
	var unmarshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FeedbackFilter(unmarshaler.embed)
	f.CreatedAfter = unmarshaler.CreatedAfter.TimePtr()
	f.CreatedBefore = unmarshaler.CreatedBefore.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackFilter) MarshalJSON() ([]byte, error) {
	type embed FeedbackFilter
	var marshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed:         embed(*f),
		CreatedAfter:  internal.NewOptionalDateTime(f.CreatedAfter),
		CreatedBefore: internal.NewOptionalDateTime(f.CreatedBefore),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackFilter) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	feedbackRequestFieldType                  = big.NewInt(1 << 0)
	feedbackRequestFieldText                  = big.NewInt(1 << 1)
	feedbackRequestFieldFeedbackId            = big.NewInt(1 << 2)
	feedbackRequestFieldConversationId        = big.NewInt(1 << 3)
	feedbackRequestFieldConversationMessageId = big.NewInt(1 << 4)
	feedbackRequestFieldUserId                = big.NewInt(1 << 5)
)

type FeedbackRequest struct {
	// The type of feedback
	Type FeedbackType `json:"type" url:"type"`
	// The feedback text
	Text *string `json:"text,omitempty" url:"text,omitempty"`
	// The ID that uniquely identifies this feedback
	FeedbackId *EntityIdBase `json:"feedbackId" url:"feedbackId"`
	// The ID that uniquely identifies the the conversation the feedback is about
	ConversationId *EntityIdBase `json:"conversationId" url:"conversationId"`
	// The ID that uniquely identifies the message within the conversation the feedback is about
	ConversationMessageId *EntityIdBase `json:"conversationMessageId" url:"conversationMessageId"`
	// The ID of the user who is creating the feedback
	UserId *EntityIdBase `json:"userId,omitempty" url:"userId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackRequest) GetType() FeedbackType {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FeedbackRequest) GetText() *string {
	if f == nil {
		return nil
	}
	return f.Text
}

func (f *FeedbackRequest) GetFeedbackId() *EntityIdBase {
	if f == nil {
		return nil
	}
	return f.FeedbackId
}

func (f *FeedbackRequest) GetConversationId() *EntityIdBase {
	if f == nil {
		return nil
	}
	return f.ConversationId
}

func (f *FeedbackRequest) GetConversationMessageId() *EntityIdBase {
	if f == nil {
		return nil
	}
	return f.ConversationMessageId
}

func (f *FeedbackRequest) GetUserId() *EntityIdBase {
	if f == nil {
		return nil
	}
	return f.UserId
}

func (f *FeedbackRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackRequest) SetType(type_ FeedbackType) {
	f.Type = type_
	f.require(feedbackRequestFieldType)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackRequest) SetText(text *string) {
	f.Text = text
	f.require(feedbackRequestFieldText)
}

// SetFeedbackId sets the FeedbackId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackRequest) SetFeedbackId(feedbackId *EntityIdBase) {
	f.FeedbackId = feedbackId
	f.require(feedbackRequestFieldFeedbackId)
}

// SetConversationId sets the ConversationId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackRequest) SetConversationId(conversationId *EntityIdBase) {
	f.ConversationId = conversationId
	f.require(feedbackRequestFieldConversationId)
}

// SetConversationMessageId sets the ConversationMessageId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackRequest) SetConversationMessageId(conversationMessageId *EntityIdBase) {
	f.ConversationMessageId = conversationMessageId
	f.require(feedbackRequestFieldConversationMessageId)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackRequest) SetUserId(userId *EntityIdBase) {
	f.UserId = userId
	f.require(feedbackRequestFieldUserId)
}

func (f *FeedbackRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackRequest) MarshalJSON() ([]byte, error) {
	type embed FeedbackRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackRequest) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type NumericConversationField string

const (
	NumericConversationFieldThumbsUpCount     NumericConversationField = "ThumbsUpCount"
	NumericConversationFieldThumbsDownCount   NumericConversationField = "ThumbsDownCount"
	NumericConversationFieldInsertCount       NumericConversationField = "InsertCount"
	NumericConversationFieldUserMessageCount  NumericConversationField = "UserMessageCount"
	NumericConversationFieldHandleTime        NumericConversationField = "HandleTime"
	NumericConversationFieldFirstResponseTime NumericConversationField = "FirstResponseTime"
	NumericConversationFieldPredictedNps      NumericConversationField = "PredictedNPS"
)

func NewNumericConversationFieldFromString(s string) (NumericConversationField, error) {
	switch s {
	case "ThumbsUpCount":
		return NumericConversationFieldThumbsUpCount, nil
	case "ThumbsDownCount":
		return NumericConversationFieldThumbsDownCount, nil
	case "InsertCount":
		return NumericConversationFieldInsertCount, nil
	case "UserMessageCount":
		return NumericConversationFieldUserMessageCount, nil
	case "HandleTime":
		return NumericConversationFieldHandleTime, nil
	case "FirstResponseTime":
		return NumericConversationFieldFirstResponseTime, nil
	case "PredictedNPS":
		return NumericConversationFieldPredictedNps, nil
	}
	var t NumericConversationField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NumericConversationField) Ptr() *NumericConversationField {
	return &n
}

type ObjectStreamResponse struct {
	EventType string
	Text      *AskStreamTextEvent
	Start     *AskStreamStartEvent
	End       *AskStreamEndEvent
}

func (o *ObjectStreamResponse) GetEventType() string {
	if o == nil {
		return ""
	}
	return o.EventType
}

func (o *ObjectStreamResponse) GetText() *AskStreamTextEvent {
	if o == nil {
		return nil
	}
	return o.Text
}

func (o *ObjectStreamResponse) GetStart() *AskStreamStartEvent {
	if o == nil {
		return nil
	}
	return o.Start
}

func (o *ObjectStreamResponse) GetEnd() *AskStreamEndEvent {
	if o == nil {
		return nil
	}
	return o.End
}

func (o *ObjectStreamResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"eventType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	o.EventType = unmarshaler.EventType
	if unmarshaler.EventType == "" {
		return fmt.Errorf("%T did not include discriminant eventType", o)
	}
	switch unmarshaler.EventType {
	case "text":
		value := new(AskStreamTextEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Text = value
	case "start":
		value := new(AskStreamStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.Start = value
	case "end":
		value := new(AskStreamEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		o.End = value
	}
	return nil
}

func (o ObjectStreamResponse) MarshalJSON() ([]byte, error) {
	if err := o.validate(); err != nil {
		return nil, err
	}
	if o.Text != nil {
		return internal.MarshalJSONWithExtraProperty(o.Text, "eventType", "text")
	}
	if o.Start != nil {
		return internal.MarshalJSONWithExtraProperty(o.Start, "eventType", "start")
	}
	if o.End != nil {
		return internal.MarshalJSONWithExtraProperty(o.End, "eventType", "end")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", o)
}

type ObjectStreamResponseVisitor interface {
	VisitText(*AskStreamTextEvent) error
	VisitStart(*AskStreamStartEvent) error
	VisitEnd(*AskStreamEndEvent) error
}

func (o *ObjectStreamResponse) Accept(visitor ObjectStreamResponseVisitor) error {
	if o.Text != nil {
		return visitor.VisitText(o.Text)
	}
	if o.Start != nil {
		return visitor.VisitStart(o.Start)
	}
	if o.End != nil {
		return visitor.VisitEnd(o.End)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", o)
}

func (o *ObjectStreamResponse) validate() error {
	if o == nil {
		return fmt.Errorf("type %T is nil", o)
	}
	var fields []string
	if o.Text != nil {
		fields = append(fields, "text")
	}
	if o.Start != nil {
		fields = append(fields, "start")
	}
	if o.End != nil {
		fields = append(fields, "end")
	}
	if len(fields) == 0 {
		if o.EventType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", o, o.EventType)
		}
		return fmt.Errorf("type %T is empty", o)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", o, fields)
	}
	if o.EventType != "" {
		field := fields[0]
		if o.EventType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				o,
				o.EventType,
				o,
			)
		}
	}
	return nil
}

type ResolutionStatus string

const (
	ResolutionStatusResolved   ResolutionStatus = "RESOLVED"
	ResolutionStatusEscalated  ResolutionStatus = "ESCALATED"
	ResolutionStatusInProgress ResolutionStatus = "IN_PROGRESS"
)

func NewResolutionStatusFromString(s string) (ResolutionStatus, error) {
	switch s {
	case "RESOLVED":
		return ResolutionStatusResolved, nil
	case "ESCALATED":
		return ResolutionStatusEscalated, nil
	case "IN_PROGRESS":
		return ResolutionStatusInProgress, nil
	}
	var t ResolutionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResolutionStatus) Ptr() *ResolutionStatus {
	return &r
}

type SimulationFilter string

const (
	SimulationFilterNonSimulations SimulationFilter = "NON_SIMULATIONS"
	SimulationFilterSimulations    SimulationFilter = "SIMULATIONS"
	SimulationFilterAll            SimulationFilter = "ALL"
)

func NewSimulationFilterFromString(s string) (SimulationFilter, error) {
	switch s {
	case "NON_SIMULATIONS":
		return SimulationFilterNonSimulations, nil
	case "SIMULATIONS":
		return SimulationFilterSimulations, nil
	case "ALL":
		return SimulationFilterAll, nil
	}
	var t SimulationFilter
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SimulationFilter) Ptr() *SimulationFilter {
	return &s
}

type StreamResponse struct {
	EventType   string
	Text        *AskStreamTextEvent
	Action      *AskStreamActionEvent
	OauthButton *AskStreamOAuthButtonEvent
	Chart       *AskStreamChartEvent
	Metadata    *AskStreamMetadataEvent
	Start       *AskStreamStartEvent
	End         *AskStreamEndEvent
}

func (s *StreamResponse) GetEventType() string {
	if s == nil {
		return ""
	}
	return s.EventType
}

func (s *StreamResponse) GetText() *AskStreamTextEvent {
	if s == nil {
		return nil
	}
	return s.Text
}

func (s *StreamResponse) GetAction() *AskStreamActionEvent {
	if s == nil {
		return nil
	}
	return s.Action
}

func (s *StreamResponse) GetOauthButton() *AskStreamOAuthButtonEvent {
	if s == nil {
		return nil
	}
	return s.OauthButton
}

func (s *StreamResponse) GetChart() *AskStreamChartEvent {
	if s == nil {
		return nil
	}
	return s.Chart
}

func (s *StreamResponse) GetMetadata() *AskStreamMetadataEvent {
	if s == nil {
		return nil
	}
	return s.Metadata
}

func (s *StreamResponse) GetStart() *AskStreamStartEvent {
	if s == nil {
		return nil
	}
	return s.Start
}

func (s *StreamResponse) GetEnd() *AskStreamEndEvent {
	if s == nil {
		return nil
	}
	return s.End
}

func (s *StreamResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"eventType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.EventType = unmarshaler.EventType
	if unmarshaler.EventType == "" {
		return fmt.Errorf("%T did not include discriminant eventType", s)
	}
	switch unmarshaler.EventType {
	case "text":
		value := new(AskStreamTextEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Text = value
	case "action":
		value := new(AskStreamActionEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Action = value
	case "oauthButton":
		value := new(AskStreamOAuthButtonEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.OauthButton = value
	case "chart":
		value := new(AskStreamChartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Chart = value
	case "metadata":
		value := new(AskStreamMetadataEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Metadata = value
	case "start":
		value := new(AskStreamStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Start = value
	case "end":
		value := new(AskStreamEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.End = value
	}
	return nil
}

func (s StreamResponse) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Text != nil {
		return internal.MarshalJSONWithExtraProperty(s.Text, "eventType", "text")
	}
	if s.Action != nil {
		return internal.MarshalJSONWithExtraProperty(s.Action, "eventType", "action")
	}
	if s.OauthButton != nil {
		return internal.MarshalJSONWithExtraProperty(s.OauthButton, "eventType", "oauthButton")
	}
	if s.Chart != nil {
		return internal.MarshalJSONWithExtraProperty(s.Chart, "eventType", "chart")
	}
	if s.Metadata != nil {
		return internal.MarshalJSONWithExtraProperty(s.Metadata, "eventType", "metadata")
	}
	if s.Start != nil {
		return internal.MarshalJSONWithExtraProperty(s.Start, "eventType", "start")
	}
	if s.End != nil {
		return internal.MarshalJSONWithExtraProperty(s.End, "eventType", "end")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type StreamResponseVisitor interface {
	VisitText(*AskStreamTextEvent) error
	VisitAction(*AskStreamActionEvent) error
	VisitOauthButton(*AskStreamOAuthButtonEvent) error
	VisitChart(*AskStreamChartEvent) error
	VisitMetadata(*AskStreamMetadataEvent) error
	VisitStart(*AskStreamStartEvent) error
	VisitEnd(*AskStreamEndEvent) error
}

func (s *StreamResponse) Accept(visitor StreamResponseVisitor) error {
	if s.Text != nil {
		return visitor.VisitText(s.Text)
	}
	if s.Action != nil {
		return visitor.VisitAction(s.Action)
	}
	if s.OauthButton != nil {
		return visitor.VisitOauthButton(s.OauthButton)
	}
	if s.Chart != nil {
		return visitor.VisitChart(s.Chart)
	}
	if s.Metadata != nil {
		return visitor.VisitMetadata(s.Metadata)
	}
	if s.Start != nil {
		return visitor.VisitStart(s.Start)
	}
	if s.End != nil {
		return visitor.VisitEnd(s.End)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *StreamResponse) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Text != nil {
		fields = append(fields, "text")
	}
	if s.Action != nil {
		fields = append(fields, "action")
	}
	if s.OauthButton != nil {
		fields = append(fields, "oauthButton")
	}
	if s.Chart != nil {
		fields = append(fields, "chart")
	}
	if s.Metadata != nil {
		fields = append(fields, "metadata")
	}
	if s.Start != nil {
		fields = append(fields, "start")
	}
	if s.End != nil {
		fields = append(fields, "end")
	}
	if len(fields) == 0 {
		if s.EventType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.EventType)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.EventType != "" {
		field := fields[0]
		if s.EventType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.EventType,
				s,
			)
		}
	}
	return nil
}

var (
	submitActionFormRequestFieldActionFormId  = big.NewInt(1 << 0)
	submitActionFormRequestFieldParameters    = big.NewInt(1 << 1)
	submitActionFormRequestFieldTransientData = big.NewInt(1 << 2)
)

type SubmitActionFormRequest struct {
	ActionFormId string `json:"actionFormId" url:"actionFormId"`
	// Map of parameter IDs to values provided by the user. All required action fields must be provided.
	Parameters map[string]*ActionFormRequestParamValue `json:"parameters" url:"parameters"`
	// Transient data which the Maven platform will not persist. This data will only be forwarded to actions taken. For example, one may put in user tokens as transient data.
	TransientData map[string]string `json:"transientData,omitempty" url:"transientData,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SubmitActionFormRequest) GetActionFormId() string {
	if s == nil {
		return ""
	}
	return s.ActionFormId
}

func (s *SubmitActionFormRequest) GetParameters() map[string]*ActionFormRequestParamValue {
	if s == nil {
		return nil
	}
	return s.Parameters
}

func (s *SubmitActionFormRequest) GetTransientData() map[string]string {
	if s == nil {
		return nil
	}
	return s.TransientData
}

func (s *SubmitActionFormRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SubmitActionFormRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetActionFormId sets the ActionFormId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitActionFormRequest) SetActionFormId(actionFormId string) {
	s.ActionFormId = actionFormId
	s.require(submitActionFormRequestFieldActionFormId)
}

// SetParameters sets the Parameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitActionFormRequest) SetParameters(parameters map[string]*ActionFormRequestParamValue) {
	s.Parameters = parameters
	s.require(submitActionFormRequestFieldParameters)
}

// SetTransientData sets the TransientData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SubmitActionFormRequest) SetTransientData(transientData map[string]string) {
	s.TransientData = transientData
	s.require(submitActionFormRequestFieldTransientData)
}

func (s *SubmitActionFormRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SubmitActionFormRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SubmitActionFormRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SubmitActionFormRequest) MarshalJSON() ([]byte, error) {
	type embed SubmitActionFormRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SubmitActionFormRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	updateMetadataRequestFieldAppId  = big.NewInt(1 << 0)
	updateMetadataRequestFieldValues = big.NewInt(1 << 1)
)

type UpdateMetadataRequest struct {
	// The App ID of the conversation to modify metadata for. If not provided the ID of the calling app will be used.
	AppId *string `json:"appId,omitempty" url:"appId,omitempty"`
	// The metadata values to add to the conversation.
	Values map[string]string `json:"values" url:"values"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UpdateMetadataRequest) GetAppId() *string {
	if u == nil {
		return nil
	}
	return u.AppId
}

func (u *UpdateMetadataRequest) GetValues() map[string]string {
	if u == nil {
		return nil
	}
	return u.Values
}

func (u *UpdateMetadataRequest) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UpdateMetadataRequest) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateMetadataRequest) SetAppId(appId *string) {
	u.AppId = appId
	u.require(updateMetadataRequestFieldAppId)
}

// SetValues sets the Values field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UpdateMetadataRequest) SetValues(values map[string]string) {
	u.Values = values
	u.require(updateMetadataRequestFieldValues)
}

func (u *UpdateMetadataRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateMetadataRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateMetadataRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateMetadataRequest) MarshalJSON() ([]byte, error) {
	type embed UpdateMetadataRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UpdateMetadataRequest) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}
