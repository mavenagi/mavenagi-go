// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mavenagi/mavenagi-go/internal"
	big "math/big"
	time "time"
)

var (
	sessionTokenRequestFieldTTLSeconds = big.NewInt(1 << 0)
)

type SessionTokenRequest struct {
	TTLSeconds int `json:"ttlSeconds" url:"ttlSeconds"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SessionTokenRequest) GetTTLSeconds() int {
	if s == nil {
		return 0
	}
	return s.TTLSeconds
}

func (s *SessionTokenRequest) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SessionTokenRequest) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetTTLSeconds sets the TTLSeconds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SessionTokenRequest) SetTTLSeconds(ttlSeconds int) {
	s.TTLSeconds = ttlSeconds
	s.require(sessionTokenRequestFieldTTLSeconds)
}

func (s *SessionTokenRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler SessionTokenRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SessionTokenRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SessionTokenRequest) MarshalJSON() ([]byte, error) {
	type embed SessionTokenRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SessionTokenRequest) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	sessionTokenResponseFieldSessionToken = big.NewInt(1 << 0)
	sessionTokenResponseFieldExpiresAt    = big.NewInt(1 << 1)
)

type SessionTokenResponse struct {
	// The session token to use for authentication.
	SessionToken string `json:"sessionToken" url:"sessionToken"`
	// When the session token expires.
	ExpiresAt time.Time `json:"expiresAt" url:"expiresAt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SessionTokenResponse) GetSessionToken() string {
	if s == nil {
		return ""
	}
	return s.SessionToken
}

func (s *SessionTokenResponse) GetExpiresAt() time.Time {
	if s == nil {
		return time.Time{}
	}
	return s.ExpiresAt
}

func (s *SessionTokenResponse) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SessionTokenResponse) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSessionToken sets the SessionToken field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SessionTokenResponse) SetSessionToken(sessionToken string) {
	s.SessionToken = sessionToken
	s.require(sessionTokenResponseFieldSessionToken)
}

// SetExpiresAt sets the ExpiresAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SessionTokenResponse) SetExpiresAt(expiresAt time.Time) {
	s.ExpiresAt = expiresAt
	s.require(sessionTokenResponseFieldExpiresAt)
}

func (s *SessionTokenResponse) UnmarshalJSON(data []byte) error {
	type embed SessionTokenResponse
	var unmarshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expiresAt"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SessionTokenResponse(unmarshaler.embed)
	s.ExpiresAt = unmarshaler.ExpiresAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SessionTokenResponse) MarshalJSON() ([]byte, error) {
	type embed SessionTokenResponse
	var marshaler = struct {
		embed
		ExpiresAt *internal.DateTime `json:"expiresAt"`
	}{
		embed:     embed(*s),
		ExpiresAt: internal.NewDateTime(s.ExpiresAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SessionTokenResponse) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}
