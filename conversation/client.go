// Code generated by Fern. DO NOT EDIT.

package conversation

import (
	context "context"
	mavenagigo "github.com/mavenagi/mavenagi-go"
	core "github.com/mavenagi/mavenagi-go/core"
	internal "github.com/mavenagi/mavenagi-go/internal"
	option "github.com/mavenagi/mavenagi-go/option"
	io "io"
	http "net/http"
	os "os"
)

type Client struct {
	WithRawResponse *RawClient

	options *core.RequestOptions
	baseURL string
	caller  *internal.Caller
}

func NewClient(options *core.RequestOptions) *Client {
	if options.AppId == "" {
		options.AppId = os.Getenv("MAVENAGI_APP_ID")
	}
	if options.AppSecret == "" {
		options.AppSecret = os.Getenv("MAVENAGI_APP_SECRET")
	}
	return &Client{
		WithRawResponse: NewRawClient(options),
		options:         options,
		baseURL:         options.BaseURL,
		caller: internal.NewCaller(
			&internal.CallerParams{
				Client:      options.HTTPClient,
				MaxAttempts: options.MaxAttempts,
			},
		),
	}
}

// Initialize a new conversation.
// Only required if the ask request wishes to supply conversation level data or when syncing to external systems.
//
// Conversations can not be modified using this API. If the conversation already exists then the existing conversation will be returned.
//
// After initialization,
// - metadata can be changed using the `updateConversationMetadata` API.
// - messages can be added to the conversation with the `appendNewMessages` or `ask` APIs.
func (c *Client) Initialize(
	ctx context.Context,
	request *mavenagigo.ConversationRequest,
	opts ...option.RequestOption,
) (*mavenagigo.ConversationResponse, error) {
	response, err := c.WithRawResponse.Initialize(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Update mutable conversation fields.
//
// The `appId` field can be provided to update a conversation owned by a different app.
// All other fields will overwrite the existing value on the conversation only if provided.
func (c *Client) Patch(
	ctx context.Context,
	// The ID of the conversation to patch
	conversationId string,
	request *mavenagigo.ConversationPatchRequest,
	opts ...option.RequestOption,
) (*mavenagigo.ConversationResponse, error) {
	response, err := c.WithRawResponse.Patch(
		ctx,
		conversationId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Get a conversation
func (c *Client) Get(
	ctx context.Context,
	// The ID of the conversation to get
	conversationId string,
	request *mavenagigo.ConversationGetRequest,
	opts ...option.RequestOption,
) (*mavenagigo.ConversationResponse, error) {
	response, err := c.WithRawResponse.Get(
		ctx,
		conversationId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Wipes a conversation of all user data.
// The conversation ID will still exist and non-user specific data will still be retained.
// Attempts to modify or add messages to the conversation will throw an error.
//
// Simulation conversations will no longer be visible in search results nor metrics.
// Non-simulation conversations will remain visible - they can not be fully removed from the system.
//
// <Warning>This is a destructive operation and cannot be undone. <br/><br/>
// The exact fields cleared include: the conversation subject, userRequest, agentResponse.
// As well as the text response, followup questions, and backend LLM prompt of all messages.</Warning>
func (c *Client) Delete(
	ctx context.Context,
	// The ID of the conversation to delete
	conversationId string,
	request *mavenagigo.ConversationDeleteRequest,
	opts ...option.RequestOption,
) error {
	_, err := c.WithRawResponse.Delete(
		ctx,
		conversationId,
		request,
		opts...,
	)
	if err != nil {
		return err
	}
	return nil
}

// Append messages to an existing conversation. The conversation must be initialized first. If a message with the same ID already exists, it will be ignored. Messages do not allow modification.
func (c *Client) AppendNewMessages(
	ctx context.Context,
	// The ID of the conversation to append messages to
	conversationId string,
	request []*mavenagigo.ConversationMessageRequest,
	opts ...option.RequestOption,
) (*mavenagigo.ConversationResponse, error) {
	response, err := c.WithRawResponse.AppendNewMessages(
		ctx,
		conversationId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Get an answer from Maven for a given user question. If the user question or its answer already exists,
// they will be reused and will not be updated. Messages do not allow modification once generated.
//
// Concurrency Behavior:
// - If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.
// - The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.
//
// Known Limitation:
// - The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.
func (c *Client) Ask(
	ctx context.Context,
	// The ID of a new or existing conversation to use as context for the question
	conversationId string,
	request *mavenagigo.AskRequest,
	opts ...option.RequestOption,
) (*mavenagigo.ConversationResponse, error) {
	response, err := c.WithRawResponse.Ask(
		ctx,
		conversationId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Get an answer from Maven for a given user question with a streaming response. The response will be sent as a stream of events.
// The text portions of stream responses should be concatenated to form the full response text.
// Action and metadata events should overwrite past data and do not need concatenation.
//
// If the user question or its answer already exists, they will be reused and will not be updated.
// Messages do not allow modification once generated.
//
// Concurrency Behavior:
// - If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.
// - The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.
//
// Known Limitation:
// - The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.
func (c *Client) AskStream(
	ctx context.Context,
	// The ID of a new or existing conversation to use as context for the question
	conversationId string,
	request *mavenagigo.AskRequest,
	opts ...option.RequestOption,
) (*core.Stream[mavenagigo.StreamResponse], error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://www.mavenagi-apis.com",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/v1/conversations/%v/ask_stream",
		conversationId,
	)
	headers := internal.MergeHeaders(
		c.options.ToHeader(),
		options.ToHeader(),
	)
	headers.Add("Accept", "text/event-stream")
	streamer := internal.NewStreamer[mavenagigo.StreamResponse](c.caller)
	return streamer.Stream(
		ctx,
		&internal.StreamParams{
			URL:             endpointURL,
			Method:          http.MethodPost,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Prefix:          internal.DefaultSSEDataPrefix,
			Terminator:      internal.DefaultSSETerminator,
			Format:          core.StreamFormatSSE,
			Request:         request,
			ErrorDecoder:    internal.NewErrorDecoder(mavenagigo.ErrorCodes),
		},
	)
}

// Generate a structured object response based on a provided schema and user prompt with a streaming response.
// The response will be sent as a stream of events containing text, start, and end events.
// The text portions of stream responses should be concatenated to form the full response text.
//
// If the user question and object response already exist, they will be reused and not updated.
//
// Concurrency Behavior:
// - If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.
// - The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.
//
// Known Limitations:
// - Schema enforcement is best-effort and may not guarantee exact conformity.
// - The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.
func (c *Client) AskObjectStream(
	ctx context.Context,
	// The ID of a new or existing conversation to use as context for the object generation request
	conversationId string,
	request *mavenagigo.AskObjectRequest,
	opts ...option.RequestOption,
) (*core.Stream[mavenagigo.ObjectStreamResponse], error) {
	options := core.NewRequestOptions(opts...)
	baseURL := internal.ResolveBaseURL(
		options.BaseURL,
		c.baseURL,
		"https://www.mavenagi-apis.com",
	)
	endpointURL := internal.EncodeURL(
		baseURL+"/v1/conversations/%v/ask_object_stream",
		conversationId,
	)
	headers := internal.MergeHeaders(
		c.options.ToHeader(),
		options.ToHeader(),
	)
	headers.Add("Accept", "text/event-stream")
	streamer := internal.NewStreamer[mavenagigo.ObjectStreamResponse](c.caller)
	return streamer.Stream(
		ctx,
		&internal.StreamParams{
			URL:             endpointURL,
			Method:          http.MethodPost,
			Headers:         headers,
			MaxAttempts:     options.MaxAttempts,
			BodyProperties:  options.BodyProperties,
			QueryParameters: options.QueryParameters,
			Client:          options.HTTPClient,
			Prefix:          internal.DefaultSSEDataPrefix,
			Terminator:      internal.DefaultSSETerminator,
			Format:          core.StreamFormatSSE,
			Request:         request,
			ErrorDecoder:    internal.NewErrorDecoder(mavenagigo.ErrorCodes),
		},
	)
}

// Uses an LLM flow to categorize the conversation. Experimental.
func (c *Client) Categorize(
	ctx context.Context,
	// The ID of the conversation to categorize
	conversationId string,
	opts ...option.RequestOption,
) (*mavenagigo.CategorizationResponse, error) {
	response, err := c.WithRawResponse.Categorize(
		ctx,
		conversationId,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Update feedback or create it if it doesn't exist
func (c *Client) CreateFeedback(
	ctx context.Context,
	request *mavenagigo.FeedbackRequest,
	opts ...option.RequestOption,
) (*mavenagigo.Feedback, error) {
	response, err := c.WithRawResponse.CreateFeedback(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Submit a filled out action form.
// Action forms can not be submitted more than once, attempting to do so will result in an error.
//
// Additionally, form submission is only allowed when the form is the last message in the conversation.
// Forms should be disabled in surface UI if a conversation continues and they remain unsubmitted.
func (c *Client) SubmitActionForm(
	ctx context.Context,
	// The ID of a conversation the form being submitted belongs to
	conversationId string,
	request *mavenagigo.SubmitActionFormRequest,
	opts ...option.RequestOption,
) (*mavenagigo.ConversationResponse, error) {
	response, err := c.WithRawResponse.SubmitActionForm(
		ctx,
		conversationId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Replaced by `updateConversationMetadata`.
//
// Adds metadata to an existing conversation. If a metadata field already exists, it will be overwritten.
func (c *Client) AddConversationMetadata(
	ctx context.Context,
	// The ID of a conversation the metadata being added belongs to
	conversationId string,
	request map[string]string,
	opts ...option.RequestOption,
) (map[string]string, error) {
	response, err := c.WithRawResponse.AddConversationMetadata(
		ctx,
		conversationId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Update metadata supplied by the calling application for an existing conversation.
// Does not modify metadata saved by other apps.
//
// If a metadata field already exists for the calling app, it will be overwritten.
// If it does not exist, it will be added. Will not remove metadata fields.
//
// Returns all metadata saved by any app on the conversation.
func (c *Client) UpdateConversationMetadata(
	ctx context.Context,
	// The ID of the conversation to modify metadata for
	conversationId string,
	request *mavenagigo.UpdateMetadataRequest,
	opts ...option.RequestOption,
) (*mavenagigo.ConversationMetadata, error) {
	response, err := c.WithRawResponse.UpdateConversationMetadata(
		ctx,
		conversationId,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Search conversations
func (c *Client) Search(
	ctx context.Context,
	request *mavenagigo.ConversationsSearchRequest,
	opts ...option.RequestOption,
) (*mavenagigo.ConversationsResponse, error) {
	response, err := c.WithRawResponse.Search(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Export conversations to a CSV file.
//
// This will output a summary of each conversation that matches the supplied filter. A maximum of 10,000 conversations can be exported at a time.
//
// For most use cases it is recommended to use the `search` API instead and convert the JSON response to your desired format.
// The CSV format may change over time and should not be relied upon by code consumers.
func (c *Client) Export(
	ctx context.Context,
	request *mavenagigo.ConversationsSearchRequest,
	opts ...option.RequestOption,
) (io.Reader, error) {
	response, err := c.WithRawResponse.Export(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}

// Import simulation conversations from a CSV file.
//
// This CSV format is very simple and only allows for one column: `question`. A header containing this column is required.
// Each row will generate one simulation conversation, using the provided response config, if present.
//
// This API is offered for backwards compatibility.
// Most API callers should create simulations programmatically to allow for more flexibility.
func (c *Client) ImportSimulations(
	ctx context.Context,
	request *mavenagigo.SimulationImportRequest,
	opts ...option.RequestOption,
) error {
	_, err := c.WithRawResponse.ImportSimulations(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return err
	}
	return nil
}

// Deliver a message to a user or conversation.
//
// <Warning>
// Currently, messages can only be successfully delivered to conversations with the `ASYNC` capability that are `open`.
// User message delivery is not yet supported.
// </Warning>
func (c *Client) DeliverMessage(
	ctx context.Context,
	request *mavenagigo.DeliverMessageRequest,
	opts ...option.RequestOption,
) (*mavenagigo.DeliverMessageResponse, error) {
	response, err := c.WithRawResponse.DeliverMessage(
		ctx,
		request,
		opts...,
	)
	if err != nil {
		return nil, err
	}
	return response.Body, nil
}
