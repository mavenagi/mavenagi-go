// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mavenagi/mavenagi-go/internal"
	big "math/big"
)

var (
	voiceSessionTokenRequestFieldAppUserID  = big.NewInt(1 << 0)
	voiceSessionTokenRequestFieldType       = big.NewInt(1 << 1)
	voiceSessionTokenRequestFieldCustomData = big.NewInt(1 << 2)
)

type VoiceSessionTokenRequest struct {
	// The end user identity for the voice session.
	AppUserID string `json:"appUserId" url:"appUserId"`
	// The type of session token to generate.
	// Use "webrtc" for browser-based calls via Twilio, or "websocket" for direct WebSocket connections.
	Type VoiceTokenType `json:"type" url:"type"`
	// Arbitrary key-value metadata to associate with this session (e.g., conversationId, topic).
	// For WebRTC tokens, this data is stored server-side and referenced by a secure ID
	// encoded in the token identity, ensuring it cannot be tampered with by the client.
	// For WebSocket tokens, clients can also pass data directly in the Config message.
	CustomData map[string]string `json:"customData,omitempty" url:"customData,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VoiceSessionTokenRequest) GetAppUserID() string {
	if v == nil {
		return ""
	}
	return v.AppUserID
}

func (v *VoiceSessionTokenRequest) GetType() VoiceTokenType {
	if v == nil {
		return ""
	}
	return v.Type
}

func (v *VoiceSessionTokenRequest) GetCustomData() map[string]string {
	if v == nil {
		return nil
	}
	return v.CustomData
}

func (v *VoiceSessionTokenRequest) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceSessionTokenRequest) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetAppUserID sets the AppUserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VoiceSessionTokenRequest) SetAppUserID(appUserID string) {
	v.AppUserID = appUserID
	v.require(voiceSessionTokenRequestFieldAppUserID)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VoiceSessionTokenRequest) SetType(type_ VoiceTokenType) {
	v.Type = type_
	v.require(voiceSessionTokenRequestFieldType)
}

// SetCustomData sets the CustomData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VoiceSessionTokenRequest) SetCustomData(customData map[string]string) {
	v.CustomData = customData
	v.require(voiceSessionTokenRequestFieldCustomData)
}

func (v *VoiceSessionTokenRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler VoiceSessionTokenRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoiceSessionTokenRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoiceSessionTokenRequest) MarshalJSON() ([]byte, error) {
	type embed VoiceSessionTokenRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*v),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, v.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (v *VoiceSessionTokenRequest) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

var (
	voiceSessionTokenResponseFieldToken     = big.NewInt(1 << 0)
	voiceSessionTokenResponseFieldIdentity  = big.NewInt(1 << 1)
	voiceSessionTokenResponseFieldType      = big.NewInt(1 << 2)
	voiceSessionTokenResponseFieldExpiresIn = big.NewInt(1 << 3)
)

type VoiceSessionTokenResponse struct {
	// Opaque JWT session token. Pass this in the Authorization header when connecting.
	Token string `json:"token" url:"token"`
	// The identity string associated with this token (echoes appUserId).
	Identity string `json:"identity" url:"identity"`
	// The type of token that was generated.
	Type VoiceTokenType `json:"type" url:"type"`
	// Time in seconds until the token expires.
	ExpiresIn int `json:"expiresIn" url:"expiresIn"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (v *VoiceSessionTokenResponse) GetToken() string {
	if v == nil {
		return ""
	}
	return v.Token
}

func (v *VoiceSessionTokenResponse) GetIdentity() string {
	if v == nil {
		return ""
	}
	return v.Identity
}

func (v *VoiceSessionTokenResponse) GetType() VoiceTokenType {
	if v == nil {
		return ""
	}
	return v.Type
}

func (v *VoiceSessionTokenResponse) GetExpiresIn() int {
	if v == nil {
		return 0
	}
	return v.ExpiresIn
}

func (v *VoiceSessionTokenResponse) GetExtraProperties() map[string]interface{} {
	return v.extraProperties
}

func (v *VoiceSessionTokenResponse) require(field *big.Int) {
	if v.explicitFields == nil {
		v.explicitFields = big.NewInt(0)
	}
	v.explicitFields.Or(v.explicitFields, field)
}

// SetToken sets the Token field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VoiceSessionTokenResponse) SetToken(token string) {
	v.Token = token
	v.require(voiceSessionTokenResponseFieldToken)
}

// SetIdentity sets the Identity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VoiceSessionTokenResponse) SetIdentity(identity string) {
	v.Identity = identity
	v.require(voiceSessionTokenResponseFieldIdentity)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VoiceSessionTokenResponse) SetType(type_ VoiceTokenType) {
	v.Type = type_
	v.require(voiceSessionTokenResponseFieldType)
}

// SetExpiresIn sets the ExpiresIn field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (v *VoiceSessionTokenResponse) SetExpiresIn(expiresIn int) {
	v.ExpiresIn = expiresIn
	v.require(voiceSessionTokenResponseFieldExpiresIn)
}

func (v *VoiceSessionTokenResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler VoiceSessionTokenResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*v = VoiceSessionTokenResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *v)
	if err != nil {
		return err
	}
	v.extraProperties = extraProperties
	v.rawJSON = json.RawMessage(data)
	return nil
}

func (v *VoiceSessionTokenResponse) MarshalJSON() ([]byte, error) {
	type embed VoiceSessionTokenResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*v),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, v.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (v *VoiceSessionTokenResponse) String() string {
	if len(v.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(v.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}

type VoiceTokenType string

const (
	VoiceTokenTypeWebrtc    VoiceTokenType = "webrtc"
	VoiceTokenTypeWebsocket VoiceTokenType = "websocket"
)

func NewVoiceTokenTypeFromString(s string) (VoiceTokenType, error) {
	switch s {
	case "webrtc":
		return VoiceTokenTypeWebrtc, nil
	case "websocket":
		return VoiceTokenTypeWebsocket, nil
	}
	var t VoiceTokenType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VoiceTokenType) Ptr() *VoiceTokenType {
	return &v
}
