// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mavenagi/mavenagi-go/internal"
	big "math/big"
	time "time"
)

var (
	agentUserAnalyticsRequestFieldAgentUserFilter = big.NewInt(1 << 0)
	agentUserAnalyticsRequestFieldTimezone        = big.NewInt(1 << 1)
)

type AgentUserAnalyticsRequest struct {
	// Optional filter applied to refine the agent user data before processing.
	AgentUserFilter *AgentUserFilter `json:"agentUserFilter,omitempty" url:"agentUserFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AgentUserAnalyticsRequest) GetAgentUserFilter() *AgentUserFilter {
	if a == nil {
		return nil
	}
	return a.AgentUserFilter
}

func (a *AgentUserAnalyticsRequest) GetTimezone() *string {
	if a == nil {
		return nil
	}
	return a.Timezone
}

func (a *AgentUserAnalyticsRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentUserAnalyticsRequest) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAgentUserFilter sets the AgentUserFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserAnalyticsRequest) SetAgentUserFilter(agentUserFilter *AgentUserFilter) {
	a.AgentUserFilter = agentUserFilter
	a.require(agentUserAnalyticsRequestFieldAgentUserFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserAnalyticsRequest) SetTimezone(timezone *string) {
	a.Timezone = timezone
	a.require(agentUserAnalyticsRequestFieldTimezone)
}

func (a *AgentUserAnalyticsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentUserAnalyticsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentUserAnalyticsRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentUserAnalyticsRequest) MarshalJSON() ([]byte, error) {
	type embed AgentUserAnalyticsRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AgentUserAnalyticsRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	agentUserColumnDefinitionFieldHeader = big.NewInt(1 << 0)
	agentUserColumnDefinitionFieldMetric = big.NewInt(1 << 1)
)

type AgentUserColumnDefinition struct {
	// Unique column header, serving as the key for corresponding metric values.
	Header string `json:"header" url:"header"`
	// The metric calculated for this column, stored in the row data under the specified header.
	Metric *AgentUserMetric `json:"metric" url:"metric"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AgentUserColumnDefinition) GetHeader() string {
	if a == nil {
		return ""
	}
	return a.Header
}

func (a *AgentUserColumnDefinition) GetMetric() *AgentUserMetric {
	if a == nil {
		return nil
	}
	return a.Metric
}

func (a *AgentUserColumnDefinition) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentUserColumnDefinition) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetHeader sets the Header field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserColumnDefinition) SetHeader(header string) {
	a.Header = header
	a.require(agentUserColumnDefinitionFieldHeader)
}

// SetMetric sets the Metric field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserColumnDefinition) SetMetric(metric *AgentUserMetric) {
	a.Metric = metric
	a.require(agentUserColumnDefinitionFieldMetric)
}

func (a *AgentUserColumnDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentUserColumnDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentUserColumnDefinition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentUserColumnDefinition) MarshalJSON() ([]byte, error) {
	type embed AgentUserColumnDefinition
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AgentUserColumnDefinition) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Returns the total count of records in a group.
type AgentUserCount struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AgentUserCount) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentUserCount) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

func (a *AgentUserCount) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentUserCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentUserCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentUserCount) MarshalJSON() ([]byte, error) {
	type embed AgentUserCount
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AgentUserCount) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Defines the metric to be calculated for a column or chart.
type AgentUserMetric struct {
	Type  string
	Count *AgentUserCount
}

func (a *AgentUserMetric) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AgentUserMetric) GetCount() *AgentUserCount {
	if a == nil {
		return nil
	}
	return a.Count
}

func (a *AgentUserMetric) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", a)
	}
	switch unmarshaler.Type {
	case "count":
		value := new(AgentUserCount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Count = value
	}
	return nil
}

func (a AgentUserMetric) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Count != nil {
		return internal.MarshalJSONWithExtraProperty(a.Count, "type", "count")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type AgentUserMetricVisitor interface {
	VisitCount(*AgentUserCount) error
}

func (a *AgentUserMetric) Accept(visitor AgentUserMetricVisitor) error {
	if a.Count != nil {
		return visitor.VisitCount(a.Count)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *AgentUserMetric) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Count != nil {
		fields = append(fields, "count")
	}
	if len(fields) == 0 {
		if a.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.Type)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.Type != "" {
		field := fields[0]
		if a.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.Type,
				a,
			)
		}
	}
	return nil
}

var (
	agentUserRowFieldData       = big.NewInt(1 << 0)
	agentUserRowFieldIdentifier = big.NewInt(1 << 1)
)

type AgentUserRow struct {
	// The actual row data, where keys represent column headers and values contain the respective metric results.
	Data map[string]*CellData `json:"data" url:"data"`
	// A unique identifier for each row, consisting of field names mapped to their respective values.
	// This includes time groupings and any specified field groupings.
	Identifier map[AgentUserField]*FieldValue `json:"identifier" url:"identifier"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AgentUserRow) GetData() map[string]*CellData {
	if a == nil {
		return nil
	}
	return a.Data
}

func (a *AgentUserRow) GetIdentifier() map[AgentUserField]*FieldValue {
	if a == nil {
		return nil
	}
	return a.Identifier
}

func (a *AgentUserRow) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentUserRow) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserRow) SetData(data map[string]*CellData) {
	a.Data = data
	a.require(agentUserRowFieldData)
}

// SetIdentifier sets the Identifier field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserRow) SetIdentifier(identifier map[AgentUserField]*FieldValue) {
	a.Identifier = identifier
	a.require(agentUserRowFieldIdentifier)
}

func (a *AgentUserRow) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentUserRow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentUserRow(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentUserRow) MarshalJSON() ([]byte, error) {
	type embed AgentUserRow
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AgentUserRow) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	agentUserTableRequestFieldAgentUserFilter   = big.NewInt(1 << 0)
	agentUserTableRequestFieldTimezone          = big.NewInt(1 << 1)
	agentUserTableRequestFieldTimeGrouping      = big.NewInt(1 << 2)
	agentUserTableRequestFieldColumnDefinitions = big.NewInt(1 << 3)
)

type AgentUserTableRequest struct {
	// Optional filter applied to refine the agent user data before processing.
	AgentUserFilter *AgentUserFilter `json:"agentUserFilter,omitempty" url:"agentUserFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// Defines the time interval for grouping data. If specified, data is grouped accordingly based on the time they were created.
	//
	//	Example: If set to "DAY," data will be aggregated by day.
	TimeGrouping *TimeInterval `json:"timeGrouping,omitempty" url:"timeGrouping,omitempty"`
	// Specifies the metrics to be displayed as columns.
	// Only the `count` metric is supported for agent user tables, so each table will have a single column definition using `count`.
	ColumnDefinitions []*AgentUserColumnDefinition `json:"columnDefinitions" url:"columnDefinitions"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AgentUserTableRequest) GetAgentUserFilter() *AgentUserFilter {
	if a == nil {
		return nil
	}
	return a.AgentUserFilter
}

func (a *AgentUserTableRequest) GetTimezone() *string {
	if a == nil {
		return nil
	}
	return a.Timezone
}

func (a *AgentUserTableRequest) GetTimeGrouping() *TimeInterval {
	if a == nil {
		return nil
	}
	return a.TimeGrouping
}

func (a *AgentUserTableRequest) GetColumnDefinitions() []*AgentUserColumnDefinition {
	if a == nil {
		return nil
	}
	return a.ColumnDefinitions
}

func (a *AgentUserTableRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentUserTableRequest) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAgentUserFilter sets the AgentUserFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserTableRequest) SetAgentUserFilter(agentUserFilter *AgentUserFilter) {
	a.AgentUserFilter = agentUserFilter
	a.require(agentUserTableRequestFieldAgentUserFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserTableRequest) SetTimezone(timezone *string) {
	a.Timezone = timezone
	a.require(agentUserTableRequestFieldTimezone)
}

// SetTimeGrouping sets the TimeGrouping field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserTableRequest) SetTimeGrouping(timeGrouping *TimeInterval) {
	a.TimeGrouping = timeGrouping
	a.require(agentUserTableRequestFieldTimeGrouping)
}

// SetColumnDefinitions sets the ColumnDefinitions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserTableRequest) SetColumnDefinitions(columnDefinitions []*AgentUserColumnDefinition) {
	a.ColumnDefinitions = columnDefinitions
	a.require(agentUserTableRequestFieldColumnDefinitions)
}

func (a *AgentUserTableRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentUserTableRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentUserTableRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentUserTableRequest) MarshalJSON() ([]byte, error) {
	type embed AgentUserTableRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AgentUserTableRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	agentUserTableResponseFieldHeaders = big.NewInt(1 << 0)
	agentUserTableResponseFieldRows    = big.NewInt(1 << 1)
)

type AgentUserTableResponse struct {
	// Column headers in the table, aligning with the column definitions specified in the request.
	Headers []string `json:"headers" url:"headers"`
	// Each row contains the user count for the given search query and corresponding time grouping.
	Rows []*AgentUserRow `json:"rows" url:"rows"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AgentUserTableResponse) GetHeaders() []string {
	if a == nil {
		return nil
	}
	return a.Headers
}

func (a *AgentUserTableResponse) GetRows() []*AgentUserRow {
	if a == nil {
		return nil
	}
	return a.Rows
}

func (a *AgentUserTableResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AgentUserTableResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserTableResponse) SetHeaders(headers []string) {
	a.Headers = headers
	a.require(agentUserTableResponseFieldHeaders)
}

// SetRows sets the Rows field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AgentUserTableResponse) SetRows(rows []*AgentUserRow) {
	a.Rows = rows
	a.require(agentUserTableResponseFieldRows)
}

func (a *AgentUserTableResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AgentUserTableResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AgentUserTableResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AgentUserTableResponse) MarshalJSON() ([]byte, error) {
	type embed AgentUserTableResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AgentUserTableResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	barChartResponseFieldSeries = big.NewInt(1 << 0)
)

type BarChartResponse struct {
	// Each LabeledPoint in the series represents a value for the bar, where the name serves as the bar's label.
	// If vertical grouping is defined, multiple series will be created, each representing a group.
	// In such cases, the bars can be stacked to reflect the grouped data distribution.
	Series []*Series `json:"series" url:"series"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BarChartResponse) GetSeries() []*Series {
	if b == nil {
		return nil
	}
	return b.Series
}

func (b *BarChartResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BarChartResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetSeries sets the Series field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BarChartResponse) SetSeries(series []*Series) {
	b.Series = series
	b.require(barChartResponseFieldSeries)
}

func (b *BarChartResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BarChartResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BarChartResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BarChartResponse) MarshalJSON() ([]byte, error) {
	type embed BarChartResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BarChartResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type CellData struct {
	Type        string
	Double      float64
	Long        int64
	Millisecond float64
	String      string
}

func (c *CellData) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *CellData) GetDouble() float64 {
	if c == nil {
		return 0
	}
	return c.Double
}

func (c *CellData) GetLong() int64 {
	if c == nil {
		return 0
	}
	return c.Long
}

func (c *CellData) GetMillisecond() float64 {
	if c == nil {
		return 0
	}
	return c.Millisecond
}

func (c *CellData) GetString() string {
	if c == nil {
		return ""
	}
	return c.String
}

func (c *CellData) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "double":
		var valueUnmarshaler struct {
			Double float64 `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Double = valueUnmarshaler.Double
	case "long":
		var valueUnmarshaler struct {
			Long int64 `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Long = valueUnmarshaler.Long
	case "millisecond":
		var valueUnmarshaler struct {
			Millisecond float64 `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.Millisecond = valueUnmarshaler.Millisecond
	case "string":
		var valueUnmarshaler struct {
			String string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		c.String = valueUnmarshaler.String
	}
	return nil
}

func (c CellData) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.Double != 0 {
		var marshaler = struct {
			Type   string  `json:"type"`
			Double float64 `json:"value"`
		}{
			Type:   "double",
			Double: c.Double,
		}
		return json.Marshal(marshaler)
	}
	if c.Long != 0 {
		var marshaler = struct {
			Type string `json:"type"`
			Long int64  `json:"value"`
		}{
			Type: "long",
			Long: c.Long,
		}
		return json.Marshal(marshaler)
	}
	if c.Millisecond != 0 {
		var marshaler = struct {
			Type        string  `json:"type"`
			Millisecond float64 `json:"value"`
		}{
			Type:        "millisecond",
			Millisecond: c.Millisecond,
		}
		return json.Marshal(marshaler)
	}
	if c.String != "" {
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"value"`
		}{
			Type:   "string",
			String: c.String,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type CellDataVisitor interface {
	VisitDouble(float64) error
	VisitLong(int64) error
	VisitMillisecond(float64) error
	VisitString(string) error
}

func (c *CellData) Accept(visitor CellDataVisitor) error {
	if c.Double != 0 {
		return visitor.VisitDouble(c.Double)
	}
	if c.Long != 0 {
		return visitor.VisitLong(c.Long)
	}
	if c.Millisecond != 0 {
		return visitor.VisitMillisecond(c.Millisecond)
	}
	if c.String != "" {
		return visitor.VisitString(c.String)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *CellData) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.Double != 0 {
		fields = append(fields, "double")
	}
	if c.Long != 0 {
		fields = append(fields, "long")
	}
	if c.Millisecond != 0 {
		fields = append(fields, "millisecond")
	}
	if c.String != "" {
		fields = append(fields, "string")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

type ChartResponse struct {
	Type          string
	PieChart      *PieChartResponse
	DateHistogram *DateHistogramResponse
	BarChart      *BarChartResponse
}

func (c *ChartResponse) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ChartResponse) GetPieChart() *PieChartResponse {
	if c == nil {
		return nil
	}
	return c.PieChart
}

func (c *ChartResponse) GetDateHistogram() *DateHistogramResponse {
	if c == nil {
		return nil
	}
	return c.DateHistogram
}

func (c *ChartResponse) GetBarChart() *BarChartResponse {
	if c == nil {
		return nil
	}
	return c.BarChart
}

func (c *ChartResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "pieChart":
		value := new(PieChartResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.PieChart = value
	case "dateHistogram":
		value := new(DateHistogramResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.DateHistogram = value
	case "barChart":
		value := new(BarChartResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.BarChart = value
	}
	return nil
}

func (c ChartResponse) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.PieChart != nil {
		return internal.MarshalJSONWithExtraProperty(c.PieChart, "type", "pieChart")
	}
	if c.DateHistogram != nil {
		return internal.MarshalJSONWithExtraProperty(c.DateHistogram, "type", "dateHistogram")
	}
	if c.BarChart != nil {
		return internal.MarshalJSONWithExtraProperty(c.BarChart, "type", "barChart")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ChartResponseVisitor interface {
	VisitPieChart(*PieChartResponse) error
	VisitDateHistogram(*DateHistogramResponse) error
	VisitBarChart(*BarChartResponse) error
}

func (c *ChartResponse) Accept(visitor ChartResponseVisitor) error {
	if c.PieChart != nil {
		return visitor.VisitPieChart(c.PieChart)
	}
	if c.DateHistogram != nil {
		return visitor.VisitDateHistogram(c.DateHistogram)
	}
	if c.BarChart != nil {
		return visitor.VisitBarChart(c.BarChart)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *ChartResponse) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.PieChart != nil {
		fields = append(fields, "pieChart")
	}
	if c.DateHistogram != nil {
		fields = append(fields, "dateHistogram")
	}
	if c.BarChart != nil {
		fields = append(fields, "barChart")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

var (
	columnDefinitionBaseFieldHeader = big.NewInt(1 << 0)
)

type ColumnDefinitionBase struct {
	// Unique column header, serving as the key for corresponding metric values.
	Header string `json:"header" url:"header"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ColumnDefinitionBase) GetHeader() string {
	if c == nil {
		return ""
	}
	return c.Header
}

func (c *ColumnDefinitionBase) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ColumnDefinitionBase) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetHeader sets the Header field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ColumnDefinitionBase) SetHeader(header string) {
	c.Header = header
	c.require(columnDefinitionBaseFieldHeader)
}

func (c *ColumnDefinitionBase) UnmarshalJSON(data []byte) error {
	type unmarshaler ColumnDefinitionBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ColumnDefinitionBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ColumnDefinitionBase) MarshalJSON() ([]byte, error) {
	type embed ColumnDefinitionBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ColumnDefinitionBase) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationAnalyticsRequestFieldConversationFilter = big.NewInt(1 << 0)
	conversationAnalyticsRequestFieldTimezone           = big.NewInt(1 << 1)
)

type ConversationAnalyticsRequest struct {
	// Optional filter applied to refine the conversation data before processing.
	ConversationFilter *ConversationFilter `json:"conversationFilter,omitempty" url:"conversationFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationAnalyticsRequest) GetConversationFilter() *ConversationFilter {
	if c == nil {
		return nil
	}
	return c.ConversationFilter
}

func (c *ConversationAnalyticsRequest) GetTimezone() *string {
	if c == nil {
		return nil
	}
	return c.Timezone
}

func (c *ConversationAnalyticsRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationAnalyticsRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetConversationFilter sets the ConversationFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalyticsRequest) SetConversationFilter(conversationFilter *ConversationFilter) {
	c.ConversationFilter = conversationFilter
	c.require(conversationAnalyticsRequestFieldConversationFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalyticsRequest) SetTimezone(timezone *string) {
	c.Timezone = timezone
	c.require(conversationAnalyticsRequestFieldTimezone)
}

func (c *ConversationAnalyticsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationAnalyticsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationAnalyticsRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationAnalyticsRequest) MarshalJSON() ([]byte, error) {
	type embed ConversationAnalyticsRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationAnalyticsRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Calculates the average value of the specified field.
var (
	conversationAverageFieldTargetField = big.NewInt(1 << 0)
)

type ConversationAverage struct {
	// Numeric field to apply the metric to.
	TargetField NumericConversationField `json:"targetField" url:"targetField"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationAverage) GetTargetField() NumericConversationField {
	if c == nil {
		return ""
	}
	return c.TargetField
}

func (c *ConversationAverage) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationAverage) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetTargetField sets the TargetField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAverage) SetTargetField(targetField NumericConversationField) {
	c.TargetField = targetField
	c.require(conversationAverageFieldTargetField)
}

func (c *ConversationAverage) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationAverage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationAverage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationAverage) MarshalJSON() ([]byte, error) {
	type embed ConversationAverage
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationAverage) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationBarChartRequestFieldConversationFilter = big.NewInt(1 << 0)
	conversationBarChartRequestFieldTimezone           = big.NewInt(1 << 1)
	conversationBarChartRequestFieldBarDefinition      = big.NewInt(1 << 2)
	conversationBarChartRequestFieldMetric             = big.NewInt(1 << 3)
	conversationBarChartRequestFieldVerticalGrouping   = big.NewInt(1 << 4)
)

type ConversationBarChartRequest struct {
	// Optional filter applied to refine the conversation data before processing.
	ConversationFilter *ConversationFilter `json:"conversationFilter,omitempty" url:"conversationFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// Determines how data is grouped along the x-axis. Each unique value forms a separate bar.
	// The name of the bar is derived from the grouping field's value or range.
	//
	// **Label Formats by Field:**
	// - `Sources`: Document title (e.g., "Product Documentation")
	// - `Actions`: "Action Name - App Name" (e.g., "Create Ticket - Freshdesk")
	// - `IncompleteActions`: "Action Name - App Name" (e.g., "Search Documents - Zendesk")
	// - `Users`: User identifier value (e.g., "user@example.com")
	// - `InboxItems`: Inbox item title
	// - `HumanAgents`: Human agent display name
	// - `HumanAgentsWithInserts`: Human agent display name (for agents who made inserts)
	// - Other fields: Field value as stored (e.g., "GOOD", "NEEDS_IMPROVEMENT" for Quality)
	BarDefinition *ConversationGroupBy `json:"barDefinition" url:"barDefinition"`
	// Metric defining the y-axis values for the bar chart.
	Metric *ConversationMetric `json:"metric" url:"metric"`
	// Optionally defines vertical grouping within each bar, producing multiple series.
	// If omitted, a single series is generated.
	//
	// **Series Name Formats by Field:**
	// - `Sources`: Document title (e.g., "Product Documentation")
	// - `Actions`: "Action Name - App Name" (e.g., "Create Ticket - Freshdesk")
	// - `IncompleteActions`: "Action Name - App Name" (e.g., "Search Documents - Zendesk")
	// - `Users`: User identifier value (e.g., "user@example.com")
	// - `InboxItems`: Inbox item title
	// - `HumanAgents`: Human agent display name
	// - `HumanAgentsWithInserts`: Human agent display name (for agents who made inserts)
	// - Other fields: Field value as stored (e.g., "GOOD", "NEEDS_IMPROVEMENT" for Quality)
	VerticalGrouping *ConversationGroupBy `json:"verticalGrouping,omitempty" url:"verticalGrouping,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationBarChartRequest) GetConversationFilter() *ConversationFilter {
	if c == nil {
		return nil
	}
	return c.ConversationFilter
}

func (c *ConversationBarChartRequest) GetTimezone() *string {
	if c == nil {
		return nil
	}
	return c.Timezone
}

func (c *ConversationBarChartRequest) GetBarDefinition() *ConversationGroupBy {
	if c == nil {
		return nil
	}
	return c.BarDefinition
}

func (c *ConversationBarChartRequest) GetMetric() *ConversationMetric {
	if c == nil {
		return nil
	}
	return c.Metric
}

func (c *ConversationBarChartRequest) GetVerticalGrouping() *ConversationGroupBy {
	if c == nil {
		return nil
	}
	return c.VerticalGrouping
}

func (c *ConversationBarChartRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationBarChartRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetConversationFilter sets the ConversationFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationBarChartRequest) SetConversationFilter(conversationFilter *ConversationFilter) {
	c.ConversationFilter = conversationFilter
	c.require(conversationBarChartRequestFieldConversationFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationBarChartRequest) SetTimezone(timezone *string) {
	c.Timezone = timezone
	c.require(conversationBarChartRequestFieldTimezone)
}

// SetBarDefinition sets the BarDefinition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationBarChartRequest) SetBarDefinition(barDefinition *ConversationGroupBy) {
	c.BarDefinition = barDefinition
	c.require(conversationBarChartRequestFieldBarDefinition)
}

// SetMetric sets the Metric field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationBarChartRequest) SetMetric(metric *ConversationMetric) {
	c.Metric = metric
	c.require(conversationBarChartRequestFieldMetric)
}

// SetVerticalGrouping sets the VerticalGrouping field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationBarChartRequest) SetVerticalGrouping(verticalGrouping *ConversationGroupBy) {
	c.VerticalGrouping = verticalGrouping
	c.require(conversationBarChartRequestFieldVerticalGrouping)
}

func (c *ConversationBarChartRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationBarChartRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationBarChartRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationBarChartRequest) MarshalJSON() ([]byte, error) {
	type embed ConversationBarChartRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationBarChartRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationBasicMetricFieldTargetField = big.NewInt(1 << 0)
)

type ConversationBasicMetric struct {
	// Field to apply the metric to.
	TargetField ConversationField `json:"targetField" url:"targetField"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationBasicMetric) GetTargetField() ConversationField {
	if c == nil {
		return ""
	}
	return c.TargetField
}

func (c *ConversationBasicMetric) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationBasicMetric) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetTargetField sets the TargetField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationBasicMetric) SetTargetField(targetField ConversationField) {
	c.TargetField = targetField
	c.require(conversationBasicMetricFieldTargetField)
}

func (c *ConversationBasicMetric) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationBasicMetric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationBasicMetric(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationBasicMetric) MarshalJSON() ([]byte, error) {
	type embed ConversationBasicMetric
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationBasicMetric) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConversationChartRequest struct {
	Type          string
	PieChart      *ConversationPieChartRequest
	DateHistogram *ConversationDateHistogramRequest
	BarChart      *ConversationBarChartRequest
}

func (c *ConversationChartRequest) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ConversationChartRequest) GetPieChart() *ConversationPieChartRequest {
	if c == nil {
		return nil
	}
	return c.PieChart
}

func (c *ConversationChartRequest) GetDateHistogram() *ConversationDateHistogramRequest {
	if c == nil {
		return nil
	}
	return c.DateHistogram
}

func (c *ConversationChartRequest) GetBarChart() *ConversationBarChartRequest {
	if c == nil {
		return nil
	}
	return c.BarChart
}

func (c *ConversationChartRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "pieChart":
		value := new(ConversationPieChartRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.PieChart = value
	case "dateHistogram":
		value := new(ConversationDateHistogramRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.DateHistogram = value
	case "barChart":
		value := new(ConversationBarChartRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.BarChart = value
	}
	return nil
}

func (c ConversationChartRequest) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.PieChart != nil {
		return internal.MarshalJSONWithExtraProperty(c.PieChart, "type", "pieChart")
	}
	if c.DateHistogram != nil {
		return internal.MarshalJSONWithExtraProperty(c.DateHistogram, "type", "dateHistogram")
	}
	if c.BarChart != nil {
		return internal.MarshalJSONWithExtraProperty(c.BarChart, "type", "barChart")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ConversationChartRequestVisitor interface {
	VisitPieChart(*ConversationPieChartRequest) error
	VisitDateHistogram(*ConversationDateHistogramRequest) error
	VisitBarChart(*ConversationBarChartRequest) error
}

func (c *ConversationChartRequest) Accept(visitor ConversationChartRequestVisitor) error {
	if c.PieChart != nil {
		return visitor.VisitPieChart(c.PieChart)
	}
	if c.DateHistogram != nil {
		return visitor.VisitDateHistogram(c.DateHistogram)
	}
	if c.BarChart != nil {
		return visitor.VisitBarChart(c.BarChart)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *ConversationChartRequest) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.PieChart != nil {
		fields = append(fields, "pieChart")
	}
	if c.DateHistogram != nil {
		fields = append(fields, "dateHistogram")
	}
	if c.BarChart != nil {
		fields = append(fields, "barChart")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

var (
	conversationColumnDefinitionFieldHeader = big.NewInt(1 << 0)
	conversationColumnDefinitionFieldMetric = big.NewInt(1 << 1)
)

type ConversationColumnDefinition struct {
	// Unique column header, serving as the key for corresponding metric values.
	Header string `json:"header" url:"header"`
	// The metric calculated for this column, stored in the row data under the specified header.
	Metric *ConversationMetric `json:"metric" url:"metric"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationColumnDefinition) GetHeader() string {
	if c == nil {
		return ""
	}
	return c.Header
}

func (c *ConversationColumnDefinition) GetMetric() *ConversationMetric {
	if c == nil {
		return nil
	}
	return c.Metric
}

func (c *ConversationColumnDefinition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationColumnDefinition) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetHeader sets the Header field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationColumnDefinition) SetHeader(header string) {
	c.Header = header
	c.require(conversationColumnDefinitionFieldHeader)
}

// SetMetric sets the Metric field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationColumnDefinition) SetMetric(metric *ConversationMetric) {
	c.Metric = metric
	c.require(conversationColumnDefinitionFieldMetric)
}

func (c *ConversationColumnDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationColumnDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationColumnDefinition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationColumnDefinition) MarshalJSON() ([]byte, error) {
	type embed ConversationColumnDefinition
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationColumnDefinition) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Returns the total count of records in a group.
type ConversationCount struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationCount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationCount) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

func (c *ConversationCount) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationCount) MarshalJSON() ([]byte, error) {
	type embed ConversationCount
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationCount) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationDateHistogramRequestFieldConversationFilter = big.NewInt(1 << 0)
	conversationDateHistogramRequestFieldTimezone           = big.NewInt(1 << 1)
	conversationDateHistogramRequestFieldTimeInterval       = big.NewInt(1 << 2)
	conversationDateHistogramRequestFieldGroupBy            = big.NewInt(1 << 3)
	conversationDateHistogramRequestFieldMetric             = big.NewInt(1 << 4)
)

type ConversationDateHistogramRequest struct {
	// Optional filter applied to refine the conversation data before processing.
	ConversationFilter *ConversationFilter `json:"conversationFilter,omitempty" url:"conversationFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// Time-based grouping interval (e.g., HOUR, DAY, WEEK) for the date histogram.
	TimeInterval TimeInterval `json:"timeInterval" url:"timeInterval"`
	// Groups data before applying calculations, forming a separate time series for each group.
	//
	// **Series Name Formats by Field:**
	// - `Sources`: Document title (e.g., "Product Documentation")
	// - `Actions`: "Action Name - App Name" (e.g., "Create Ticket - Freshdesk")
	// - `IncompleteActions`: "Action Name - App Name" (e.g., "Search Documents - Zendesk")
	// - `Users`: User identifier value (e.g., "user@example.com")
	// - `InboxItems`: Inbox item title
	// - `HumanAgents`: Human agent display name
	// - `HumanAgentsWithInserts`: Human agent display name (for agents who made inserts)
	// - Other fields: Field value as stored (e.g., "GOOD", "NEEDS_IMPROVEMENT" for Quality)
	GroupBy *ConversationGroupBy `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// Defines the y-axis values for the date histogram.
	Metric *ConversationMetric `json:"metric" url:"metric"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationDateHistogramRequest) GetConversationFilter() *ConversationFilter {
	if c == nil {
		return nil
	}
	return c.ConversationFilter
}

func (c *ConversationDateHistogramRequest) GetTimezone() *string {
	if c == nil {
		return nil
	}
	return c.Timezone
}

func (c *ConversationDateHistogramRequest) GetTimeInterval() TimeInterval {
	if c == nil {
		return ""
	}
	return c.TimeInterval
}

func (c *ConversationDateHistogramRequest) GetGroupBy() *ConversationGroupBy {
	if c == nil {
		return nil
	}
	return c.GroupBy
}

func (c *ConversationDateHistogramRequest) GetMetric() *ConversationMetric {
	if c == nil {
		return nil
	}
	return c.Metric
}

func (c *ConversationDateHistogramRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationDateHistogramRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetConversationFilter sets the ConversationFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationDateHistogramRequest) SetConversationFilter(conversationFilter *ConversationFilter) {
	c.ConversationFilter = conversationFilter
	c.require(conversationDateHistogramRequestFieldConversationFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationDateHistogramRequest) SetTimezone(timezone *string) {
	c.Timezone = timezone
	c.require(conversationDateHistogramRequestFieldTimezone)
}

// SetTimeInterval sets the TimeInterval field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationDateHistogramRequest) SetTimeInterval(timeInterval TimeInterval) {
	c.TimeInterval = timeInterval
	c.require(conversationDateHistogramRequestFieldTimeInterval)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationDateHistogramRequest) SetGroupBy(groupBy *ConversationGroupBy) {
	c.GroupBy = groupBy
	c.require(conversationDateHistogramRequestFieldGroupBy)
}

// SetMetric sets the Metric field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationDateHistogramRequest) SetMetric(metric *ConversationMetric) {
	c.Metric = metric
	c.require(conversationDateHistogramRequestFieldMetric)
}

func (c *ConversationDateHistogramRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationDateHistogramRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationDateHistogramRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationDateHistogramRequest) MarshalJSON() ([]byte, error) {
	type embed ConversationDateHistogramRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationDateHistogramRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Calculates the number of unique values in the specified field.
// Supports fields with list values as well.
var (
	conversationDistinctCountFieldTargetField = big.NewInt(1 << 0)
)

type ConversationDistinctCount struct {
	// Field to apply the metric to.
	TargetField ConversationField `json:"targetField" url:"targetField"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationDistinctCount) GetTargetField() ConversationField {
	if c == nil {
		return ""
	}
	return c.TargetField
}

func (c *ConversationDistinctCount) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationDistinctCount) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetTargetField sets the TargetField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationDistinctCount) SetTargetField(targetField ConversationField) {
	c.TargetField = targetField
	c.require(conversationDistinctCountFieldTargetField)
}

func (c *ConversationDistinctCount) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationDistinctCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationDistinctCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationDistinctCount) MarshalJSON() ([]byte, error) {
	type embed ConversationDistinctCount
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationDistinctCount) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationGroupByFieldLimit  = big.NewInt(1 << 0)
	conversationGroupByFieldField  = big.NewInt(1 << 1)
	conversationGroupByFieldRanges = big.NewInt(1 << 2)
)

type ConversationGroupBy struct {
	// Limits the number of groups returned (defaults to 100 if omitted).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Field used for data grouping.
	Field ConversationField `json:"field" url:"field"`
	// Numeric ranges for grouping data into predefined buckets. Applies only to numeric fields.
	Ranges []*Range `json:"ranges,omitempty" url:"ranges,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationGroupBy) GetLimit() *int {
	if c == nil {
		return nil
	}
	return c.Limit
}

func (c *ConversationGroupBy) GetField() ConversationField {
	if c == nil {
		return ""
	}
	return c.Field
}

func (c *ConversationGroupBy) GetRanges() []*Range {
	if c == nil {
		return nil
	}
	return c.Ranges
}

func (c *ConversationGroupBy) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationGroupBy) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationGroupBy) SetLimit(limit *int) {
	c.Limit = limit
	c.require(conversationGroupByFieldLimit)
}

// SetField sets the Field field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationGroupBy) SetField(field ConversationField) {
	c.Field = field
	c.require(conversationGroupByFieldField)
}

// SetRanges sets the Ranges field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationGroupBy) SetRanges(ranges []*Range) {
	c.Ranges = ranges
	c.require(conversationGroupByFieldRanges)
}

func (c *ConversationGroupBy) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationGroupBy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationGroupBy(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationGroupBy) MarshalJSON() ([]byte, error) {
	type embed ConversationGroupBy
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationGroupBy) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Retrieves the maximum value of the specified field.
var (
	conversationMaxFieldTargetField = big.NewInt(1 << 0)
)

type ConversationMax struct {
	// Numeric field to apply the metric to.
	TargetField NumericConversationField `json:"targetField" url:"targetField"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationMax) GetTargetField() NumericConversationField {
	if c == nil {
		return ""
	}
	return c.TargetField
}

func (c *ConversationMax) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationMax) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetTargetField sets the TargetField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMax) SetTargetField(targetField NumericConversationField) {
	c.TargetField = targetField
	c.require(conversationMaxFieldTargetField)
}

func (c *ConversationMax) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationMax
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationMax(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationMax) MarshalJSON() ([]byte, error) {
	type embed ConversationMax
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationMax) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Computes the median value of the specified field.
var (
	conversationMedianFieldTargetField = big.NewInt(1 << 0)
)

type ConversationMedian struct {
	// Numeric field to apply the metric to.
	TargetField NumericConversationField `json:"targetField" url:"targetField"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationMedian) GetTargetField() NumericConversationField {
	if c == nil {
		return ""
	}
	return c.TargetField
}

func (c *ConversationMedian) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationMedian) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetTargetField sets the TargetField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMedian) SetTargetField(targetField NumericConversationField) {
	c.TargetField = targetField
	c.require(conversationMedianFieldTargetField)
}

func (c *ConversationMedian) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationMedian
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationMedian(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationMedian) MarshalJSON() ([]byte, error) {
	type embed ConversationMedian
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationMedian) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defines the metric to be calculated for a column or chart.
// Only numeric fields are supported, except for ConversationCount and ConversationDistinctCount, which can be applied to any field.
type ConversationMetric struct {
	Type          string
	Count         *ConversationCount
	Sum           *ConversationSum
	Average       *ConversationAverage
	Min           *ConversationMin
	Max           *ConversationMax
	Percentile    *ConversationPercentile
	Median        *ConversationMedian
	DistinctCount *ConversationDistinctCount
}

func (c *ConversationMetric) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ConversationMetric) GetCount() *ConversationCount {
	if c == nil {
		return nil
	}
	return c.Count
}

func (c *ConversationMetric) GetSum() *ConversationSum {
	if c == nil {
		return nil
	}
	return c.Sum
}

func (c *ConversationMetric) GetAverage() *ConversationAverage {
	if c == nil {
		return nil
	}
	return c.Average
}

func (c *ConversationMetric) GetMin() *ConversationMin {
	if c == nil {
		return nil
	}
	return c.Min
}

func (c *ConversationMetric) GetMax() *ConversationMax {
	if c == nil {
		return nil
	}
	return c.Max
}

func (c *ConversationMetric) GetPercentile() *ConversationPercentile {
	if c == nil {
		return nil
	}
	return c.Percentile
}

func (c *ConversationMetric) GetMedian() *ConversationMedian {
	if c == nil {
		return nil
	}
	return c.Median
}

func (c *ConversationMetric) GetDistinctCount() *ConversationDistinctCount {
	if c == nil {
		return nil
	}
	return c.DistinctCount
}

func (c *ConversationMetric) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "count":
		value := new(ConversationCount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Count = value
	case "sum":
		value := new(ConversationSum)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Sum = value
	case "average":
		value := new(ConversationAverage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Average = value
	case "min":
		value := new(ConversationMin)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Min = value
	case "max":
		value := new(ConversationMax)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Max = value
	case "percentile":
		value := new(ConversationPercentile)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Percentile = value
	case "median":
		value := new(ConversationMedian)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Median = value
	case "distinctCount":
		value := new(ConversationDistinctCount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.DistinctCount = value
	}
	return nil
}

func (c ConversationMetric) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.Count != nil {
		return internal.MarshalJSONWithExtraProperty(c.Count, "type", "count")
	}
	if c.Sum != nil {
		return internal.MarshalJSONWithExtraProperty(c.Sum, "type", "sum")
	}
	if c.Average != nil {
		return internal.MarshalJSONWithExtraProperty(c.Average, "type", "average")
	}
	if c.Min != nil {
		return internal.MarshalJSONWithExtraProperty(c.Min, "type", "min")
	}
	if c.Max != nil {
		return internal.MarshalJSONWithExtraProperty(c.Max, "type", "max")
	}
	if c.Percentile != nil {
		return internal.MarshalJSONWithExtraProperty(c.Percentile, "type", "percentile")
	}
	if c.Median != nil {
		return internal.MarshalJSONWithExtraProperty(c.Median, "type", "median")
	}
	if c.DistinctCount != nil {
		return internal.MarshalJSONWithExtraProperty(c.DistinctCount, "type", "distinctCount")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ConversationMetricVisitor interface {
	VisitCount(*ConversationCount) error
	VisitSum(*ConversationSum) error
	VisitAverage(*ConversationAverage) error
	VisitMin(*ConversationMin) error
	VisitMax(*ConversationMax) error
	VisitPercentile(*ConversationPercentile) error
	VisitMedian(*ConversationMedian) error
	VisitDistinctCount(*ConversationDistinctCount) error
}

func (c *ConversationMetric) Accept(visitor ConversationMetricVisitor) error {
	if c.Count != nil {
		return visitor.VisitCount(c.Count)
	}
	if c.Sum != nil {
		return visitor.VisitSum(c.Sum)
	}
	if c.Average != nil {
		return visitor.VisitAverage(c.Average)
	}
	if c.Min != nil {
		return visitor.VisitMin(c.Min)
	}
	if c.Max != nil {
		return visitor.VisitMax(c.Max)
	}
	if c.Percentile != nil {
		return visitor.VisitPercentile(c.Percentile)
	}
	if c.Median != nil {
		return visitor.VisitMedian(c.Median)
	}
	if c.DistinctCount != nil {
		return visitor.VisitDistinctCount(c.DistinctCount)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *ConversationMetric) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.Count != nil {
		fields = append(fields, "count")
	}
	if c.Sum != nil {
		fields = append(fields, "sum")
	}
	if c.Average != nil {
		fields = append(fields, "average")
	}
	if c.Min != nil {
		fields = append(fields, "min")
	}
	if c.Max != nil {
		fields = append(fields, "max")
	}
	if c.Percentile != nil {
		fields = append(fields, "percentile")
	}
	if c.Median != nil {
		fields = append(fields, "median")
	}
	if c.DistinctCount != nil {
		fields = append(fields, "distinctCount")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

// Retrieves the minimum value of the specified field.
var (
	conversationMinFieldTargetField = big.NewInt(1 << 0)
)

type ConversationMin struct {
	// Numeric field to apply the metric to.
	TargetField NumericConversationField `json:"targetField" url:"targetField"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationMin) GetTargetField() NumericConversationField {
	if c == nil {
		return ""
	}
	return c.TargetField
}

func (c *ConversationMin) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationMin) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetTargetField sets the TargetField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMin) SetTargetField(targetField NumericConversationField) {
	c.TargetField = targetField
	c.require(conversationMinFieldTargetField)
}

func (c *ConversationMin) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationMin
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationMin(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationMin) MarshalJSON() ([]byte, error) {
	type embed ConversationMin
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationMin) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationNumericMetricFieldTargetField = big.NewInt(1 << 0)
)

type ConversationNumericMetric struct {
	// Numeric field to apply the metric to.
	TargetField NumericConversationField `json:"targetField" url:"targetField"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationNumericMetric) GetTargetField() NumericConversationField {
	if c == nil {
		return ""
	}
	return c.TargetField
}

func (c *ConversationNumericMetric) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationNumericMetric) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetTargetField sets the TargetField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationNumericMetric) SetTargetField(targetField NumericConversationField) {
	c.TargetField = targetField
	c.require(conversationNumericMetricFieldTargetField)
}

func (c *ConversationNumericMetric) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationNumericMetric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationNumericMetric(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationNumericMetric) MarshalJSON() ([]byte, error) {
	type embed ConversationNumericMetric
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationNumericMetric) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Calculates specified percentile for a numeric field.
var (
	conversationPercentileFieldTargetField = big.NewInt(1 << 0)
	conversationPercentileFieldPercentile  = big.NewInt(1 << 1)
)

type ConversationPercentile struct {
	// Numeric field to apply the metric to.
	TargetField NumericConversationField `json:"targetField" url:"targetField"`
	// The percentile to calculate. Example: 25 computes the 25th percentile.
	Percentile float64 `json:"percentile" url:"percentile"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationPercentile) GetTargetField() NumericConversationField {
	if c == nil {
		return ""
	}
	return c.TargetField
}

func (c *ConversationPercentile) GetPercentile() float64 {
	if c == nil {
		return 0
	}
	return c.Percentile
}

func (c *ConversationPercentile) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationPercentile) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetTargetField sets the TargetField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPercentile) SetTargetField(targetField NumericConversationField) {
	c.TargetField = targetField
	c.require(conversationPercentileFieldTargetField)
}

// SetPercentile sets the Percentile field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPercentile) SetPercentile(percentile float64) {
	c.Percentile = percentile
	c.require(conversationPercentileFieldPercentile)
}

func (c *ConversationPercentile) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationPercentile
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationPercentile(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationPercentile) MarshalJSON() ([]byte, error) {
	type embed ConversationPercentile
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationPercentile) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationPieChartRequestFieldConversationFilter = big.NewInt(1 << 0)
	conversationPieChartRequestFieldTimezone           = big.NewInt(1 << 1)
	conversationPieChartRequestFieldGroupBy            = big.NewInt(1 << 2)
	conversationPieChartRequestFieldMetric             = big.NewInt(1 << 3)
)

type ConversationPieChartRequest struct {
	// Optional filter applied to refine the conversation data before processing.
	ConversationFilter *ConversationFilter `json:"conversationFilter,omitempty" url:"conversationFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// Field used to group data into slices for the pie chart.
	//
	// **Series Name Formats by Field:**
	// - `Sources`: Document title (e.g., "Product Documentation")
	// - `Actions`: "Action Name - App Name" (e.g., "Create Ticket - Freshdesk")
	// - `IncompleteActions`: "Action Name - App Name" (e.g., "Search Documents - Zendesk")
	// - `Users`: User identifier value (e.g., "user@example.com")
	// - `InboxItems`: Inbox item title
	// - `HumanAgents`: Human agent display name
	// - `HumanAgentsWithInserts`: Human agent display name (for agents who made inserts)
	// - Other fields: Field value as stored (e.g., "GOOD", "NEEDS_IMPROVEMENT" for Quality)
	GroupBy *ConversationGroupBy `json:"groupBy" url:"groupBy"`
	// Metric defining the value for each pie slice, stored in the y-axis value.
	Metric *ConversationMetric `json:"metric" url:"metric"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationPieChartRequest) GetConversationFilter() *ConversationFilter {
	if c == nil {
		return nil
	}
	return c.ConversationFilter
}

func (c *ConversationPieChartRequest) GetTimezone() *string {
	if c == nil {
		return nil
	}
	return c.Timezone
}

func (c *ConversationPieChartRequest) GetGroupBy() *ConversationGroupBy {
	if c == nil {
		return nil
	}
	return c.GroupBy
}

func (c *ConversationPieChartRequest) GetMetric() *ConversationMetric {
	if c == nil {
		return nil
	}
	return c.Metric
}

func (c *ConversationPieChartRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationPieChartRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetConversationFilter sets the ConversationFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPieChartRequest) SetConversationFilter(conversationFilter *ConversationFilter) {
	c.ConversationFilter = conversationFilter
	c.require(conversationPieChartRequestFieldConversationFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPieChartRequest) SetTimezone(timezone *string) {
	c.Timezone = timezone
	c.require(conversationPieChartRequestFieldTimezone)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPieChartRequest) SetGroupBy(groupBy *ConversationGroupBy) {
	c.GroupBy = groupBy
	c.require(conversationPieChartRequestFieldGroupBy)
}

// SetMetric sets the Metric field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPieChartRequest) SetMetric(metric *ConversationMetric) {
	c.Metric = metric
	c.require(conversationPieChartRequestFieldMetric)
}

func (c *ConversationPieChartRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationPieChartRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationPieChartRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationPieChartRequest) MarshalJSON() ([]byte, error) {
	type embed ConversationPieChartRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationPieChartRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationRowFieldData       = big.NewInt(1 << 0)
	conversationRowFieldIdentifier = big.NewInt(1 << 1)
)

type ConversationRow struct {
	// The actual row data, where keys represent column headers and values contain the respective metric results.
	Data map[string]*CellData `json:"data" url:"data"`
	// A unique identifier for each row, consisting of field names mapped to their respective values.
	// This includes time groupings and any specified field groupings.
	Identifier map[ConversationField]*FieldValue `json:"identifier" url:"identifier"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationRow) GetData() map[string]*CellData {
	if c == nil {
		return nil
	}
	return c.Data
}

func (c *ConversationRow) GetIdentifier() map[ConversationField]*FieldValue {
	if c == nil {
		return nil
	}
	return c.Identifier
}

func (c *ConversationRow) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationRow) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRow) SetData(data map[string]*CellData) {
	c.Data = data
	c.require(conversationRowFieldData)
}

// SetIdentifier sets the Identifier field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationRow) SetIdentifier(identifier map[ConversationField]*FieldValue) {
	c.Identifier = identifier
	c.require(conversationRowFieldIdentifier)
}

func (c *ConversationRow) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationRow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationRow(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationRow) MarshalJSON() ([]byte, error) {
	type embed ConversationRow
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationRow) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Computes the sum of all values in the specified field.
var (
	conversationSumFieldTargetField = big.NewInt(1 << 0)
)

type ConversationSum struct {
	// Numeric field to apply the metric to.
	TargetField NumericConversationField `json:"targetField" url:"targetField"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationSum) GetTargetField() NumericConversationField {
	if c == nil {
		return ""
	}
	return c.TargetField
}

func (c *ConversationSum) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationSum) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetTargetField sets the TargetField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSum) SetTargetField(targetField NumericConversationField) {
	c.TargetField = targetField
	c.require(conversationSumFieldTargetField)
}

func (c *ConversationSum) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationSum
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationSum(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationSum) MarshalJSON() ([]byte, error) {
	type embed ConversationSum
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationSum) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationTableRequestFieldConversationFilter = big.NewInt(1 << 0)
	conversationTableRequestFieldTimezone           = big.NewInt(1 << 1)
	conversationTableRequestFieldTimeGrouping       = big.NewInt(1 << 2)
	conversationTableRequestFieldFieldGroupings     = big.NewInt(1 << 3)
	conversationTableRequestFieldColumnDefinitions  = big.NewInt(1 << 4)
)

type ConversationTableRequest struct {
	// Optional filter applied to refine the conversation data before processing.
	ConversationFilter *ConversationFilter `json:"conversationFilter,omitempty" url:"conversationFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// Defines the time interval for grouping data. If specified, data is grouped accordingly  based on the time they were created. Example: If set to "DAY," data will be aggregated by day.
	TimeGrouping *TimeInterval `json:"timeGrouping,omitempty" url:"timeGrouping,omitempty"`
	// Specifies the fields by which data should be grouped. Each unique combination forms a row.
	// If multiple fields are provided, the result is grouped by their unique value combinations.
	// If empty, all data is aggregated into a single row. |
	// Note: The field `CreatedAt` should not be used here, all time-based grouping should be done using the `timeGrouping` field.
	FieldGroupings []*ConversationGroupBy `json:"fieldGroupings" url:"fieldGroupings"`
	// Specifies the metrics to be displayed as columns. Column headers act as keys, with computed metric values as their mapped values. There needs to be at least one column definition in the table request.
	ColumnDefinitions []*ConversationColumnDefinition `json:"columnDefinitions" url:"columnDefinitions"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationTableRequest) GetConversationFilter() *ConversationFilter {
	if c == nil {
		return nil
	}
	return c.ConversationFilter
}

func (c *ConversationTableRequest) GetTimezone() *string {
	if c == nil {
		return nil
	}
	return c.Timezone
}

func (c *ConversationTableRequest) GetTimeGrouping() *TimeInterval {
	if c == nil {
		return nil
	}
	return c.TimeGrouping
}

func (c *ConversationTableRequest) GetFieldGroupings() []*ConversationGroupBy {
	if c == nil {
		return nil
	}
	return c.FieldGroupings
}

func (c *ConversationTableRequest) GetColumnDefinitions() []*ConversationColumnDefinition {
	if c == nil {
		return nil
	}
	return c.ColumnDefinitions
}

func (c *ConversationTableRequest) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationTableRequest) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetConversationFilter sets the ConversationFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationTableRequest) SetConversationFilter(conversationFilter *ConversationFilter) {
	c.ConversationFilter = conversationFilter
	c.require(conversationTableRequestFieldConversationFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationTableRequest) SetTimezone(timezone *string) {
	c.Timezone = timezone
	c.require(conversationTableRequestFieldTimezone)
}

// SetTimeGrouping sets the TimeGrouping field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationTableRequest) SetTimeGrouping(timeGrouping *TimeInterval) {
	c.TimeGrouping = timeGrouping
	c.require(conversationTableRequestFieldTimeGrouping)
}

// SetFieldGroupings sets the FieldGroupings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationTableRequest) SetFieldGroupings(fieldGroupings []*ConversationGroupBy) {
	c.FieldGroupings = fieldGroupings
	c.require(conversationTableRequestFieldFieldGroupings)
}

// SetColumnDefinitions sets the ColumnDefinitions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationTableRequest) SetColumnDefinitions(columnDefinitions []*ConversationColumnDefinition) {
	c.ColumnDefinitions = columnDefinitions
	c.require(conversationTableRequestFieldColumnDefinitions)
}

func (c *ConversationTableRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationTableRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationTableRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationTableRequest) MarshalJSON() ([]byte, error) {
	type embed ConversationTableRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationTableRequest) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationTableResponseFieldHeaders = big.NewInt(1 << 0)
	conversationTableResponseFieldRows    = big.NewInt(1 << 1)
)

type ConversationTableResponse struct {
	// Column headers in the table, aligning with the column definitions specified in the request.
	Headers []string `json:"headers" url:"headers"`
	// The dataset rows, where each row represents a unique combination of grouping field values.
	// The identifier map contains grouping field names mapped to their respective values.
	// The data map contains column headers mapped to their respective metric values.
	Rows []*ConversationRow `json:"rows" url:"rows"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationTableResponse) GetHeaders() []string {
	if c == nil {
		return nil
	}
	return c.Headers
}

func (c *ConversationTableResponse) GetRows() []*ConversationRow {
	if c == nil {
		return nil
	}
	return c.Rows
}

func (c *ConversationTableResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationTableResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationTableResponse) SetHeaders(headers []string) {
	c.Headers = headers
	c.require(conversationTableResponseFieldHeaders)
}

// SetRows sets the Rows field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationTableResponse) SetRows(rows []*ConversationRow) {
	c.Rows = rows
	c.require(conversationTableResponseFieldRows)
}

func (c *ConversationTableResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationTableResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationTableResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationTableResponse) MarshalJSON() ([]byte, error) {
	type embed ConversationTableResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationTableResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	dateHistogramResponseFieldTimeSeries = big.NewInt(1 << 0)
)

type DateHistogramResponse struct {
	// The dataset for the date histogram.
	// Each series represents a separate plottable time series.
	// Series names reflect the grouping field values.
	TimeSeries []*TimeSeries `json:"timeSeries" url:"timeSeries"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DateHistogramResponse) GetTimeSeries() []*TimeSeries {
	if d == nil {
		return nil
	}
	return d.TimeSeries
}

func (d *DateHistogramResponse) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DateHistogramResponse) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetTimeSeries sets the TimeSeries field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DateHistogramResponse) SetTimeSeries(timeSeries []*TimeSeries) {
	d.TimeSeries = timeSeries
	d.require(dateHistogramResponseFieldTimeSeries)
}

func (d *DateHistogramResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DateHistogramResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DateHistogramResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DateHistogramResponse) MarshalJSON() ([]byte, error) {
	type embed DateHistogramResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DateHistogramResponse) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	eventAnalyticsRequestFieldEventFilter = big.NewInt(1 << 0)
	eventAnalyticsRequestFieldTimezone    = big.NewInt(1 << 1)
)

type EventAnalyticsRequest struct {
	// Optional filter applied to refine the event data before processing.
	EventFilter *EventFilter `json:"eventFilter,omitempty" url:"eventFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventAnalyticsRequest) GetEventFilter() *EventFilter {
	if e == nil {
		return nil
	}
	return e.EventFilter
}

func (e *EventAnalyticsRequest) GetTimezone() *string {
	if e == nil {
		return nil
	}
	return e.Timezone
}

func (e *EventAnalyticsRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventAnalyticsRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEventFilter sets the EventFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventAnalyticsRequest) SetEventFilter(eventFilter *EventFilter) {
	e.EventFilter = eventFilter
	e.require(eventAnalyticsRequestFieldEventFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventAnalyticsRequest) SetTimezone(timezone *string) {
	e.Timezone = timezone
	e.require(eventAnalyticsRequestFieldTimezone)
}

func (e *EventAnalyticsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EventAnalyticsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventAnalyticsRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventAnalyticsRequest) MarshalJSON() ([]byte, error) {
	type embed EventAnalyticsRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventAnalyticsRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventBarChartRequestFieldEventFilter      = big.NewInt(1 << 0)
	eventBarChartRequestFieldTimezone         = big.NewInt(1 << 1)
	eventBarChartRequestFieldBarDefinition    = big.NewInt(1 << 2)
	eventBarChartRequestFieldMetric           = big.NewInt(1 << 3)
	eventBarChartRequestFieldVerticalGrouping = big.NewInt(1 << 4)
)

type EventBarChartRequest struct {
	// Optional filter applied to refine the event data before processing.
	EventFilter *EventFilter `json:"eventFilter,omitempty" url:"eventFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// Determines how data is grouped along the x-axis. Each unique value forms a separate bar.
	BarDefinition *EventGroupBy `json:"barDefinition" url:"barDefinition"`
	// Metric defining the y-axis values for the bar chart.
	Metric *EventMetric `json:"metric" url:"metric"`
	// Optionally defines vertical grouping within each bar, producing multiple series.
	// If omitted, a single series is generated.
	VerticalGrouping *EventGroupBy `json:"verticalGrouping,omitempty" url:"verticalGrouping,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventBarChartRequest) GetEventFilter() *EventFilter {
	if e == nil {
		return nil
	}
	return e.EventFilter
}

func (e *EventBarChartRequest) GetTimezone() *string {
	if e == nil {
		return nil
	}
	return e.Timezone
}

func (e *EventBarChartRequest) GetBarDefinition() *EventGroupBy {
	if e == nil {
		return nil
	}
	return e.BarDefinition
}

func (e *EventBarChartRequest) GetMetric() *EventMetric {
	if e == nil {
		return nil
	}
	return e.Metric
}

func (e *EventBarChartRequest) GetVerticalGrouping() *EventGroupBy {
	if e == nil {
		return nil
	}
	return e.VerticalGrouping
}

func (e *EventBarChartRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventBarChartRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEventFilter sets the EventFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBarChartRequest) SetEventFilter(eventFilter *EventFilter) {
	e.EventFilter = eventFilter
	e.require(eventBarChartRequestFieldEventFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBarChartRequest) SetTimezone(timezone *string) {
	e.Timezone = timezone
	e.require(eventBarChartRequestFieldTimezone)
}

// SetBarDefinition sets the BarDefinition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBarChartRequest) SetBarDefinition(barDefinition *EventGroupBy) {
	e.BarDefinition = barDefinition
	e.require(eventBarChartRequestFieldBarDefinition)
}

// SetMetric sets the Metric field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBarChartRequest) SetMetric(metric *EventMetric) {
	e.Metric = metric
	e.require(eventBarChartRequestFieldMetric)
}

// SetVerticalGrouping sets the VerticalGrouping field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBarChartRequest) SetVerticalGrouping(verticalGrouping *EventGroupBy) {
	e.VerticalGrouping = verticalGrouping
	e.require(eventBarChartRequestFieldVerticalGrouping)
}

func (e *EventBarChartRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EventBarChartRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventBarChartRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventBarChartRequest) MarshalJSON() ([]byte, error) {
	type embed EventBarChartRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventBarChartRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventChartRequest struct {
	Type          string
	PieChart      *EventPieChartRequest
	DateHistogram *EventDateHistogramRequest
	BarChart      *EventBarChartRequest
}

func (e *EventChartRequest) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EventChartRequest) GetPieChart() *EventPieChartRequest {
	if e == nil {
		return nil
	}
	return e.PieChart
}

func (e *EventChartRequest) GetDateHistogram() *EventDateHistogramRequest {
	if e == nil {
		return nil
	}
	return e.DateHistogram
}

func (e *EventChartRequest) GetBarChart() *EventBarChartRequest {
	if e == nil {
		return nil
	}
	return e.BarChart
}

func (e *EventChartRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "pieChart":
		value := new(EventPieChartRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.PieChart = value
	case "dateHistogram":
		value := new(EventDateHistogramRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DateHistogram = value
	case "barChart":
		value := new(EventBarChartRequest)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.BarChart = value
	}
	return nil
}

func (e EventChartRequest) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.PieChart != nil {
		return internal.MarshalJSONWithExtraProperty(e.PieChart, "type", "pieChart")
	}
	if e.DateHistogram != nil {
		return internal.MarshalJSONWithExtraProperty(e.DateHistogram, "type", "dateHistogram")
	}
	if e.BarChart != nil {
		return internal.MarshalJSONWithExtraProperty(e.BarChart, "type", "barChart")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EventChartRequestVisitor interface {
	VisitPieChart(*EventPieChartRequest) error
	VisitDateHistogram(*EventDateHistogramRequest) error
	VisitBarChart(*EventBarChartRequest) error
}

func (e *EventChartRequest) Accept(visitor EventChartRequestVisitor) error {
	if e.PieChart != nil {
		return visitor.VisitPieChart(e.PieChart)
	}
	if e.DateHistogram != nil {
		return visitor.VisitDateHistogram(e.DateHistogram)
	}
	if e.BarChart != nil {
		return visitor.VisitBarChart(e.BarChart)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *EventChartRequest) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.PieChart != nil {
		fields = append(fields, "pieChart")
	}
	if e.DateHistogram != nil {
		fields = append(fields, "dateHistogram")
	}
	if e.BarChart != nil {
		fields = append(fields, "barChart")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

var (
	eventColumnDefinitionFieldHeader = big.NewInt(1 << 0)
	eventColumnDefinitionFieldMetric = big.NewInt(1 << 1)
)

type EventColumnDefinition struct {
	// Unique column header, serving as the key for corresponding metric values.
	Header string `json:"header" url:"header"`
	// The metric calculated for this column, stored in the row data under the specified header.
	Metric *EventMetric `json:"metric" url:"metric"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventColumnDefinition) GetHeader() string {
	if e == nil {
		return ""
	}
	return e.Header
}

func (e *EventColumnDefinition) GetMetric() *EventMetric {
	if e == nil {
		return nil
	}
	return e.Metric
}

func (e *EventColumnDefinition) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventColumnDefinition) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetHeader sets the Header field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventColumnDefinition) SetHeader(header string) {
	e.Header = header
	e.require(eventColumnDefinitionFieldHeader)
}

// SetMetric sets the Metric field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventColumnDefinition) SetMetric(metric *EventMetric) {
	e.Metric = metric
	e.require(eventColumnDefinitionFieldMetric)
}

func (e *EventColumnDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler EventColumnDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventColumnDefinition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventColumnDefinition) MarshalJSON() ([]byte, error) {
	type embed EventColumnDefinition
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventColumnDefinition) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Returns the total count of records in a group.
type EventCount struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventCount) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventCount) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

func (e *EventCount) UnmarshalJSON(data []byte) error {
	type unmarshaler EventCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventCount) MarshalJSON() ([]byte, error) {
	type embed EventCount
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventCount) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventDateHistogramRequestFieldEventFilter  = big.NewInt(1 << 0)
	eventDateHistogramRequestFieldTimezone     = big.NewInt(1 << 1)
	eventDateHistogramRequestFieldTimeInterval = big.NewInt(1 << 2)
	eventDateHistogramRequestFieldGroupBy      = big.NewInt(1 << 3)
	eventDateHistogramRequestFieldMetric       = big.NewInt(1 << 4)
)

type EventDateHistogramRequest struct {
	// Optional filter applied to refine the event data before processing.
	EventFilter *EventFilter `json:"eventFilter,omitempty" url:"eventFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// Time-based grouping interval (e.g., HOUR, DAY, WEEK) for the date histogram.
	TimeInterval TimeInterval `json:"timeInterval" url:"timeInterval"`
	// Groups data before applying calculations, forming a separate time series for each group.
	GroupBy *EventGroupBy `json:"groupBy,omitempty" url:"groupBy,omitempty"`
	// Defines the y-axis values for the date histogram.
	Metric *EventMetric `json:"metric" url:"metric"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventDateHistogramRequest) GetEventFilter() *EventFilter {
	if e == nil {
		return nil
	}
	return e.EventFilter
}

func (e *EventDateHistogramRequest) GetTimezone() *string {
	if e == nil {
		return nil
	}
	return e.Timezone
}

func (e *EventDateHistogramRequest) GetTimeInterval() TimeInterval {
	if e == nil {
		return ""
	}
	return e.TimeInterval
}

func (e *EventDateHistogramRequest) GetGroupBy() *EventGroupBy {
	if e == nil {
		return nil
	}
	return e.GroupBy
}

func (e *EventDateHistogramRequest) GetMetric() *EventMetric {
	if e == nil {
		return nil
	}
	return e.Metric
}

func (e *EventDateHistogramRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventDateHistogramRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEventFilter sets the EventFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventDateHistogramRequest) SetEventFilter(eventFilter *EventFilter) {
	e.EventFilter = eventFilter
	e.require(eventDateHistogramRequestFieldEventFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventDateHistogramRequest) SetTimezone(timezone *string) {
	e.Timezone = timezone
	e.require(eventDateHistogramRequestFieldTimezone)
}

// SetTimeInterval sets the TimeInterval field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventDateHistogramRequest) SetTimeInterval(timeInterval TimeInterval) {
	e.TimeInterval = timeInterval
	e.require(eventDateHistogramRequestFieldTimeInterval)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventDateHistogramRequest) SetGroupBy(groupBy *EventGroupBy) {
	e.GroupBy = groupBy
	e.require(eventDateHistogramRequestFieldGroupBy)
}

// SetMetric sets the Metric field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventDateHistogramRequest) SetMetric(metric *EventMetric) {
	e.Metric = metric
	e.require(eventDateHistogramRequestFieldMetric)
}

func (e *EventDateHistogramRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EventDateHistogramRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventDateHistogramRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventDateHistogramRequest) MarshalJSON() ([]byte, error) {
	type embed EventDateHistogramRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventDateHistogramRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Calculates the number of unique values in the specified field.
var (
	eventDistinctCountFieldTargetField = big.NewInt(1 << 0)
)

type EventDistinctCount struct {
	// All the distinct values of this field will be counted.
	TargetField EventField `json:"targetField" url:"targetField"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventDistinctCount) GetTargetField() EventField {
	if e == nil {
		return ""
	}
	return e.TargetField
}

func (e *EventDistinctCount) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventDistinctCount) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetTargetField sets the TargetField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventDistinctCount) SetTargetField(targetField EventField) {
	e.TargetField = targetField
	e.require(eventDistinctCountFieldTargetField)
}

func (e *EventDistinctCount) UnmarshalJSON(data []byte) error {
	type unmarshaler EventDistinctCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventDistinctCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventDistinctCount) MarshalJSON() ([]byte, error) {
	type embed EventDistinctCount
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventDistinctCount) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventGroupByFieldLimit = big.NewInt(1 << 0)
	eventGroupByFieldField = big.NewInt(1 << 1)
)

type EventGroupBy struct {
	// Limits the number of groups returned (defaults to 100 if omitted).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Field used for data grouping.
	Field EventField `json:"field" url:"field"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventGroupBy) GetLimit() *int {
	if e == nil {
		return nil
	}
	return e.Limit
}

func (e *EventGroupBy) GetField() EventField {
	if e == nil {
		return ""
	}
	return e.Field
}

func (e *EventGroupBy) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventGroupBy) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventGroupBy) SetLimit(limit *int) {
	e.Limit = limit
	e.require(eventGroupByFieldLimit)
}

// SetField sets the Field field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventGroupBy) SetField(field EventField) {
	e.Field = field
	e.require(eventGroupByFieldField)
}

func (e *EventGroupBy) UnmarshalJSON(data []byte) error {
	type unmarshaler EventGroupBy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventGroupBy(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventGroupBy) MarshalJSON() ([]byte, error) {
	type embed EventGroupBy
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventGroupBy) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Defines the metric to be calculated for a column or chart.
// Currently only count metric is supported for events.
type EventMetric struct {
	Type          string
	Count         *EventCount
	DistinctCount *EventDistinctCount
}

func (e *EventMetric) GetType() string {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EventMetric) GetCount() *EventCount {
	if e == nil {
		return nil
	}
	return e.Count
}

func (e *EventMetric) GetDistinctCount() *EventDistinctCount {
	if e == nil {
		return nil
	}
	return e.DistinctCount
}

func (e *EventMetric) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", e)
	}
	switch unmarshaler.Type {
	case "count":
		value := new(EventCount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.Count = value
	case "distinctCount":
		value := new(EventDistinctCount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.DistinctCount = value
	}
	return nil
}

func (e EventMetric) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.Count != nil {
		return internal.MarshalJSONWithExtraProperty(e.Count, "type", "count")
	}
	if e.DistinctCount != nil {
		return internal.MarshalJSONWithExtraProperty(e.DistinctCount, "type", "distinctCount")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EventMetricVisitor interface {
	VisitCount(*EventCount) error
	VisitDistinctCount(*EventDistinctCount) error
}

func (e *EventMetric) Accept(visitor EventMetricVisitor) error {
	if e.Count != nil {
		return visitor.VisitCount(e.Count)
	}
	if e.DistinctCount != nil {
		return visitor.VisitDistinctCount(e.DistinctCount)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *EventMetric) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.Count != nil {
		fields = append(fields, "count")
	}
	if e.DistinctCount != nil {
		fields = append(fields, "distinctCount")
	}
	if len(fields) == 0 {
		if e.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.Type)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.Type != "" {
		field := fields[0]
		if e.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.Type,
				e,
			)
		}
	}
	return nil
}

var (
	eventPieChartRequestFieldEventFilter = big.NewInt(1 << 0)
	eventPieChartRequestFieldTimezone    = big.NewInt(1 << 1)
	eventPieChartRequestFieldGroupBy     = big.NewInt(1 << 2)
	eventPieChartRequestFieldMetric      = big.NewInt(1 << 3)
)

type EventPieChartRequest struct {
	// Optional filter applied to refine the event data before processing.
	EventFilter *EventFilter `json:"eventFilter,omitempty" url:"eventFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// Field used to group data into slices for the pie chart.
	GroupBy *EventGroupBy `json:"groupBy" url:"groupBy"`
	// Metric defining the value for each pie slice, stored in the y-axis value.
	Metric *EventMetric `json:"metric" url:"metric"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventPieChartRequest) GetEventFilter() *EventFilter {
	if e == nil {
		return nil
	}
	return e.EventFilter
}

func (e *EventPieChartRequest) GetTimezone() *string {
	if e == nil {
		return nil
	}
	return e.Timezone
}

func (e *EventPieChartRequest) GetGroupBy() *EventGroupBy {
	if e == nil {
		return nil
	}
	return e.GroupBy
}

func (e *EventPieChartRequest) GetMetric() *EventMetric {
	if e == nil {
		return nil
	}
	return e.Metric
}

func (e *EventPieChartRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventPieChartRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEventFilter sets the EventFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventPieChartRequest) SetEventFilter(eventFilter *EventFilter) {
	e.EventFilter = eventFilter
	e.require(eventPieChartRequestFieldEventFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventPieChartRequest) SetTimezone(timezone *string) {
	e.Timezone = timezone
	e.require(eventPieChartRequestFieldTimezone)
}

// SetGroupBy sets the GroupBy field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventPieChartRequest) SetGroupBy(groupBy *EventGroupBy) {
	e.GroupBy = groupBy
	e.require(eventPieChartRequestFieldGroupBy)
}

// SetMetric sets the Metric field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventPieChartRequest) SetMetric(metric *EventMetric) {
	e.Metric = metric
	e.require(eventPieChartRequestFieldMetric)
}

func (e *EventPieChartRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EventPieChartRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventPieChartRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventPieChartRequest) MarshalJSON() ([]byte, error) {
	type embed EventPieChartRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventPieChartRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventRowFieldData       = big.NewInt(1 << 0)
	eventRowFieldIdentifier = big.NewInt(1 << 1)
)

type EventRow struct {
	// The actual row data, where keys represent column headers and values contain the respective metric results.
	Data map[string]*CellData `json:"data" url:"data"`
	// A unique identifier for each row, consisting of field names mapped to their respective values.
	// This includes time groupings and any specified field groupings.
	Identifier map[EventField]*FieldValue `json:"identifier" url:"identifier"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventRow) GetData() map[string]*CellData {
	if e == nil {
		return nil
	}
	return e.Data
}

func (e *EventRow) GetIdentifier() map[EventField]*FieldValue {
	if e == nil {
		return nil
	}
	return e.Identifier
}

func (e *EventRow) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventRow) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventRow) SetData(data map[string]*CellData) {
	e.Data = data
	e.require(eventRowFieldData)
}

// SetIdentifier sets the Identifier field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventRow) SetIdentifier(identifier map[EventField]*FieldValue) {
	e.Identifier = identifier
	e.require(eventRowFieldIdentifier)
}

func (e *EventRow) UnmarshalJSON(data []byte) error {
	type unmarshaler EventRow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventRow(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventRow) MarshalJSON() ([]byte, error) {
	type embed EventRow
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventRow) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventTableRequestFieldEventFilter       = big.NewInt(1 << 0)
	eventTableRequestFieldTimezone          = big.NewInt(1 << 1)
	eventTableRequestFieldTimeGrouping      = big.NewInt(1 << 2)
	eventTableRequestFieldFieldGroupings    = big.NewInt(1 << 3)
	eventTableRequestFieldColumnDefinitions = big.NewInt(1 << 4)
)

type EventTableRequest struct {
	// Optional filter applied to refine the event data before processing.
	EventFilter *EventFilter `json:"eventFilter,omitempty" url:"eventFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// Defines the time interval for grouping data. If specified, data is grouped accordingly based on the time they were created.
	//
	//	Example: If set to "DAY," data will be aggregated by day.
	TimeGrouping *TimeInterval `json:"timeGrouping,omitempty" url:"timeGrouping,omitempty"`
	// Specifies the fields by which data should be grouped. Each unique combination forms a row.
	// If multiple fields are provided, the result is grouped by their unique value combinations.
	// If empty, all data is aggregated into a single row.
	// Note: The field CreatedAt should not be used here, all the time-based grouping should be done using the timeGrouping field.
	FieldGroupings []*EventGroupBy `json:"fieldGroupings" url:"fieldGroupings"`
	// Specifies the metrics to be displayed as columns.
	// Column headers act as keys, with computed metric values as their mapped values.
	// There needs to be at least one column definition in the table request.
	ColumnDefinitions []*EventColumnDefinition `json:"columnDefinitions" url:"columnDefinitions"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventTableRequest) GetEventFilter() *EventFilter {
	if e == nil {
		return nil
	}
	return e.EventFilter
}

func (e *EventTableRequest) GetTimezone() *string {
	if e == nil {
		return nil
	}
	return e.Timezone
}

func (e *EventTableRequest) GetTimeGrouping() *TimeInterval {
	if e == nil {
		return nil
	}
	return e.TimeGrouping
}

func (e *EventTableRequest) GetFieldGroupings() []*EventGroupBy {
	if e == nil {
		return nil
	}
	return e.FieldGroupings
}

func (e *EventTableRequest) GetColumnDefinitions() []*EventColumnDefinition {
	if e == nil {
		return nil
	}
	return e.ColumnDefinitions
}

func (e *EventTableRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventTableRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetEventFilter sets the EventFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventTableRequest) SetEventFilter(eventFilter *EventFilter) {
	e.EventFilter = eventFilter
	e.require(eventTableRequestFieldEventFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventTableRequest) SetTimezone(timezone *string) {
	e.Timezone = timezone
	e.require(eventTableRequestFieldTimezone)
}

// SetTimeGrouping sets the TimeGrouping field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventTableRequest) SetTimeGrouping(timeGrouping *TimeInterval) {
	e.TimeGrouping = timeGrouping
	e.require(eventTableRequestFieldTimeGrouping)
}

// SetFieldGroupings sets the FieldGroupings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventTableRequest) SetFieldGroupings(fieldGroupings []*EventGroupBy) {
	e.FieldGroupings = fieldGroupings
	e.require(eventTableRequestFieldFieldGroupings)
}

// SetColumnDefinitions sets the ColumnDefinitions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventTableRequest) SetColumnDefinitions(columnDefinitions []*EventColumnDefinition) {
	e.ColumnDefinitions = columnDefinitions
	e.require(eventTableRequestFieldColumnDefinitions)
}

func (e *EventTableRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EventTableRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventTableRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventTableRequest) MarshalJSON() ([]byte, error) {
	type embed EventTableRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventTableRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventTableResponseFieldHeaders = big.NewInt(1 << 0)
	eventTableResponseFieldRows    = big.NewInt(1 << 1)
)

type EventTableResponse struct {
	// Column headers in the table, aligning with the column definitions specified in the request.
	Headers []string `json:"headers" url:"headers"`
	// The dataset rows, where each row represents a unique combination of grouping field values.
	// The identifier map contains grouping field names mapped to their respective values.
	// The data map contains column headers mapped to their respective metric values.
	Rows []*EventRow `json:"rows" url:"rows"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventTableResponse) GetHeaders() []string {
	if e == nil {
		return nil
	}
	return e.Headers
}

func (e *EventTableResponse) GetRows() []*EventRow {
	if e == nil {
		return nil
	}
	return e.Rows
}

func (e *EventTableResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventTableResponse) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventTableResponse) SetHeaders(headers []string) {
	e.Headers = headers
	e.require(eventTableResponseFieldHeaders)
}

// SetRows sets the Rows field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventTableResponse) SetRows(rows []*EventRow) {
	e.Rows = rows
	e.require(eventTableResponseFieldRows)
}

func (e *EventTableResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EventTableResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventTableResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventTableResponse) MarshalJSON() ([]byte, error) {
	type embed EventTableResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventTableResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	feedbackAnalyticsRequestFieldFeedbackFilter = big.NewInt(1 << 0)
	feedbackAnalyticsRequestFieldTimezone       = big.NewInt(1 << 1)
)

type FeedbackAnalyticsRequest struct {
	// Optional filter applied to refine the feedback data before processing.
	FeedbackFilter *FeedbackFilter `json:"feedbackFilter,omitempty" url:"feedbackFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackAnalyticsRequest) GetFeedbackFilter() *FeedbackFilter {
	if f == nil {
		return nil
	}
	return f.FeedbackFilter
}

func (f *FeedbackAnalyticsRequest) GetTimezone() *string {
	if f == nil {
		return nil
	}
	return f.Timezone
}

func (f *FeedbackAnalyticsRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackAnalyticsRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFeedbackFilter sets the FeedbackFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackAnalyticsRequest) SetFeedbackFilter(feedbackFilter *FeedbackFilter) {
	f.FeedbackFilter = feedbackFilter
	f.require(feedbackAnalyticsRequestFieldFeedbackFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackAnalyticsRequest) SetTimezone(timezone *string) {
	f.Timezone = timezone
	f.require(feedbackAnalyticsRequestFieldTimezone)
}

func (f *FeedbackAnalyticsRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackAnalyticsRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackAnalyticsRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackAnalyticsRequest) MarshalJSON() ([]byte, error) {
	type embed FeedbackAnalyticsRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackAnalyticsRequest) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	feedbackColumnDefinitionFieldHeader = big.NewInt(1 << 0)
	feedbackColumnDefinitionFieldMetric = big.NewInt(1 << 1)
)

type FeedbackColumnDefinition struct {
	// Unique column header, serving as the key for corresponding metric values.
	Header string `json:"header" url:"header"`
	// The metric calculated for this column, stored in the row data under the specified header.
	Metric *FeedbackMetric `json:"metric" url:"metric"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackColumnDefinition) GetHeader() string {
	if f == nil {
		return ""
	}
	return f.Header
}

func (f *FeedbackColumnDefinition) GetMetric() *FeedbackMetric {
	if f == nil {
		return nil
	}
	return f.Metric
}

func (f *FeedbackColumnDefinition) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackColumnDefinition) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetHeader sets the Header field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackColumnDefinition) SetHeader(header string) {
	f.Header = header
	f.require(feedbackColumnDefinitionFieldHeader)
}

// SetMetric sets the Metric field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackColumnDefinition) SetMetric(metric *FeedbackMetric) {
	f.Metric = metric
	f.require(feedbackColumnDefinitionFieldMetric)
}

func (f *FeedbackColumnDefinition) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackColumnDefinition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackColumnDefinition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackColumnDefinition) MarshalJSON() ([]byte, error) {
	type embed FeedbackColumnDefinition
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackColumnDefinition) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Returns the total count of records in a group.
type FeedbackCount struct {

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackCount) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackCount) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

func (f *FeedbackCount) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackCount) MarshalJSON() ([]byte, error) {
	type embed FeedbackCount
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackCount) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Calculates the number of unique values in the specified field.
// Supports fields with list values as well.
var (
	feedbackDistinctCountFieldTargetField = big.NewInt(1 << 0)
)

type FeedbackDistinctCount struct {
	// All the distinct values of this field will be counted.
	TargetField FeedbackField `json:"targetField" url:"targetField"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackDistinctCount) GetTargetField() FeedbackField {
	if f == nil {
		return ""
	}
	return f.TargetField
}

func (f *FeedbackDistinctCount) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackDistinctCount) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetTargetField sets the TargetField field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackDistinctCount) SetTargetField(targetField FeedbackField) {
	f.TargetField = targetField
	f.require(feedbackDistinctCountFieldTargetField)
}

func (f *FeedbackDistinctCount) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackDistinctCount
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackDistinctCount(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackDistinctCount) MarshalJSON() ([]byte, error) {
	type embed FeedbackDistinctCount
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackDistinctCount) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	feedbackGroupByFieldLimit = big.NewInt(1 << 0)
	feedbackGroupByFieldField = big.NewInt(1 << 1)
)

type FeedbackGroupBy struct {
	// Limits the number of groups returned (defaults to 100 if omitted).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`
	// Field used for data grouping.
	Field FeedbackField `json:"field" url:"field"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackGroupBy) GetLimit() *int {
	if f == nil {
		return nil
	}
	return f.Limit
}

func (f *FeedbackGroupBy) GetField() FeedbackField {
	if f == nil {
		return ""
	}
	return f.Field
}

func (f *FeedbackGroupBy) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackGroupBy) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackGroupBy) SetLimit(limit *int) {
	f.Limit = limit
	f.require(feedbackGroupByFieldLimit)
}

// SetField sets the Field field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackGroupBy) SetField(field FeedbackField) {
	f.Field = field
	f.require(feedbackGroupByFieldField)
}

func (f *FeedbackGroupBy) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackGroupBy
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackGroupBy(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackGroupBy) MarshalJSON() ([]byte, error) {
	type embed FeedbackGroupBy
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackGroupBy) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// Defines the metric to be calculated for a column or chart.
type FeedbackMetric struct {
	Type          string
	Count         *FeedbackCount
	DistinctCount *FeedbackDistinctCount
}

func (f *FeedbackMetric) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FeedbackMetric) GetCount() *FeedbackCount {
	if f == nil {
		return nil
	}
	return f.Count
}

func (f *FeedbackMetric) GetDistinctCount() *FeedbackDistinctCount {
	if f == nil {
		return nil
	}
	return f.DistinctCount
}

func (f *FeedbackMetric) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "count":
		value := new(FeedbackCount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.Count = value
	case "distinctCount":
		value := new(FeedbackDistinctCount)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.DistinctCount = value
	}
	return nil
}

func (f FeedbackMetric) MarshalJSON() ([]byte, error) {
	if err := f.validate(); err != nil {
		return nil, err
	}
	if f.Count != nil {
		return internal.MarshalJSONWithExtraProperty(f.Count, "type", "count")
	}
	if f.DistinctCount != nil {
		return internal.MarshalJSONWithExtraProperty(f.DistinctCount, "type", "distinctCount")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", f)
}

type FeedbackMetricVisitor interface {
	VisitCount(*FeedbackCount) error
	VisitDistinctCount(*FeedbackDistinctCount) error
}

func (f *FeedbackMetric) Accept(visitor FeedbackMetricVisitor) error {
	if f.Count != nil {
		return visitor.VisitCount(f.Count)
	}
	if f.DistinctCount != nil {
		return visitor.VisitDistinctCount(f.DistinctCount)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", f)
}

func (f *FeedbackMetric) validate() error {
	if f == nil {
		return fmt.Errorf("type %T is nil", f)
	}
	var fields []string
	if f.Count != nil {
		fields = append(fields, "count")
	}
	if f.DistinctCount != nil {
		fields = append(fields, "distinctCount")
	}
	if len(fields) == 0 {
		if f.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", f, f.Type)
		}
		return fmt.Errorf("type %T is empty", f)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", f, fields)
	}
	if f.Type != "" {
		field := fields[0]
		if f.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				f,
				f.Type,
				f,
			)
		}
	}
	return nil
}

var (
	feedbackRowFieldData       = big.NewInt(1 << 0)
	feedbackRowFieldIdentifier = big.NewInt(1 << 1)
)

type FeedbackRow struct {
	// The actual row data, where keys represent column headers and values contain the respective metric results.
	Data map[string]*CellData `json:"data" url:"data"`
	// A unique identifier for each row, consisting of field names mapped to their respective values.
	// This includes time groupings and any specified field groupings.
	Identifier map[FeedbackField]*FieldValue `json:"identifier" url:"identifier"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackRow) GetData() map[string]*CellData {
	if f == nil {
		return nil
	}
	return f.Data
}

func (f *FeedbackRow) GetIdentifier() map[FeedbackField]*FieldValue {
	if f == nil {
		return nil
	}
	return f.Identifier
}

func (f *FeedbackRow) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackRow) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackRow) SetData(data map[string]*CellData) {
	f.Data = data
	f.require(feedbackRowFieldData)
}

// SetIdentifier sets the Identifier field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackRow) SetIdentifier(identifier map[FeedbackField]*FieldValue) {
	f.Identifier = identifier
	f.require(feedbackRowFieldIdentifier)
}

func (f *FeedbackRow) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackRow
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackRow(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackRow) MarshalJSON() ([]byte, error) {
	type embed FeedbackRow
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackRow) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	feedbackTableRequestFieldFeedbackFilter    = big.NewInt(1 << 0)
	feedbackTableRequestFieldTimezone          = big.NewInt(1 << 1)
	feedbackTableRequestFieldTimeGrouping      = big.NewInt(1 << 2)
	feedbackTableRequestFieldFieldGroupings    = big.NewInt(1 << 3)
	feedbackTableRequestFieldColumnDefinitions = big.NewInt(1 << 4)
)

type FeedbackTableRequest struct {
	// Optional filter applied to refine the feedback data before processing.
	FeedbackFilter *FeedbackFilter `json:"feedbackFilter,omitempty" url:"feedbackFilter,omitempty"`
	// IANA timezone identifier (e.g., "America/Los_Angeles").
	// When provided, time-based groupings (e.g., DAY) and date filters are evaluated in this timezone;
	// otherwise UTC is used.
	Timezone *string `json:"timezone,omitempty" url:"timezone,omitempty"`
	// Defines the time interval for grouping data. If specified, data is grouped accordingly based on the time they were created.
	//
	//	Example: If set to "DAY," data will be aggregated by day.
	TimeGrouping *TimeInterval `json:"timeGrouping,omitempty" url:"timeGrouping,omitempty"`
	// Specifies the fields by which data should be grouped. Each unique combination forms a row.
	// If multiple fields are provided, the result is grouped by their unique value combinations.
	// If empty, all data is aggregated into a single row.
	// Note: The field CreatedAt should not be used here, all the time-based grouping should be done using the timeGrouping field.
	FieldGroupings []*FeedbackGroupBy `json:"fieldGroupings" url:"fieldGroupings"`
	// Specifies the metrics to be displayed as columns.
	// Column headers act as keys, with computed metric values as their mapped values.
	// There needs to be at least one column definition in the table request.
	ColumnDefinitions []*FeedbackColumnDefinition `json:"columnDefinitions" url:"columnDefinitions"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackTableRequest) GetFeedbackFilter() *FeedbackFilter {
	if f == nil {
		return nil
	}
	return f.FeedbackFilter
}

func (f *FeedbackTableRequest) GetTimezone() *string {
	if f == nil {
		return nil
	}
	return f.Timezone
}

func (f *FeedbackTableRequest) GetTimeGrouping() *TimeInterval {
	if f == nil {
		return nil
	}
	return f.TimeGrouping
}

func (f *FeedbackTableRequest) GetFieldGroupings() []*FeedbackGroupBy {
	if f == nil {
		return nil
	}
	return f.FieldGroupings
}

func (f *FeedbackTableRequest) GetColumnDefinitions() []*FeedbackColumnDefinition {
	if f == nil {
		return nil
	}
	return f.ColumnDefinitions
}

func (f *FeedbackTableRequest) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackTableRequest) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetFeedbackFilter sets the FeedbackFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackTableRequest) SetFeedbackFilter(feedbackFilter *FeedbackFilter) {
	f.FeedbackFilter = feedbackFilter
	f.require(feedbackTableRequestFieldFeedbackFilter)
}

// SetTimezone sets the Timezone field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackTableRequest) SetTimezone(timezone *string) {
	f.Timezone = timezone
	f.require(feedbackTableRequestFieldTimezone)
}

// SetTimeGrouping sets the TimeGrouping field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackTableRequest) SetTimeGrouping(timeGrouping *TimeInterval) {
	f.TimeGrouping = timeGrouping
	f.require(feedbackTableRequestFieldTimeGrouping)
}

// SetFieldGroupings sets the FieldGroupings field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackTableRequest) SetFieldGroupings(fieldGroupings []*FeedbackGroupBy) {
	f.FieldGroupings = fieldGroupings
	f.require(feedbackTableRequestFieldFieldGroupings)
}

// SetColumnDefinitions sets the ColumnDefinitions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackTableRequest) SetColumnDefinitions(columnDefinitions []*FeedbackColumnDefinition) {
	f.ColumnDefinitions = columnDefinitions
	f.require(feedbackTableRequestFieldColumnDefinitions)
}

func (f *FeedbackTableRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackTableRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackTableRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackTableRequest) MarshalJSON() ([]byte, error) {
	type embed FeedbackTableRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackTableRequest) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	feedbackTableResponseFieldHeaders = big.NewInt(1 << 0)
	feedbackTableResponseFieldRows    = big.NewInt(1 << 1)
)

type FeedbackTableResponse struct {
	// Column headers in the table, aligning with the column definitions specified in the request.
	Headers []string `json:"headers" url:"headers"`
	// The dataset rows, where each row represents a unique combination of grouping field values.
	// The identifier map contains grouping field names mapped to their respective values.
	// The data map contains column headers mapped to their respective metric values.
	Rows []*FeedbackRow `json:"rows" url:"rows"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackTableResponse) GetHeaders() []string {
	if f == nil {
		return nil
	}
	return f.Headers
}

func (f *FeedbackTableResponse) GetRows() []*FeedbackRow {
	if f == nil {
		return nil
	}
	return f.Rows
}

func (f *FeedbackTableResponse) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackTableResponse) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackTableResponse) SetHeaders(headers []string) {
	f.Headers = headers
	f.require(feedbackTableResponseFieldHeaders)
}

// SetRows sets the Rows field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackTableResponse) SetRows(rows []*FeedbackRow) {
	f.Rows = rows
	f.require(feedbackTableResponseFieldRows)
}

func (f *FeedbackTableResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackTableResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackTableResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackTableResponse) MarshalJSON() ([]byte, error) {
	type embed FeedbackTableResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackTableResponse) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FieldValue struct {
	Type     string
	DateTime time.Time
	String   string
	Double   float64
	Long     int64
	Range    *Range
	Boolean  bool
	EntityID *EntityResult
}

func (f *FieldValue) GetType() string {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FieldValue) GetDateTime() time.Time {
	if f == nil {
		return time.Time{}
	}
	return f.DateTime
}

func (f *FieldValue) GetString() string {
	if f == nil {
		return ""
	}
	return f.String
}

func (f *FieldValue) GetDouble() float64 {
	if f == nil {
		return 0
	}
	return f.Double
}

func (f *FieldValue) GetLong() int64 {
	if f == nil {
		return 0
	}
	return f.Long
}

func (f *FieldValue) GetRange() *Range {
	if f == nil {
		return nil
	}
	return f.Range
}

func (f *FieldValue) GetBoolean() bool {
	if f == nil {
		return false
	}
	return f.Boolean
}

func (f *FieldValue) GetEntityID() *EntityResult {
	if f == nil {
		return nil
	}
	return f.EntityID
}

func (f *FieldValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	f.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", f)
	}
	switch unmarshaler.Type {
	case "dateTime":
		var valueUnmarshaler struct {
			DateTime *internal.DateTime `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.DateTime = valueUnmarshaler.DateTime.Time()
	case "string":
		var valueUnmarshaler struct {
			String string `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.String = valueUnmarshaler.String
	case "double":
		var valueUnmarshaler struct {
			Double float64 `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.Double = valueUnmarshaler.Double
	case "long":
		var valueUnmarshaler struct {
			Long int64 `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.Long = valueUnmarshaler.Long
	case "range":
		value := new(Range)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.Range = value
	case "boolean":
		var valueUnmarshaler struct {
			Boolean bool `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		f.Boolean = valueUnmarshaler.Boolean
	case "entityId":
		value := new(EntityResult)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		f.EntityID = value
	}
	return nil
}

func (f FieldValue) MarshalJSON() ([]byte, error) {
	if err := f.validate(); err != nil {
		return nil, err
	}
	if !f.DateTime.IsZero() {
		var marshaler = struct {
			Type     string             `json:"type"`
			DateTime *internal.DateTime `json:"value"`
		}{
			Type:     "dateTime",
			DateTime: internal.NewDateTime(f.DateTime),
		}
		return json.Marshal(marshaler)
	}
	if f.String != "" {
		var marshaler = struct {
			Type   string `json:"type"`
			String string `json:"value"`
		}{
			Type:   "string",
			String: f.String,
		}
		return json.Marshal(marshaler)
	}
	if f.Double != 0 {
		var marshaler = struct {
			Type   string  `json:"type"`
			Double float64 `json:"value"`
		}{
			Type:   "double",
			Double: f.Double,
		}
		return json.Marshal(marshaler)
	}
	if f.Long != 0 {
		var marshaler = struct {
			Type string `json:"type"`
			Long int64  `json:"value"`
		}{
			Type: "long",
			Long: f.Long,
		}
		return json.Marshal(marshaler)
	}
	if f.Range != nil {
		return internal.MarshalJSONWithExtraProperty(f.Range, "type", "range")
	}
	if f.Boolean != false {
		var marshaler = struct {
			Type    string `json:"type"`
			Boolean bool   `json:"value"`
		}{
			Type:    "boolean",
			Boolean: f.Boolean,
		}
		return json.Marshal(marshaler)
	}
	if f.EntityID != nil {
		return internal.MarshalJSONWithExtraProperty(f.EntityID, "type", "entityId")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", f)
}

type FieldValueVisitor interface {
	VisitDateTime(time.Time) error
	VisitString(string) error
	VisitDouble(float64) error
	VisitLong(int64) error
	VisitRange(*Range) error
	VisitBoolean(bool) error
	VisitEntityID(*EntityResult) error
}

func (f *FieldValue) Accept(visitor FieldValueVisitor) error {
	if !f.DateTime.IsZero() {
		return visitor.VisitDateTime(f.DateTime)
	}
	if f.String != "" {
		return visitor.VisitString(f.String)
	}
	if f.Double != 0 {
		return visitor.VisitDouble(f.Double)
	}
	if f.Long != 0 {
		return visitor.VisitLong(f.Long)
	}
	if f.Range != nil {
		return visitor.VisitRange(f.Range)
	}
	if f.Boolean != false {
		return visitor.VisitBoolean(f.Boolean)
	}
	if f.EntityID != nil {
		return visitor.VisitEntityID(f.EntityID)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", f)
}

func (f *FieldValue) validate() error {
	if f == nil {
		return fmt.Errorf("type %T is nil", f)
	}
	var fields []string
	if !f.DateTime.IsZero() {
		fields = append(fields, "dateTime")
	}
	if f.String != "" {
		fields = append(fields, "string")
	}
	if f.Double != 0 {
		fields = append(fields, "double")
	}
	if f.Long != 0 {
		fields = append(fields, "long")
	}
	if f.Range != nil {
		fields = append(fields, "range")
	}
	if f.Boolean != false {
		fields = append(fields, "boolean")
	}
	if f.EntityID != nil {
		fields = append(fields, "entityId")
	}
	if len(fields) == 0 {
		if f.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", f, f.Type)
		}
		return fmt.Errorf("type %T is empty", f)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", f, fields)
	}
	if f.Type != "" {
		field := fields[0]
		if f.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				f,
				f.Type,
				f,
			)
		}
	}
	return nil
}

var (
	groupByBaseFieldLimit = big.NewInt(1 << 0)
)

type GroupByBase struct {
	// Limits the number of groups returned (defaults to 100 if omitted).
	Limit *int `json:"limit,omitempty" url:"limit,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GroupByBase) GetLimit() *int {
	if g == nil {
		return nil
	}
	return g.Limit
}

func (g *GroupByBase) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GroupByBase) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetLimit sets the Limit field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GroupByBase) SetLimit(limit *int) {
	g.Limit = limit
	g.require(groupByBaseFieldLimit)
}

func (g *GroupByBase) UnmarshalJSON(data []byte) error {
	type unmarshaler GroupByBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GroupByBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GroupByBase) MarshalJSON() ([]byte, error) {
	type embed GroupByBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GroupByBase) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	labeledPointFieldLabel = big.NewInt(1 << 0)
	labeledPointFieldY     = big.NewInt(1 << 1)
)

type LabeledPoint struct {
	// Label for the data point corresponding to the y-value.
	Label string `json:"label" url:"label"`
	// Value of the data point.
	Y float64 `json:"y" url:"y"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LabeledPoint) GetLabel() string {
	if l == nil {
		return ""
	}
	return l.Label
}

func (l *LabeledPoint) GetY() float64 {
	if l == nil {
		return 0
	}
	return l.Y
}

func (l *LabeledPoint) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LabeledPoint) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabeledPoint) SetLabel(label string) {
	l.Label = label
	l.require(labeledPointFieldLabel)
}

// SetY sets the Y field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LabeledPoint) SetY(y float64) {
	l.Y = y
	l.require(labeledPointFieldY)
}

func (l *LabeledPoint) UnmarshalJSON(data []byte) error {
	type unmarshaler LabeledPoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabeledPoint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabeledPoint) MarshalJSON() ([]byte, error) {
	type embed LabeledPoint
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LabeledPoint) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

var (
	pieChartResponseFieldSeries = big.NewInt(1 << 0)
)

type PieChartResponse struct {
	// The dataset for the pie chart.
	// Each slice in the pie chart is represented as a data point with a name and a corresponding y-value.
	Series *Series `json:"series" url:"series"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PieChartResponse) GetSeries() *Series {
	if p == nil {
		return nil
	}
	return p.Series
}

func (p *PieChartResponse) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PieChartResponse) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetSeries sets the Series field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PieChartResponse) SetSeries(series *Series) {
	p.Series = series
	p.require(pieChartResponseFieldSeries)
}

func (p *PieChartResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler PieChartResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PieChartResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PieChartResponse) MarshalJSON() ([]byte, error) {
	type embed PieChartResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PieChartResponse) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	rangeFieldFrom = big.NewInt(1 << 0)
	rangeFieldTo   = big.NewInt(1 << 1)
)

type Range struct {
	// Lower bound of the range (inclusive).
	From *float64 `json:"from,omitempty" url:"from,omitempty"`
	// Upper bound of the range (exclusive).
	To *float64 `json:"to,omitempty" url:"to,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *Range) GetFrom() *float64 {
	if r == nil {
		return nil
	}
	return r.From
}

func (r *Range) GetTo() *float64 {
	if r == nil {
		return nil
	}
	return r.To
}

func (r *Range) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Range) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetFrom sets the From field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Range) SetFrom(from *float64) {
	r.From = from
	r.require(rangeFieldFrom)
}

// SetTo sets the To field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *Range) SetTo(to *float64) {
	r.To = to
	r.require(rangeFieldTo)
}

func (r *Range) UnmarshalJSON(data []byte) error {
	type unmarshaler Range
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Range(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *Range) MarshalJSON() ([]byte, error) {
	type embed Range
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *Range) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	rowBaseFieldData = big.NewInt(1 << 0)
)

type RowBase struct {
	// The actual row data, where keys represent column headers and values contain the respective metric results.
	Data map[string]*CellData `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *RowBase) GetData() map[string]*CellData {
	if r == nil {
		return nil
	}
	return r.Data
}

func (r *RowBase) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RowBase) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *RowBase) SetData(data map[string]*CellData) {
	r.Data = data
	r.require(rowBaseFieldData)
}

func (r *RowBase) UnmarshalJSON(data []byte) error {
	type unmarshaler RowBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RowBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *RowBase) MarshalJSON() ([]byte, error) {
	type embed RowBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *RowBase) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	seriesFieldName = big.NewInt(1 << 0)
	seriesFieldData = big.NewInt(1 << 1)
)

type Series struct {
	// The name of the series, derived from the grouping field.
	// If the metric is a percentile, the name represents the percentile value.
	Name string `json:"name" url:"name"`
	// List of labeled data points for the series.
	Data []*LabeledPoint `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Series) GetName() string {
	if s == nil {
		return ""
	}
	return s.Name
}

func (s *Series) GetData() []*LabeledPoint {
	if s == nil {
		return nil
	}
	return s.Data
}

func (s *Series) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Series) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Series) SetName(name string) {
	s.Name = name
	s.require(seriesFieldName)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Series) SetData(data []*LabeledPoint) {
	s.Data = data
	s.require(seriesFieldData)
}

func (s *Series) UnmarshalJSON(data []byte) error {
	type unmarshaler Series
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Series(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Series) MarshalJSON() ([]byte, error) {
	type embed Series
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *Series) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	tableResponseBaseFieldHeaders = big.NewInt(1 << 0)
)

type TableResponseBase struct {
	// Column headers in the table, aligning with the column definitions specified in the request.
	Headers []string `json:"headers" url:"headers"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TableResponseBase) GetHeaders() []string {
	if t == nil {
		return nil
	}
	return t.Headers
}

func (t *TableResponseBase) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TableResponseBase) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetHeaders sets the Headers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TableResponseBase) SetHeaders(headers []string) {
	t.Headers = headers
	t.require(tableResponseBaseFieldHeaders)
}

func (t *TableResponseBase) UnmarshalJSON(data []byte) error {
	type unmarshaler TableResponseBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TableResponseBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TableResponseBase) MarshalJSON() ([]byte, error) {
	type embed TableResponseBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TableResponseBase) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	timeDataPointFieldX = big.NewInt(1 << 0)
	timeDataPointFieldY = big.NewInt(1 << 1)
)

type TimeDataPoint struct {
	// X-axis value representing time in epoch milliseconds.
	X int64 `json:"x" url:"x"`
	// Y-axis value representing the measured data.
	Y float64 `json:"y" url:"y"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimeDataPoint) GetX() int64 {
	if t == nil {
		return 0
	}
	return t.X
}

func (t *TimeDataPoint) GetY() float64 {
	if t == nil {
		return 0
	}
	return t.Y
}

func (t *TimeDataPoint) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeDataPoint) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetX sets the X field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TimeDataPoint) SetX(x int64) {
	t.X = x
	t.require(timeDataPointFieldX)
}

// SetY sets the Y field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TimeDataPoint) SetY(y float64) {
	t.Y = y
	t.require(timeDataPointFieldY)
}

func (t *TimeDataPoint) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeDataPoint
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeDataPoint(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeDataPoint) MarshalJSON() ([]byte, error) {
	type embed TimeDataPoint
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TimeDataPoint) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TimeInterval string

const (
	TimeIntervalHour  TimeInterval = "HOUR"
	TimeIntervalDay   TimeInterval = "DAY"
	TimeIntervalWeek  TimeInterval = "WEEK"
	TimeIntervalMonth TimeInterval = "MONTH"
	TimeIntervalYear  TimeInterval = "YEAR"
)

func NewTimeIntervalFromString(s string) (TimeInterval, error) {
	switch s {
	case "HOUR":
		return TimeIntervalHour, nil
	case "DAY":
		return TimeIntervalDay, nil
	case "WEEK":
		return TimeIntervalWeek, nil
	case "MONTH":
		return TimeIntervalMonth, nil
	case "YEAR":
		return TimeIntervalYear, nil
	}
	var t TimeInterval
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TimeInterval) Ptr() *TimeInterval {
	return &t
}

var (
	timeSeriesFieldName = big.NewInt(1 << 0)
	timeSeriesFieldData = big.NewInt(1 << 1)
)

type TimeSeries struct {
	// Name of the series, derived from the grouping field or percentile metric.
	Name string `json:"name" url:"name"`
	// List of time-based data points for the series.
	Data []*TimeDataPoint `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TimeSeries) GetName() string {
	if t == nil {
		return ""
	}
	return t.Name
}

func (t *TimeSeries) GetData() []*TimeDataPoint {
	if t == nil {
		return nil
	}
	return t.Data
}

func (t *TimeSeries) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TimeSeries) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TimeSeries) SetName(name string) {
	t.Name = name
	t.require(timeSeriesFieldName)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TimeSeries) SetData(data []*TimeDataPoint) {
	t.Data = data
	t.require(timeSeriesFieldData)
}

func (t *TimeSeries) UnmarshalJSON(data []byte) error {
	type unmarshaler TimeSeries
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TimeSeries(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TimeSeries) MarshalJSON() ([]byte, error) {
	type embed TimeSeries
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TimeSeries) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}
