// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mavenagi/mavenagi-go/internal"
	big "math/big"
	time "time"
)

var (
	actionBaseFieldUserInteractionRequired = big.NewInt(1 << 0)
	actionBaseFieldButtonName              = big.NewInt(1 << 1)
	actionBaseFieldPrecondition            = big.NewInt(1 << 2)
	actionBaseFieldUserFormParameters      = big.NewInt(1 << 3)
	actionBaseFieldLanguage                = big.NewInt(1 << 4)
	actionBaseFieldName                    = big.NewInt(1 << 5)
	actionBaseFieldDescription             = big.NewInt(1 << 6)
)

type ActionBase struct {
	// Whether the action requires user interaction to execute. If false, and all of the required action parameters are known, the LLM may call the action automatically. If true, an conversations ask call will return a BotActionFormResponse which must be submitted by an API caller. API callers must display a button with the buttonName label to confirm the user's intent.
	UserInteractionRequired bool `json:"userInteractionRequired" url:"userInteractionRequired"`
	// When user interaction is required, the name of the button that is shown to the end user to confirm execution of the action. Defaults to "Submit" if not supplied.
	ButtonName *string `json:"buttonName,omitempty" url:"buttonName,omitempty"`
	// The preconditions that must be met for an action to be relevant to a conversation. Can be used to restrict actions to certain types of users.
	Precondition *Precondition `json:"precondition,omitempty" url:"precondition,omitempty"`
	// The parameters that the action uses as input. An action will only be executed when all of the required parameters are provided. During execution, actions all have access to the full Conversation and User objects. Parameter values may be inferred from the user's conversation by the LLM.
	UserFormParameters []*ActionParameter `json:"userFormParameters" url:"userFormParameters"`
	// The ISO 639-1 code for the language used in all fields of this action. Will be derived using the description's text if not specified.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The name of the action. This is displayed to the end user as part of forms when user interaction is required. It is also used to help Maven decide if the action is relevant to a conversation.
	Name string `json:"name" url:"name"`
	// The description of the action. Must be less than 1024 characters. This helps Maven decide if the action is relevant to a conversation and is not displayed directly to the end user. Descriptions are used by the LLM.
	Description string `json:"description" url:"description"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionBase) GetUserInteractionRequired() bool {
	if a == nil {
		return false
	}
	return a.UserInteractionRequired
}

func (a *ActionBase) GetButtonName() *string {
	if a == nil {
		return nil
	}
	return a.ButtonName
}

func (a *ActionBase) GetPrecondition() *Precondition {
	if a == nil {
		return nil
	}
	return a.Precondition
}

func (a *ActionBase) GetUserFormParameters() []*ActionParameter {
	if a == nil {
		return nil
	}
	return a.UserFormParameters
}

func (a *ActionBase) GetLanguage() *string {
	if a == nil {
		return nil
	}
	return a.Language
}

func (a *ActionBase) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *ActionBase) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ActionBase) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionBase) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetUserInteractionRequired sets the UserInteractionRequired field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetUserInteractionRequired(userInteractionRequired bool) {
	a.UserInteractionRequired = userInteractionRequired
	a.require(actionBaseFieldUserInteractionRequired)
}

// SetButtonName sets the ButtonName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetButtonName(buttonName *string) {
	a.ButtonName = buttonName
	a.require(actionBaseFieldButtonName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetPrecondition(precondition *Precondition) {
	a.Precondition = precondition
	a.require(actionBaseFieldPrecondition)
}

// SetUserFormParameters sets the UserFormParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetUserFormParameters(userFormParameters []*ActionParameter) {
	a.UserFormParameters = userFormParameters
	a.require(actionBaseFieldUserFormParameters)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetLanguage(language *string) {
	a.Language = language
	a.require(actionBaseFieldLanguage)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetName(name string) {
	a.Name = name
	a.require(actionBaseFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetDescription(description string) {
	a.Description = description
	a.require(actionBaseFieldDescription)
}

func (a *ActionBase) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionBase) MarshalJSON() ([]byte, error) {
	type embed ActionBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionBase) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	actionEnumOptionFieldLabel = big.NewInt(1 << 0)
	actionEnumOptionFieldValue = big.NewInt(1 << 1)
)

type ActionEnumOption struct {
	// Will be shown during form display as the user facing string in a dropdown or radio.
	Label string `json:"label" url:"label"`
	// A valid value for the field.
	Value interface{} `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionEnumOption) GetLabel() string {
	if a == nil {
		return ""
	}
	return a.Label
}

func (a *ActionEnumOption) GetValue() interface{} {
	if a == nil {
		return nil
	}
	return a.Value
}

func (a *ActionEnumOption) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionEnumOption) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionEnumOption) SetLabel(label string) {
	a.Label = label
	a.require(actionEnumOptionFieldLabel)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionEnumOption) SetValue(value interface{}) {
	a.Value = value
	a.require(actionEnumOptionFieldValue)
}

func (a *ActionEnumOption) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionEnumOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionEnumOption(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionEnumOption) MarshalJSON() ([]byte, error) {
	type embed ActionEnumOption
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionEnumOption) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionExecutionParamValue struct {
	ValueType  string
	Primitive  interface{}
	Attachment *AttachmentResponse
}

func (a *ActionExecutionParamValue) GetValueType() string {
	if a == nil {
		return ""
	}
	return a.ValueType
}

func (a *ActionExecutionParamValue) GetPrimitive() interface{} {
	if a == nil {
		return nil
	}
	return a.Primitive
}

func (a *ActionExecutionParamValue) GetAttachment() *AttachmentResponse {
	if a == nil {
		return nil
	}
	return a.Attachment
}

func (a *ActionExecutionParamValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ValueType string `json:"valueType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.ValueType = unmarshaler.ValueType
	if unmarshaler.ValueType == "" {
		return fmt.Errorf("%T did not include discriminant valueType", a)
	}
	switch unmarshaler.ValueType {
	case "primitive":
		var valueUnmarshaler struct {
			Primitive interface{} `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.Primitive = valueUnmarshaler.Primitive
	case "attachment":
		value := new(AttachmentResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Attachment = value
	}
	return nil
}

func (a ActionExecutionParamValue) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Primitive != nil {
		var marshaler = struct {
			ValueType string      `json:"valueType"`
			Primitive interface{} `json:"value"`
		}{
			ValueType: "primitive",
			Primitive: a.Primitive,
		}
		return json.Marshal(marshaler)
	}
	if a.Attachment != nil {
		return internal.MarshalJSONWithExtraProperty(a.Attachment, "valueType", "attachment")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type ActionExecutionParamValueVisitor interface {
	VisitPrimitive(interface{}) error
	VisitAttachment(*AttachmentResponse) error
}

func (a *ActionExecutionParamValue) Accept(visitor ActionExecutionParamValueVisitor) error {
	if a.Primitive != nil {
		return visitor.VisitPrimitive(a.Primitive)
	}
	if a.Attachment != nil {
		return visitor.VisitAttachment(a.Attachment)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *ActionExecutionParamValue) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Primitive != nil {
		fields = append(fields, "primitive")
	}
	if a.Attachment != nil {
		fields = append(fields, "attachment")
	}
	if len(fields) == 0 {
		if a.ValueType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.ValueType)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.ValueType != "" {
		field := fields[0]
		if a.ValueType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.ValueType,
				a,
			)
		}
	}
	return nil
}

var (
	actionFormFieldFieldID          = big.NewInt(1 << 0)
	actionFormFieldFieldLabel       = big.NewInt(1 << 1)
	actionFormFieldFieldDescription = big.NewInt(1 << 2)
	actionFormFieldFieldRequired    = big.NewInt(1 << 3)
	actionFormFieldFieldSuggestion  = big.NewInt(1 << 4)
	actionFormFieldFieldType        = big.NewInt(1 << 5)
	actionFormFieldFieldEnumOptions = big.NewInt(1 << 6)
)

type ActionFormField struct {
	// The ID field should be used as the key in the `submitActionForm` API.
	ID string `json:"id" url:"id"`
	// The title of the field to show on the form. Provided in the user's language.
	Label string `json:"label" url:"label"`
	// A longer description of the field which should be shown in smaller text near the label. Provided in the user's language.
	Description string `json:"description" url:"description"`
	// Whether the field is required for the action. Client side validation is recommended for an improved user experience.
	Required bool `json:"required" url:"required"`
	// A value for the field provided by the LLM. All form fields should default to this value if present.
	Suggestion interface{} `json:"suggestion,omitempty" url:"suggestion,omitempty"`
	// Describes how the action field should be validated. Client side validation is recommended but not required. | If `enumOptions` are provided, using a dropdown or radio field is preferred. Otherwise, if the `type` is `BOOLEAN` a checkbox is preferred. | Fallback to a text input.
	Type ActionParameterType `json:"type" url:"type"`
	// The options that should be shown to the user as a dropdown or radio.
	EnumOptions []*ActionEnumOption `json:"enumOptions,omitempty" url:"enumOptions,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionFormField) GetID() string {
	if a == nil {
		return ""
	}
	return a.ID
}

func (a *ActionFormField) GetLabel() string {
	if a == nil {
		return ""
	}
	return a.Label
}

func (a *ActionFormField) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ActionFormField) GetRequired() bool {
	if a == nil {
		return false
	}
	return a.Required
}

func (a *ActionFormField) GetSuggestion() interface{} {
	if a == nil {
		return nil
	}
	return a.Suggestion
}

func (a *ActionFormField) GetType() ActionParameterType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *ActionFormField) GetEnumOptions() []*ActionEnumOption {
	if a == nil {
		return nil
	}
	return a.EnumOptions
}

func (a *ActionFormField) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionFormField) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetID(id string) {
	a.ID = id
	a.require(actionFormFieldFieldID)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetLabel(label string) {
	a.Label = label
	a.require(actionFormFieldFieldLabel)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetDescription(description string) {
	a.Description = description
	a.require(actionFormFieldFieldDescription)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetRequired(required bool) {
	a.Required = required
	a.require(actionFormFieldFieldRequired)
}

// SetSuggestion sets the Suggestion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetSuggestion(suggestion interface{}) {
	a.Suggestion = suggestion
	a.require(actionFormFieldFieldSuggestion)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetType(type_ ActionParameterType) {
	a.Type = type_
	a.require(actionFormFieldFieldType)
}

// SetEnumOptions sets the EnumOptions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetEnumOptions(enumOptions []*ActionEnumOption) {
	a.EnumOptions = enumOptions
	a.require(actionFormFieldFieldEnumOptions)
}

func (a *ActionFormField) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionFormField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionFormField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionFormField) MarshalJSON() ([]byte, error) {
	type embed ActionFormField
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionFormField) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	actionOAuthConfigurationFieldAuthorizationURL = big.NewInt(1 << 0)
	actionOAuthConfigurationFieldTokenURL         = big.NewInt(1 << 1)
	actionOAuthConfigurationFieldClientID         = big.NewInt(1 << 2)
	actionOAuthConfigurationFieldClientSecret     = big.NewInt(1 << 3)
	actionOAuthConfigurationFieldScopes           = big.NewInt(1 << 4)
	actionOAuthConfigurationFieldExtraAuthParams  = big.NewInt(1 << 5)
	actionOAuthConfigurationFieldExtraTokenParams = big.NewInt(1 << 6)
)

type ActionOAuthConfiguration struct {
	AuthorizationURL string            `json:"authorizationUrl" url:"authorizationUrl"`
	TokenURL         string            `json:"tokenUrl" url:"tokenUrl"`
	ClientID         string            `json:"clientId" url:"clientId"`
	ClientSecret     string            `json:"clientSecret" url:"clientSecret"`
	Scopes           []string          `json:"scopes" url:"scopes"`
	ExtraAuthParams  map[string]string `json:"extraAuthParams,omitempty" url:"extraAuthParams,omitempty"`
	ExtraTokenParams map[string]string `json:"extraTokenParams,omitempty" url:"extraTokenParams,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionOAuthConfiguration) GetAuthorizationURL() string {
	if a == nil {
		return ""
	}
	return a.AuthorizationURL
}

func (a *ActionOAuthConfiguration) GetTokenURL() string {
	if a == nil {
		return ""
	}
	return a.TokenURL
}

func (a *ActionOAuthConfiguration) GetClientID() string {
	if a == nil {
		return ""
	}
	return a.ClientID
}

func (a *ActionOAuthConfiguration) GetClientSecret() string {
	if a == nil {
		return ""
	}
	return a.ClientSecret
}

func (a *ActionOAuthConfiguration) GetScopes() []string {
	if a == nil {
		return nil
	}
	return a.Scopes
}

func (a *ActionOAuthConfiguration) GetExtraAuthParams() map[string]string {
	if a == nil {
		return nil
	}
	return a.ExtraAuthParams
}

func (a *ActionOAuthConfiguration) GetExtraTokenParams() map[string]string {
	if a == nil {
		return nil
	}
	return a.ExtraTokenParams
}

func (a *ActionOAuthConfiguration) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionOAuthConfiguration) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAuthorizationURL sets the AuthorizationURL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetAuthorizationURL(authorizationURL string) {
	a.AuthorizationURL = authorizationURL
	a.require(actionOAuthConfigurationFieldAuthorizationURL)
}

// SetTokenURL sets the TokenURL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetTokenURL(tokenURL string) {
	a.TokenURL = tokenURL
	a.require(actionOAuthConfigurationFieldTokenURL)
}

// SetClientID sets the ClientID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetClientID(clientID string) {
	a.ClientID = clientID
	a.require(actionOAuthConfigurationFieldClientID)
}

// SetClientSecret sets the ClientSecret field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetClientSecret(clientSecret string) {
	a.ClientSecret = clientSecret
	a.require(actionOAuthConfigurationFieldClientSecret)
}

// SetScopes sets the Scopes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetScopes(scopes []string) {
	a.Scopes = scopes
	a.require(actionOAuthConfigurationFieldScopes)
}

// SetExtraAuthParams sets the ExtraAuthParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetExtraAuthParams(extraAuthParams map[string]string) {
	a.ExtraAuthParams = extraAuthParams
	a.require(actionOAuthConfigurationFieldExtraAuthParams)
}

// SetExtraTokenParams sets the ExtraTokenParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetExtraTokenParams(extraTokenParams map[string]string) {
	a.ExtraTokenParams = extraTokenParams
	a.require(actionOAuthConfigurationFieldExtraTokenParams)
}

func (a *ActionOAuthConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionOAuthConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionOAuthConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionOAuthConfiguration) MarshalJSON() ([]byte, error) {
	type embed ActionOAuthConfiguration
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionOAuthConfiguration) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	actionParameterFieldID                 = big.NewInt(1 << 0)
	actionParameterFieldLabel              = big.NewInt(1 << 1)
	actionParameterFieldDescription        = big.NewInt(1 << 2)
	actionParameterFieldRequired           = big.NewInt(1 << 3)
	actionParameterFieldHidden             = big.NewInt(1 << 4)
	actionParameterFieldType               = big.NewInt(1 << 5)
	actionParameterFieldEnumOptions        = big.NewInt(1 << 6)
	actionParameterFieldSchema             = big.NewInt(1 << 7)
	actionParameterFieldOauthConfiguration = big.NewInt(1 << 8)
)

type ActionParameter struct {
	// The ID field will be used when parameters are supplied to `executeAction`.
	ID string `json:"id" url:"id"`
	// The title of the field that will be shown on action forms.
	Label string `json:"label" url:"label"`
	// A longer description of the field which will be shown in smaller text near the label on action forms.
	Description string `json:"description" url:"description"`
	// Whether the field is required for action execution.
	Required bool `json:"required" url:"required"`
	// When user interaction is required, whether this parameter should be excluded from forms. Hidden parameters are not displayed to users but their values are still populated by the LLM and sent to actions. Defaults to false.
	Hidden *bool `json:"hidden,omitempty" url:"hidden,omitempty"`
	// The parameter type. Values provided to `executeAction` will conform to this type. Defaults to `STRING`.
	Type *ActionParameterType `json:"type,omitempty" url:"type,omitempty"`
	// Restricts the action parameter to only the options in this list. Valid for type `STRING`, `BOOLEAN`, and `NUMBER`. Should not be used when type is `SCHEMA`.
	EnumOptions []*ActionEnumOption `json:"enumOptions,omitempty" url:"enumOptions,omitempty"`
	// JSON schema for validating the parameter value. Only valid when type is `SCHEMA`.
	//
	// **Schema Requirements:**
	// - Root type must be "object" - The top-level schema must define an object type
	// - Supported types: string, number, boolean, integer, object, array, enum, anyOf
	// - Unsupported features: oneOf, allOf, const, not, if/then/else, pattern, maxLength, minLength
	// - Required fields: All fields must be required (no optional properties)
	// - Additional properties: Must be set to false
	//
	// **Limits:**
	// - Maximum nesting depth: 5 levels
	// - Maximum total properties: 100
	// - Maximum total string length: 15,000 characters
	// - Maximum total enum values: 500
	Schema *string `json:"schema,omitempty" url:"schema,omitempty"`
	// OAuth configuration required to start an OAuth authorization flow when this parameter's type is `OAUTH`.
	OauthConfiguration *ActionOAuthConfiguration `json:"oauthConfiguration,omitempty" url:"oauthConfiguration,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionParameter) GetID() string {
	if a == nil {
		return ""
	}
	return a.ID
}

func (a *ActionParameter) GetLabel() string {
	if a == nil {
		return ""
	}
	return a.Label
}

func (a *ActionParameter) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ActionParameter) GetRequired() bool {
	if a == nil {
		return false
	}
	return a.Required
}

func (a *ActionParameter) GetHidden() *bool {
	if a == nil {
		return nil
	}
	return a.Hidden
}

func (a *ActionParameter) GetType() *ActionParameterType {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *ActionParameter) GetEnumOptions() []*ActionEnumOption {
	if a == nil {
		return nil
	}
	return a.EnumOptions
}

func (a *ActionParameter) GetSchema() *string {
	if a == nil {
		return nil
	}
	return a.Schema
}

func (a *ActionParameter) GetOauthConfiguration() *ActionOAuthConfiguration {
	if a == nil {
		return nil
	}
	return a.OauthConfiguration
}

func (a *ActionParameter) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionParameter) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetID(id string) {
	a.ID = id
	a.require(actionParameterFieldID)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetLabel(label string) {
	a.Label = label
	a.require(actionParameterFieldLabel)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetDescription(description string) {
	a.Description = description
	a.require(actionParameterFieldDescription)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetRequired(required bool) {
	a.Required = required
	a.require(actionParameterFieldRequired)
}

// SetHidden sets the Hidden field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetHidden(hidden *bool) {
	a.Hidden = hidden
	a.require(actionParameterFieldHidden)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetType(type_ *ActionParameterType) {
	a.Type = type_
	a.require(actionParameterFieldType)
}

// SetEnumOptions sets the EnumOptions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetEnumOptions(enumOptions []*ActionEnumOption) {
	a.EnumOptions = enumOptions
	a.require(actionParameterFieldEnumOptions)
}

// SetSchema sets the Schema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetSchema(schema *string) {
	a.Schema = schema
	a.require(actionParameterFieldSchema)
}

// SetOauthConfiguration sets the OauthConfiguration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetOauthConfiguration(oauthConfiguration *ActionOAuthConfiguration) {
	a.OauthConfiguration = oauthConfiguration
	a.require(actionParameterFieldOauthConfiguration)
}

func (a *ActionParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionParameter) MarshalJSON() ([]byte, error) {
	type embed ActionParameter
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionParameter) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionParameterType string

const (
	// String parameter type for text input.
	ActionParameterTypeString ActionParameterType = "STRING"
	// A long string parameter type for text input. Will be rendered as a textarea when used in a form.
	ActionParameterTypeMultiline ActionParameterType = "MULTILINE"
	// Boolean parameter type for true/false values.
	ActionParameterTypeBoolean ActionParameterType = "BOOLEAN"
	// Number parameter type for numeric values.
	ActionParameterTypeNumber ActionParameterType = "NUMBER"
	// Date-time parameter type (ISO-8601, e.g. 2018-11-13T20:20:39Z)
	ActionParameterTypeDatetime ActionParameterType = "DATETIME"
	// Date parameter type (ISO-8601, e.g. 2018-11-13)
	ActionParameterTypeDate ActionParameterType = "DATE"
	// Time parameter type (ISO-8601, e.g. 20:20:39)
	ActionParameterTypeTime ActionParameterType = "TIME"
	// Email parameter type; must be a valid email address
	ActionParameterTypeEmail ActionParameterType = "EMAIL"
	// Phone number parameter type; must be a valid phone number (E.164 or regional format)
	ActionParameterTypePhone ActionParameterType = "PHONE"
	// Schema parameter type for complex structured data that adheres to a JSON schema definition. When this type is used this should be the only action parameter (all other parameters should be omitted), the `schema` field must be set and `enumOptions` should not be used.
	ActionParameterTypeSchema ActionParameterType = "SCHEMA"
	// File parameter type for file uploads.
	ActionParameterTypeFile ActionParameterType = "FILE"
	// OAuth authorization parameter type used to pass an access token at execution time. When this type is used it should be the only action parameter. This parameter is not sent to the LLM or shown on forms.
	ActionParameterTypeOauth ActionParameterType = "OAUTH"
)

func NewActionParameterTypeFromString(s string) (ActionParameterType, error) {
	switch s {
	case "STRING":
		return ActionParameterTypeString, nil
	case "MULTILINE":
		return ActionParameterTypeMultiline, nil
	case "BOOLEAN":
		return ActionParameterTypeBoolean, nil
	case "NUMBER":
		return ActionParameterTypeNumber, nil
	case "DATETIME":
		return ActionParameterTypeDatetime, nil
	case "DATE":
		return ActionParameterTypeDate, nil
	case "TIME":
		return ActionParameterTypeTime, nil
	case "EMAIL":
		return ActionParameterTypeEmail, nil
	case "PHONE":
		return ActionParameterTypePhone, nil
	case "SCHEMA":
		return ActionParameterTypeSchema, nil
	case "FILE":
		return ActionParameterTypeFile, nil
	case "OAUTH":
		return ActionParameterTypeOauth, nil
	}
	var t ActionParameterType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionParameterType) Ptr() *ActionParameterType {
	return &a
}

var (
	actionPropertiesFieldUserInteractionRequired = big.NewInt(1 << 0)
	actionPropertiesFieldButtonName              = big.NewInt(1 << 1)
	actionPropertiesFieldPrecondition            = big.NewInt(1 << 2)
	actionPropertiesFieldUserFormParameters      = big.NewInt(1 << 3)
	actionPropertiesFieldLanguage                = big.NewInt(1 << 4)
)

type ActionProperties struct {
	// Whether the action requires user interaction to execute. If false, and all of the required action parameters are known, the LLM may call the action automatically. If true, an conversations ask call will return a BotActionFormResponse which must be submitted by an API caller. API callers must display a button with the buttonName label to confirm the user's intent.
	UserInteractionRequired bool `json:"userInteractionRequired" url:"userInteractionRequired"`
	// When user interaction is required, the name of the button that is shown to the end user to confirm execution of the action. Defaults to "Submit" if not supplied.
	ButtonName *string `json:"buttonName,omitempty" url:"buttonName,omitempty"`
	// The preconditions that must be met for an action to be relevant to a conversation. Can be used to restrict actions to certain types of users.
	Precondition *Precondition `json:"precondition,omitempty" url:"precondition,omitempty"`
	// The parameters that the action uses as input. An action will only be executed when all of the required parameters are provided. During execution, actions all have access to the full Conversation and User objects. Parameter values may be inferred from the user's conversation by the LLM.
	UserFormParameters []*ActionParameter `json:"userFormParameters" url:"userFormParameters"`
	// The ISO 639-1 code for the language used in all fields of this action. Will be derived using the description's text if not specified.
	Language *string `json:"language,omitempty" url:"language,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionProperties) GetUserInteractionRequired() bool {
	if a == nil {
		return false
	}
	return a.UserInteractionRequired
}

func (a *ActionProperties) GetButtonName() *string {
	if a == nil {
		return nil
	}
	return a.ButtonName
}

func (a *ActionProperties) GetPrecondition() *Precondition {
	if a == nil {
		return nil
	}
	return a.Precondition
}

func (a *ActionProperties) GetUserFormParameters() []*ActionParameter {
	if a == nil {
		return nil
	}
	return a.UserFormParameters
}

func (a *ActionProperties) GetLanguage() *string {
	if a == nil {
		return nil
	}
	return a.Language
}

func (a *ActionProperties) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionProperties) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetUserInteractionRequired sets the UserInteractionRequired field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionProperties) SetUserInteractionRequired(userInteractionRequired bool) {
	a.UserInteractionRequired = userInteractionRequired
	a.require(actionPropertiesFieldUserInteractionRequired)
}

// SetButtonName sets the ButtonName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionProperties) SetButtonName(buttonName *string) {
	a.ButtonName = buttonName
	a.require(actionPropertiesFieldButtonName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionProperties) SetPrecondition(precondition *Precondition) {
	a.Precondition = precondition
	a.require(actionPropertiesFieldPrecondition)
}

// SetUserFormParameters sets the UserFormParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionProperties) SetUserFormParameters(userFormParameters []*ActionParameter) {
	a.UserFormParameters = userFormParameters
	a.require(actionPropertiesFieldUserFormParameters)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionProperties) SetLanguage(language *string) {
	a.Language = language
	a.require(actionPropertiesFieldLanguage)
}

func (a *ActionProperties) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionProperties
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionProperties(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionProperties) MarshalJSON() ([]byte, error) {
	type embed ActionProperties
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionProperties) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	actionResponseFieldUserInteractionRequired = big.NewInt(1 << 0)
	actionResponseFieldButtonName              = big.NewInt(1 << 1)
	actionResponseFieldPrecondition            = big.NewInt(1 << 2)
	actionResponseFieldUserFormParameters      = big.NewInt(1 << 3)
	actionResponseFieldLanguage                = big.NewInt(1 << 4)
	actionResponseFieldName                    = big.NewInt(1 << 5)
	actionResponseFieldDescription             = big.NewInt(1 << 6)
	actionResponseFieldActionID                = big.NewInt(1 << 7)
	actionResponseFieldInstructions            = big.NewInt(1 << 8)
	actionResponseFieldLlmInclusionStatus      = big.NewInt(1 << 9)
	actionResponseFieldSegmentID               = big.NewInt(1 << 10)
	actionResponseFieldPreconditionExplanation = big.NewInt(1 << 11)
	actionResponseFieldDeleted                 = big.NewInt(1 << 12)
)

type ActionResponse struct {
	// Whether the action requires user interaction to execute. If false, and all of the required action parameters are known, the LLM may call the action automatically. If true, an conversations ask call will return a BotActionFormResponse which must be submitted by an API caller. API callers must display a button with the buttonName label to confirm the user's intent.
	UserInteractionRequired bool `json:"userInteractionRequired" url:"userInteractionRequired"`
	// When user interaction is required, the name of the button that is shown to the end user to confirm execution of the action. Defaults to "Submit" if not supplied.
	ButtonName *string `json:"buttonName,omitempty" url:"buttonName,omitempty"`
	// The preconditions that must be met for an action to be relevant to a conversation. Can be used to restrict actions to certain types of users.
	Precondition *Precondition `json:"precondition,omitempty" url:"precondition,omitempty"`
	// The parameters that the action uses as input. An action will only be executed when all of the required parameters are provided. During execution, actions all have access to the full Conversation and User objects. Parameter values may be inferred from the user's conversation by the LLM.
	UserFormParameters []*ActionParameter `json:"userFormParameters" url:"userFormParameters"`
	// The ISO 639-1 code for the language used in all fields of this action. Will be derived using the description's text if not specified.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The name of the action. This is displayed to the end user as part of forms when user interaction is required. It is also used to help Maven decide if the action is relevant to a conversation.
	Name string `json:"name" url:"name"`
	// The description of the action. Must be less than 1024 characters. This helps Maven decide if the action is relevant to a conversation and is not displayed directly to the end user. Descriptions are used by the LLM.
	Description string `json:"description" url:"description"`
	// ID that uniquely identifies this action
	ActionID *EntityID `json:"actionId" url:"actionId"`
	// The instructions given to the LLM when determining whether to execute the action.
	// This field defaults to the `description` field if not provided. Use the `patch` API to update.
	Instructions *string `json:"instructions,omitempty" url:"instructions,omitempty"`
	// Determines whether the action is sent to the LLM as part of a conversation.
	//
	// - `ALWAYS`: The action is always available for use in conversations, textual relevance is not considered.
	// - `WHEN_RELEVANT`: The action is available only in conversations where the action is determined to be relevant to the user's question.
	// - `NEVER`: The action is not available for use in conversations.
	LlmInclusionStatus LlmInclusionStatus `json:"llmInclusionStatus" url:"llmInclusionStatus"`
	// The IDs of the segment that must be matched for the action to be relevant to a conversation.
	// Segments are replacing inline preconditions - an Action may not have both an inline precondition and a segment.
	// Inline precondition support will be removed in a future release.
	SegmentID *EntityID `json:"segmentId,omitempty" url:"segmentId,omitempty"`
	// A human-readable explanation of the precondition associated with this action, if present.
	PreconditionExplanation *string `json:"preconditionExplanation,omitempty" url:"preconditionExplanation,omitempty"`
	// Whether the action has been deleted. Deleted actions will not sent to the LLM nor returned in search results.
	Deleted bool `json:"deleted" url:"deleted"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionResponse) GetUserInteractionRequired() bool {
	if a == nil {
		return false
	}
	return a.UserInteractionRequired
}

func (a *ActionResponse) GetButtonName() *string {
	if a == nil {
		return nil
	}
	return a.ButtonName
}

func (a *ActionResponse) GetPrecondition() *Precondition {
	if a == nil {
		return nil
	}
	return a.Precondition
}

func (a *ActionResponse) GetUserFormParameters() []*ActionParameter {
	if a == nil {
		return nil
	}
	return a.UserFormParameters
}

func (a *ActionResponse) GetLanguage() *string {
	if a == nil {
		return nil
	}
	return a.Language
}

func (a *ActionResponse) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *ActionResponse) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ActionResponse) GetActionID() *EntityID {
	if a == nil {
		return nil
	}
	return a.ActionID
}

func (a *ActionResponse) GetInstructions() *string {
	if a == nil {
		return nil
	}
	return a.Instructions
}

func (a *ActionResponse) GetLlmInclusionStatus() LlmInclusionStatus {
	if a == nil {
		return ""
	}
	return a.LlmInclusionStatus
}

func (a *ActionResponse) GetSegmentID() *EntityID {
	if a == nil {
		return nil
	}
	return a.SegmentID
}

func (a *ActionResponse) GetPreconditionExplanation() *string {
	if a == nil {
		return nil
	}
	return a.PreconditionExplanation
}

func (a *ActionResponse) GetDeleted() bool {
	if a == nil {
		return false
	}
	return a.Deleted
}

func (a *ActionResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetUserInteractionRequired sets the UserInteractionRequired field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetUserInteractionRequired(userInteractionRequired bool) {
	a.UserInteractionRequired = userInteractionRequired
	a.require(actionResponseFieldUserInteractionRequired)
}

// SetButtonName sets the ButtonName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetButtonName(buttonName *string) {
	a.ButtonName = buttonName
	a.require(actionResponseFieldButtonName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetPrecondition(precondition *Precondition) {
	a.Precondition = precondition
	a.require(actionResponseFieldPrecondition)
}

// SetUserFormParameters sets the UserFormParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetUserFormParameters(userFormParameters []*ActionParameter) {
	a.UserFormParameters = userFormParameters
	a.require(actionResponseFieldUserFormParameters)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetLanguage(language *string) {
	a.Language = language
	a.require(actionResponseFieldLanguage)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetName(name string) {
	a.Name = name
	a.require(actionResponseFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetDescription(description string) {
	a.Description = description
	a.require(actionResponseFieldDescription)
}

// SetActionID sets the ActionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetActionID(actionID *EntityID) {
	a.ActionID = actionID
	a.require(actionResponseFieldActionID)
}

// SetInstructions sets the Instructions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetInstructions(instructions *string) {
	a.Instructions = instructions
	a.require(actionResponseFieldInstructions)
}

// SetLlmInclusionStatus sets the LlmInclusionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetLlmInclusionStatus(llmInclusionStatus LlmInclusionStatus) {
	a.LlmInclusionStatus = llmInclusionStatus
	a.require(actionResponseFieldLlmInclusionStatus)
}

// SetSegmentID sets the SegmentID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetSegmentID(segmentID *EntityID) {
	a.SegmentID = segmentID
	a.require(actionResponseFieldSegmentID)
}

// SetPreconditionExplanation sets the PreconditionExplanation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetPreconditionExplanation(preconditionExplanation *string) {
	a.PreconditionExplanation = preconditionExplanation
	a.require(actionResponseFieldPreconditionExplanation)
}

// SetDeleted sets the Deleted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetDeleted(deleted bool) {
	a.Deleted = deleted
	a.require(actionResponseFieldDeleted)
}

func (a *ActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionResponse) MarshalJSON() ([]byte, error) {
	type embed ActionResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	actionUserFieldUserID          = big.NewInt(1 << 0)
	actionUserFieldAgentUserID     = big.NewInt(1 << 1)
	actionUserFieldUserIdentifiers = big.NewInt(1 << 2)
	actionUserFieldAllUserData     = big.NewInt(1 << 3)
	actionUserFieldDefaultUserData = big.NewInt(1 << 4)
	actionUserFieldAgentUserData   = big.NewInt(1 << 5)
)

type ActionUser struct {
	// A user ID that can be used to store user information. Will only be undefined on legacy surfaces.
	UserID *EntityIDBase `json:"userId,omitempty" url:"userId,omitempty"`
	// The ID of the agent user that the userId is associated with
	AgentUserID *string `json:"agentUserId,omitempty" url:"agentUserId,omitempty"`
	// All known identifiers for the user who is executing the action.
	UserIdentifiers []*AppUserIdentifier `json:"userIdentifiers" url:"userIdentifiers"`
	// Data from all apps
	AllUserData map[string]map[string]string `json:"allUserData" url:"allUserData"`
	// Default data for this user
	DefaultUserData map[string]string `json:"defaultUserData" url:"defaultUserData"`
	// All user data for this user, including reverse indexable user data
	AgentUserData map[string][]*UserDataWithReference `json:"agentUserData" url:"agentUserData"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionUser) GetUserID() *EntityIDBase {
	if a == nil {
		return nil
	}
	return a.UserID
}

func (a *ActionUser) GetAgentUserID() *string {
	if a == nil {
		return nil
	}
	return a.AgentUserID
}

func (a *ActionUser) GetUserIdentifiers() []*AppUserIdentifier {
	if a == nil {
		return nil
	}
	return a.UserIdentifiers
}

func (a *ActionUser) GetAllUserData() map[string]map[string]string {
	if a == nil {
		return nil
	}
	return a.AllUserData
}

func (a *ActionUser) GetDefaultUserData() map[string]string {
	if a == nil {
		return nil
	}
	return a.DefaultUserData
}

func (a *ActionUser) GetAgentUserData() map[string][]*UserDataWithReference {
	if a == nil {
		return nil
	}
	return a.AgentUserData
}

func (a *ActionUser) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionUser) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetUserID sets the UserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionUser) SetUserID(userID *EntityIDBase) {
	a.UserID = userID
	a.require(actionUserFieldUserID)
}

// SetAgentUserID sets the AgentUserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionUser) SetAgentUserID(agentUserID *string) {
	a.AgentUserID = agentUserID
	a.require(actionUserFieldAgentUserID)
}

// SetUserIdentifiers sets the UserIdentifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionUser) SetUserIdentifiers(userIdentifiers []*AppUserIdentifier) {
	a.UserIdentifiers = userIdentifiers
	a.require(actionUserFieldUserIdentifiers)
}

// SetAllUserData sets the AllUserData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionUser) SetAllUserData(allUserData map[string]map[string]string) {
	a.AllUserData = allUserData
	a.require(actionUserFieldAllUserData)
}

// SetDefaultUserData sets the DefaultUserData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionUser) SetDefaultUserData(defaultUserData map[string]string) {
	a.DefaultUserData = defaultUserData
	a.require(actionUserFieldDefaultUserData)
}

// SetAgentUserData sets the AgentUserData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionUser) SetAgentUserData(agentUserData map[string][]*UserDataWithReference) {
	a.AgentUserData = agentUserData
	a.require(actionUserFieldAgentUserData)
}

func (a *ActionUser) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionUser
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionUser(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionUser) MarshalJSON() ([]byte, error) {
	type embed ActionUser
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionUser) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	appPreconditionFieldOperator = big.NewInt(1 << 0)
	appPreconditionFieldAppID    = big.NewInt(1 << 1)
)

type AppPrecondition struct {
	// Operator to apply to this precondition
	Operator *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`
	// Match only conversations created by this appId
	AppID string `json:"appId" url:"appId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AppPrecondition) GetOperator() *PreconditionOperator {
	if a == nil {
		return nil
	}
	return a.Operator
}

func (a *AppPrecondition) GetAppID() string {
	if a == nil {
		return ""
	}
	return a.AppID
}

func (a *AppPrecondition) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppPrecondition) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppPrecondition) SetOperator(operator *PreconditionOperator) {
	a.Operator = operator
	a.require(appPreconditionFieldOperator)
}

// SetAppID sets the AppID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppPrecondition) SetAppID(appID string) {
	a.AppID = appID
	a.require(appPreconditionFieldAppID)
}

func (a *AppPrecondition) UnmarshalJSON(data []byte) error {
	type unmarshaler AppPrecondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppPrecondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppPrecondition) MarshalJSON() ([]byte, error) {
	type embed AppPrecondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AppPrecondition) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	appUserFieldIdentifiers = big.NewInt(1 << 0)
	appUserFieldData        = big.NewInt(1 << 1)
)

type AppUser struct {
	// Used to determine whether two users from different apps are the same
	Identifiers []*AppUserIdentifier `json:"identifiers" url:"identifiers"`
	Data        map[string]*UserData `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AppUser) GetIdentifiers() []*AppUserIdentifier {
	if a == nil {
		return nil
	}
	return a.Identifiers
}

func (a *AppUser) GetData() map[string]*UserData {
	if a == nil {
		return nil
	}
	return a.Data
}

func (a *AppUser) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppUser) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetIdentifiers sets the Identifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUser) SetIdentifiers(identifiers []*AppUserIdentifier) {
	a.Identifiers = identifiers
	a.require(appUserFieldIdentifiers)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUser) SetData(data map[string]*UserData) {
	a.Data = data
	a.require(appUserFieldData)
}

func (a *AppUser) UnmarshalJSON(data []byte) error {
	type unmarshaler AppUser
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppUser(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppUser) MarshalJSON() ([]byte, error) {
	type embed AppUser
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AppUser) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	appUserIdentifierFieldValue = big.NewInt(1 << 0)
	appUserIdentifierFieldType  = big.NewInt(1 << 1)
)

type AppUserIdentifier struct {
	// The identifying property text
	Value string                         `json:"value" url:"value"`
	Type  AppUserIdentifyingPropertyType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AppUserIdentifier) GetValue() string {
	if a == nil {
		return ""
	}
	return a.Value
}

func (a *AppUserIdentifier) GetType() AppUserIdentifyingPropertyType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AppUserIdentifier) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppUserIdentifier) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserIdentifier) SetValue(value string) {
	a.Value = value
	a.require(appUserIdentifierFieldValue)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserIdentifier) SetType(type_ AppUserIdentifyingPropertyType) {
	a.Type = type_
	a.require(appUserIdentifierFieldType)
}

func (a *AppUserIdentifier) UnmarshalJSON(data []byte) error {
	type unmarshaler AppUserIdentifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppUserIdentifier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppUserIdentifier) MarshalJSON() ([]byte, error) {
	type embed AppUserIdentifier
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AppUserIdentifier) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppUserIdentifyingPropertyType string

const (
	AppUserIdentifyingPropertyTypeEmail       AppUserIdentifyingPropertyType = "EMAIL"
	AppUserIdentifyingPropertyTypePhoneNumber AppUserIdentifyingPropertyType = "PHONE_NUMBER"
)

func NewAppUserIdentifyingPropertyTypeFromString(s string) (AppUserIdentifyingPropertyType, error) {
	switch s {
	case "EMAIL":
		return AppUserIdentifyingPropertyTypeEmail, nil
	case "PHONE_NUMBER":
		return AppUserIdentifyingPropertyTypePhoneNumber, nil
	}
	var t AppUserIdentifyingPropertyType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppUserIdentifyingPropertyType) Ptr() *AppUserIdentifyingPropertyType {
	return &a
}

var (
	appUserRequestFieldIdentifiers = big.NewInt(1 << 0)
	appUserRequestFieldData        = big.NewInt(1 << 1)
	appUserRequestFieldUserID      = big.NewInt(1 << 2)
)

type AppUserRequest struct {
	// Used to determine whether two users from different apps are the same
	Identifiers []*AppUserIdentifier `json:"identifiers" url:"identifiers"`
	Data        map[string]*UserData `json:"data" url:"data"`
	// ID that uniquely identifies this app user
	UserID *EntityIDBase `json:"userId" url:"userId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AppUserRequest) GetIdentifiers() []*AppUserIdentifier {
	if a == nil {
		return nil
	}
	return a.Identifiers
}

func (a *AppUserRequest) GetData() map[string]*UserData {
	if a == nil {
		return nil
	}
	return a.Data
}

func (a *AppUserRequest) GetUserID() *EntityIDBase {
	if a == nil {
		return nil
	}
	return a.UserID
}

func (a *AppUserRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppUserRequest) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetIdentifiers sets the Identifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserRequest) SetIdentifiers(identifiers []*AppUserIdentifier) {
	a.Identifiers = identifiers
	a.require(appUserRequestFieldIdentifiers)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserRequest) SetData(data map[string]*UserData) {
	a.Data = data
	a.require(appUserRequestFieldData)
}

// SetUserID sets the UserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserRequest) SetUserID(userID *EntityIDBase) {
	a.UserID = userID
	a.require(appUserRequestFieldUserID)
}

func (a *AppUserRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AppUserRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppUserRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppUserRequest) MarshalJSON() ([]byte, error) {
	type embed AppUserRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AppUserRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	appUserResponseFieldIdentifiers     = big.NewInt(1 << 0)
	appUserResponseFieldData            = big.NewInt(1 << 1)
	appUserResponseFieldUserID          = big.NewInt(1 << 2)
	appUserResponseFieldAgentUserID     = big.NewInt(1 << 3)
	appUserResponseFieldAllUserData     = big.NewInt(1 << 4)
	appUserResponseFieldDefaultUserData = big.NewInt(1 << 5)
	appUserResponseFieldAgentUserData   = big.NewInt(1 << 6)
)

type AppUserResponse struct {
	// Used to determine whether two users from different apps are the same
	Identifiers []*AppUserIdentifier `json:"identifiers" url:"identifiers"`
	Data        map[string]*UserData `json:"data" url:"data"`
	// ID that uniquely identifies this user
	UserID *EntityID `json:"userId" url:"userId"`
	// The ID of the agent user (merged view) that this app user is associated with
	AgentUserID string `json:"agentUserId" url:"agentUserId"`
	// Data from all apps
	AllUserData map[string]map[string]string `json:"allUserData" url:"allUserData"`
	// Default data for this user
	DefaultUserData map[string]string `json:"defaultUserData" url:"defaultUserData"`
	// All user data for this user, including reverse indexable user data
	AgentUserData map[string][]*UserDataWithReference `json:"agentUserData" url:"agentUserData"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AppUserResponse) GetIdentifiers() []*AppUserIdentifier {
	if a == nil {
		return nil
	}
	return a.Identifiers
}

func (a *AppUserResponse) GetData() map[string]*UserData {
	if a == nil {
		return nil
	}
	return a.Data
}

func (a *AppUserResponse) GetUserID() *EntityID {
	if a == nil {
		return nil
	}
	return a.UserID
}

func (a *AppUserResponse) GetAgentUserID() string {
	if a == nil {
		return ""
	}
	return a.AgentUserID
}

func (a *AppUserResponse) GetAllUserData() map[string]map[string]string {
	if a == nil {
		return nil
	}
	return a.AllUserData
}

func (a *AppUserResponse) GetDefaultUserData() map[string]string {
	if a == nil {
		return nil
	}
	return a.DefaultUserData
}

func (a *AppUserResponse) GetAgentUserData() map[string][]*UserDataWithReference {
	if a == nil {
		return nil
	}
	return a.AgentUserData
}

func (a *AppUserResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppUserResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetIdentifiers sets the Identifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetIdentifiers(identifiers []*AppUserIdentifier) {
	a.Identifiers = identifiers
	a.require(appUserResponseFieldIdentifiers)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetData(data map[string]*UserData) {
	a.Data = data
	a.require(appUserResponseFieldData)
}

// SetUserID sets the UserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetUserID(userID *EntityID) {
	a.UserID = userID
	a.require(appUserResponseFieldUserID)
}

// SetAgentUserID sets the AgentUserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetAgentUserID(agentUserID string) {
	a.AgentUserID = agentUserID
	a.require(appUserResponseFieldAgentUserID)
}

// SetAllUserData sets the AllUserData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetAllUserData(allUserData map[string]map[string]string) {
	a.AllUserData = allUserData
	a.require(appUserResponseFieldAllUserData)
}

// SetDefaultUserData sets the DefaultUserData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetDefaultUserData(defaultUserData map[string]string) {
	a.DefaultUserData = defaultUserData
	a.require(appUserResponseFieldDefaultUserData)
}

// SetAgentUserData sets the AgentUserData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetAgentUserData(agentUserData map[string][]*UserDataWithReference) {
	a.AgentUserData = agentUserData
	a.require(appUserResponseFieldAgentUserData)
}

func (a *AppUserResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AppUserResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppUserResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppUserResponse) MarshalJSON() ([]byte, error) {
	type embed AppUserResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AppUserResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	arraySettingsSchemaEntryFieldKey          = big.NewInt(1 << 0)
	arraySettingsSchemaEntryFieldDisplayName  = big.NewInt(1 << 1)
	arraySettingsSchemaEntryFieldDescription  = big.NewInt(1 << 2)
	arraySettingsSchemaEntryFieldVisibility   = big.NewInt(1 << 3)
	arraySettingsSchemaEntryFieldRequired     = big.NewInt(1 << 4)
	arraySettingsSchemaEntryFieldDefaultValue = big.NewInt(1 << 5)
	arraySettingsSchemaEntryFieldValidation   = big.NewInt(1 << 6)
)

type ArraySettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required     *bool                     `json:"required,omitempty" url:"required,omitempty"`
	DefaultValue []string                  `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	Validation   *SettingsSchemaValidation `json:"validation,omitempty" url:"validation,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ArraySettingsSchemaEntry) GetKey() string {
	if a == nil {
		return ""
	}
	return a.Key
}

func (a *ArraySettingsSchemaEntry) GetDisplayName() string {
	if a == nil {
		return ""
	}
	return a.DisplayName
}

func (a *ArraySettingsSchemaEntry) GetDescription() *string {
	if a == nil {
		return nil
	}
	return a.Description
}

func (a *ArraySettingsSchemaEntry) GetVisibility() *VisibilityType {
	if a == nil {
		return nil
	}
	return a.Visibility
}

func (a *ArraySettingsSchemaEntry) GetRequired() *bool {
	if a == nil {
		return nil
	}
	return a.Required
}

func (a *ArraySettingsSchemaEntry) GetDefaultValue() []string {
	if a == nil {
		return nil
	}
	return a.DefaultValue
}

func (a *ArraySettingsSchemaEntry) GetValidation() *SettingsSchemaValidation {
	if a == nil {
		return nil
	}
	return a.Validation
}

func (a *ArraySettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ArraySettingsSchemaEntry) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ArraySettingsSchemaEntry) SetKey(key string) {
	a.Key = key
	a.require(arraySettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ArraySettingsSchemaEntry) SetDisplayName(displayName string) {
	a.DisplayName = displayName
	a.require(arraySettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ArraySettingsSchemaEntry) SetDescription(description *string) {
	a.Description = description
	a.require(arraySettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ArraySettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	a.Visibility = visibility
	a.require(arraySettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ArraySettingsSchemaEntry) SetRequired(required *bool) {
	a.Required = required
	a.require(arraySettingsSchemaEntryFieldRequired)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ArraySettingsSchemaEntry) SetDefaultValue(defaultValue []string) {
	a.DefaultValue = defaultValue
	a.require(arraySettingsSchemaEntryFieldDefaultValue)
}

// SetValidation sets the Validation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ArraySettingsSchemaEntry) SetValidation(validation *SettingsSchemaValidation) {
	a.Validation = validation
	a.require(arraySettingsSchemaEntryFieldValidation)
}

func (a *ArraySettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler ArraySettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ArraySettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ArraySettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed ArraySettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ArraySettingsSchemaEntry) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Attachments can be created either with inline data (up to 5MB) using the `content` field or by
// referencing an asynchronously uploaded asset using the `assetId` field.
//
// See the Assets APIs for more details on how to upload assets and get an asset ID.
//
// <Tip>
//
//	Due to backwards compatibility, both the `type` field and the `name` field are present when attaching an Asset by ID.
//	These fields will be ignored in favor of the values supplied during the initial Asset upload.
//	They are only used for inline content uploads.
//
// </Tip>
var (
	attachmentRequestFieldType    = big.NewInt(1 << 0)
	attachmentRequestFieldName    = big.NewInt(1 << 1)
	attachmentRequestFieldContent = big.NewInt(1 << 2)
	attachmentRequestFieldAssetID = big.NewInt(1 << 3)
)

type AttachmentRequest struct {
	// The mime-type of the attachment. Supported types are:
	// - image/jpeg
	// - image/jpg
	// - image/png
	// - image/gif
	// - image/webp
	// - application/pdf
	// - text/plain
	// - text/csv
	// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
	// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
	// - application/vnd.openxmlformats-officedocument.presentationml.presentation
	// - application/msword
	// - application/vnd.ms-excel
	// - application/vnd.ms-powerpoint
	// - audio/aac
	// - audio/mpeg
	// - audio/mp4
	// - audio/wav
	// - audio/ogg
	// - video/mp4
	// - video/webm
	Type string `json:"type" url:"type"`
	// An optional name for the attachment.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Inline attachment data, up to 5MB.
	Content *[]byte `json:"content,omitempty" url:"content,omitempty"`
	// The ID of an asynchronously uploaded asset.
	AssetID *EntityIDBase `json:"assetId,omitempty" url:"assetId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AttachmentRequest) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AttachmentRequest) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AttachmentRequest) GetContent() *[]byte {
	if a == nil {
		return nil
	}
	return a.Content
}

func (a *AttachmentRequest) GetAssetID() *EntityIDBase {
	if a == nil {
		return nil
	}
	return a.AssetID
}

func (a *AttachmentRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttachmentRequest) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentRequest) SetType(type_ string) {
	a.Type = type_
	a.require(attachmentRequestFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentRequest) SetName(name *string) {
	a.Name = name
	a.require(attachmentRequestFieldName)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentRequest) SetContent(content *[]byte) {
	a.Content = content
	a.require(attachmentRequestFieldContent)
}

// SetAssetID sets the AssetID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentRequest) SetAssetID(assetID *EntityIDBase) {
	a.AssetID = assetID
	a.require(attachmentRequestFieldAssetID)
}

func (a *AttachmentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AttachmentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AttachmentRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AttachmentRequest) MarshalJSON() ([]byte, error) {
	type embed AttachmentRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AttachmentRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	attachmentResponseFieldType      = big.NewInt(1 << 0)
	attachmentResponseFieldName      = big.NewInt(1 << 1)
	attachmentResponseFieldURL       = big.NewInt(1 << 2)
	attachmentResponseFieldSizeBytes = big.NewInt(1 << 3)
	attachmentResponseFieldStatus    = big.NewInt(1 << 4)
)

type AttachmentResponse struct {
	// The mime-type of the attachment. Supported types are:
	// - image/jpeg
	// - image/jpg
	// - image/png
	// - image/gif
	// - image/webp
	// - application/pdf
	// - text/plain
	// - text/csv
	// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
	// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
	// - application/vnd.openxmlformats-officedocument.presentationml.presentation
	// - application/msword
	// - application/vnd.ms-excel
	// - application/vnd.ms-powerpoint
	// - audio/aac
	// - audio/mpeg
	// - audio/mp4
	// - audio/wav
	// - audio/ogg
	// - video/mp4
	// - video/webm
	Type string `json:"type" url:"type"`
	// An optional name for the attachment.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The URL to access the attachment, The URL will be valid for 20 minutes. Only present when status is `ACCEPTED`.
	URL *string `json:"url,omitempty" url:"url,omitempty"`
	// The size of the attachment in bytes
	SizeBytes *int64 `json:"sizeBytes,omitempty" url:"sizeBytes,omitempty"`
	// The processing status of the attachment.
	Status AttachmentStatus `json:"status" url:"status"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AttachmentResponse) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AttachmentResponse) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AttachmentResponse) GetURL() *string {
	if a == nil {
		return nil
	}
	return a.URL
}

func (a *AttachmentResponse) GetSizeBytes() *int64 {
	if a == nil {
		return nil
	}
	return a.SizeBytes
}

func (a *AttachmentResponse) GetStatus() AttachmentStatus {
	if a == nil {
		return ""
	}
	return a.Status
}

func (a *AttachmentResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttachmentResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentResponse) SetType(type_ string) {
	a.Type = type_
	a.require(attachmentResponseFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentResponse) SetName(name *string) {
	a.Name = name
	a.require(attachmentResponseFieldName)
}

// SetURL sets the URL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentResponse) SetURL(url *string) {
	a.URL = url
	a.require(attachmentResponseFieldURL)
}

// SetSizeBytes sets the SizeBytes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentResponse) SetSizeBytes(sizeBytes *int64) {
	a.SizeBytes = sizeBytes
	a.require(attachmentResponseFieldSizeBytes)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentResponse) SetStatus(status AttachmentStatus) {
	a.Status = status
	a.require(attachmentResponseFieldStatus)
}

func (a *AttachmentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AttachmentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AttachmentResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AttachmentResponse) MarshalJSON() ([]byte, error) {
	type embed AttachmentResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AttachmentResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AttachmentStatus string

const (
	AttachmentStatusPending    AttachmentStatus = "PENDING"
	AttachmentStatusProcessing AttachmentStatus = "PROCESSING"
	AttachmentStatusAccepted   AttachmentStatus = "ACCEPTED"
	AttachmentStatusRejected   AttachmentStatus = "REJECTED"
)

func NewAttachmentStatusFromString(s string) (AttachmentStatus, error) {
	switch s {
	case "PENDING":
		return AttachmentStatusPending, nil
	case "PROCESSING":
		return AttachmentStatusProcessing, nil
	case "ACCEPTED":
		return AttachmentStatusAccepted, nil
	case "REJECTED":
		return AttachmentStatusRejected, nil
	}
	var t AttachmentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttachmentStatus) Ptr() *AttachmentStatus {
	return &a
}

var (
	baseAttachmentFieldType = big.NewInt(1 << 0)
	baseAttachmentFieldName = big.NewInt(1 << 1)
)

type BaseAttachment struct {
	// The mime-type of the attachment. Supported types are:
	// - image/jpeg
	// - image/jpg
	// - image/png
	// - image/gif
	// - image/webp
	// - application/pdf
	// - text/plain
	// - text/csv
	// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
	// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
	// - application/vnd.openxmlformats-officedocument.presentationml.presentation
	// - application/msword
	// - application/vnd.ms-excel
	// - application/vnd.ms-powerpoint
	// - audio/aac
	// - audio/mpeg
	// - audio/mp4
	// - audio/wav
	// - audio/ogg
	// - video/mp4
	// - video/webm
	Type string `json:"type" url:"type"`
	// An optional name for the attachment.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseAttachment) GetType() string {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BaseAttachment) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *BaseAttachment) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseAttachment) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseAttachment) SetType(type_ string) {
	b.Type = type_
	b.require(baseAttachmentFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseAttachment) SetName(name *string) {
	b.Name = name
	b.require(baseAttachmentFieldName)
}

func (b *BaseAttachment) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseAttachment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseAttachment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseAttachment) MarshalJSON() ([]byte, error) {
	type embed BaseAttachment
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseAttachment) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	baseConversationResponseFieldResponseConfig    = big.NewInt(1 << 0)
	baseConversationResponseFieldSubject           = big.NewInt(1 << 1)
	baseConversationResponseFieldURL               = big.NewInt(1 << 2)
	baseConversationResponseFieldCreatedAt         = big.NewInt(1 << 3)
	baseConversationResponseFieldUpdatedAt         = big.NewInt(1 << 4)
	baseConversationResponseFieldTags              = big.NewInt(1 << 5)
	baseConversationResponseFieldMetadata          = big.NewInt(1 << 6)
	baseConversationResponseFieldAllMetadata       = big.NewInt(1 << 7)
	baseConversationResponseFieldConversationID    = big.NewInt(1 << 8)
	baseConversationResponseFieldAnalysis          = big.NewInt(1 << 9)
	baseConversationResponseFieldSummary           = big.NewInt(1 << 10)
	baseConversationResponseFieldDeleted           = big.NewInt(1 << 11)
	baseConversationResponseFieldOpen              = big.NewInt(1 << 12)
	baseConversationResponseFieldLlmEnabled        = big.NewInt(1 << 13)
	baseConversationResponseFieldSimulationContext = big.NewInt(1 << 14)
)

type BaseConversationResponse struct {
	// Optional configurations for responses to this conversation
	ResponseConfig *ResponseConfig `json:"responseConfig,omitempty" url:"responseConfig,omitempty"`
	// The subject of the conversation
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The url of the conversation
	URL *string `json:"url,omitempty" url:"url,omitempty"`
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// The tags of the conversation. Used for filtering in Agent Designer.
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// The metadata of the conversation supplied by the app which created the conversation.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// All metadata for the conversation. Keyed by appId.
	AllMetadata map[string]map[string]string `json:"allMetadata" url:"allMetadata"`
	// The ID that uniquely identifies this conversation
	ConversationID *EntityID `json:"conversationId" url:"conversationId"`
	// An analysis of the conversation. Fields are generated by Maven via an analysis of user messages. This object is calculated on a delay. Fields will not be up to date on ask requests.
	Analysis *ConversationAnalysis `json:"analysis" url:"analysis"`
	// A summary of the conversation. Fields are calculated from conversation data. Unlike analysis, all fields can be derived from other data available in the API. This object is provided as a convenience and is calculated on a delay. Fields will not be up to date on ask requests.
	Summary *ConversationSummary `json:"summary" url:"summary"`
	// Whether the conversation user-specific data has been deleted. See `deleteConversation` for details.
	Deleted bool `json:"deleted" url:"deleted"`
	// Whether the conversation is able to receive asynchronous messages.
	// Only applicable if a conversation is initialized with the `ASYNC` capability. Defaults to true. Can be closed using the `PATCH` API.
	Open bool `json:"open" url:"open"`
	// Whether the LLM is enabled for this conversation.
	// If true, `USER` messages sent via the ask API will be sent to the LLM and a `BOT_RESPONSE` or `BOT_SUGGESTION` message will be generated.
	// If false, `USER` messages will not be sent to the LLM.
	LlmEnabled bool `json:"llmEnabled" url:"llmEnabled"`
	// Additional context used for simulation runs. When present, this conversation is treated as a simulation.
	// Simulation conversations are excluded from normal search results unless explicitly included via the `simulationFilter` field.
	SimulationContext *SimulationContext `json:"simulationContext,omitempty" url:"simulationContext,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseConversationResponse) GetResponseConfig() *ResponseConfig {
	if b == nil {
		return nil
	}
	return b.ResponseConfig
}

func (b *BaseConversationResponse) GetSubject() *string {
	if b == nil {
		return nil
	}
	return b.Subject
}

func (b *BaseConversationResponse) GetURL() *string {
	if b == nil {
		return nil
	}
	return b.URL
}

func (b *BaseConversationResponse) GetCreatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BaseConversationResponse) GetUpdatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.UpdatedAt
}

func (b *BaseConversationResponse) GetTags() []string {
	if b == nil {
		return nil
	}
	return b.Tags
}

func (b *BaseConversationResponse) GetMetadata() map[string]string {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BaseConversationResponse) GetAllMetadata() map[string]map[string]string {
	if b == nil {
		return nil
	}
	return b.AllMetadata
}

func (b *BaseConversationResponse) GetConversationID() *EntityID {
	if b == nil {
		return nil
	}
	return b.ConversationID
}

func (b *BaseConversationResponse) GetAnalysis() *ConversationAnalysis {
	if b == nil {
		return nil
	}
	return b.Analysis
}

func (b *BaseConversationResponse) GetSummary() *ConversationSummary {
	if b == nil {
		return nil
	}
	return b.Summary
}

func (b *BaseConversationResponse) GetDeleted() bool {
	if b == nil {
		return false
	}
	return b.Deleted
}

func (b *BaseConversationResponse) GetOpen() bool {
	if b == nil {
		return false
	}
	return b.Open
}

func (b *BaseConversationResponse) GetLlmEnabled() bool {
	if b == nil {
		return false
	}
	return b.LlmEnabled
}

func (b *BaseConversationResponse) GetSimulationContext() *SimulationContext {
	if b == nil {
		return nil
	}
	return b.SimulationContext
}

func (b *BaseConversationResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseConversationResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetResponseConfig sets the ResponseConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetResponseConfig(responseConfig *ResponseConfig) {
	b.ResponseConfig = responseConfig
	b.require(baseConversationResponseFieldResponseConfig)
}

// SetSubject sets the Subject field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetSubject(subject *string) {
	b.Subject = subject
	b.require(baseConversationResponseFieldSubject)
}

// SetURL sets the URL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetURL(url *string) {
	b.URL = url
	b.require(baseConversationResponseFieldURL)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetCreatedAt(createdAt *time.Time) {
	b.CreatedAt = createdAt
	b.require(baseConversationResponseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetUpdatedAt(updatedAt *time.Time) {
	b.UpdatedAt = updatedAt
	b.require(baseConversationResponseFieldUpdatedAt)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetTags(tags []string) {
	b.Tags = tags
	b.require(baseConversationResponseFieldTags)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetMetadata(metadata map[string]string) {
	b.Metadata = metadata
	b.require(baseConversationResponseFieldMetadata)
}

// SetAllMetadata sets the AllMetadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetAllMetadata(allMetadata map[string]map[string]string) {
	b.AllMetadata = allMetadata
	b.require(baseConversationResponseFieldAllMetadata)
}

// SetConversationID sets the ConversationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetConversationID(conversationID *EntityID) {
	b.ConversationID = conversationID
	b.require(baseConversationResponseFieldConversationID)
}

// SetAnalysis sets the Analysis field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetAnalysis(analysis *ConversationAnalysis) {
	b.Analysis = analysis
	b.require(baseConversationResponseFieldAnalysis)
}

// SetSummary sets the Summary field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetSummary(summary *ConversationSummary) {
	b.Summary = summary
	b.require(baseConversationResponseFieldSummary)
}

// SetDeleted sets the Deleted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetDeleted(deleted bool) {
	b.Deleted = deleted
	b.require(baseConversationResponseFieldDeleted)
}

// SetOpen sets the Open field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetOpen(open bool) {
	b.Open = open
	b.require(baseConversationResponseFieldOpen)
}

// SetLlmEnabled sets the LlmEnabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetLlmEnabled(llmEnabled bool) {
	b.LlmEnabled = llmEnabled
	b.require(baseConversationResponseFieldLlmEnabled)
}

// SetSimulationContext sets the SimulationContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetSimulationContext(simulationContext *SimulationContext) {
	b.SimulationContext = simulationContext
	b.require(baseConversationResponseFieldSimulationContext)
}

func (b *BaseConversationResponse) UnmarshalJSON(data []byte) error {
	type embed BaseConversationResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BaseConversationResponse(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseConversationResponse) MarshalJSON() ([]byte, error) {
	type embed BaseConversationResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewOptionalDateTime(b.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(b.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseConversationResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	basePaginatedRequestFieldPage     = big.NewInt(1 << 0)
	basePaginatedRequestFieldSize     = big.NewInt(1 << 1)
	basePaginatedRequestFieldSortDesc = big.NewInt(1 << 2)
)

type BasePaginatedRequest struct {
	// Page number to return, defaults to 0
	Page *int `json:"page,omitempty" url:"page,omitempty"`
	// The size of the page to return, defaults to 20
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Whether to sort descending, defaults to true
	SortDesc *bool `json:"sortDesc,omitempty" url:"sortDesc,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BasePaginatedRequest) GetPage() *int {
	if b == nil {
		return nil
	}
	return b.Page
}

func (b *BasePaginatedRequest) GetSize() *int {
	if b == nil {
		return nil
	}
	return b.Size
}

func (b *BasePaginatedRequest) GetSortDesc() *bool {
	if b == nil {
		return nil
	}
	return b.SortDesc
}

func (b *BasePaginatedRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasePaginatedRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasePaginatedRequest) SetPage(page *int) {
	b.Page = page
	b.require(basePaginatedRequestFieldPage)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasePaginatedRequest) SetSize(size *int) {
	b.Size = size
	b.require(basePaginatedRequestFieldSize)
}

// SetSortDesc sets the SortDesc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasePaginatedRequest) SetSortDesc(sortDesc *bool) {
	b.SortDesc = sortDesc
	b.require(basePaginatedRequestFieldSortDesc)
}

func (b *BasePaginatedRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BasePaginatedRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasePaginatedRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BasePaginatedRequest) MarshalJSON() ([]byte, error) {
	type embed BasePaginatedRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BasePaginatedRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	baseSearchRequestFieldPage     = big.NewInt(1 << 0)
	baseSearchRequestFieldSize     = big.NewInt(1 << 1)
	baseSearchRequestFieldSortDesc = big.NewInt(1 << 2)
	baseSearchRequestFieldSortID   = big.NewInt(1 << 3)
)

type BaseSearchRequest struct {
	// Page number to return, defaults to 0
	Page *int `json:"page,omitempty" url:"page,omitempty"`
	// The size of the page to return, defaults to 20
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Whether to sort descending, defaults to true
	SortDesc *bool `json:"sortDesc,omitempty" url:"sortDesc,omitempty"`
	// The field to sort by, defaults to created timestamp
	SortID *string `json:"sortId,omitempty" url:"sortId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseSearchRequest) GetPage() *int {
	if b == nil {
		return nil
	}
	return b.Page
}

func (b *BaseSearchRequest) GetSize() *int {
	if b == nil {
		return nil
	}
	return b.Size
}

func (b *BaseSearchRequest) GetSortDesc() *bool {
	if b == nil {
		return nil
	}
	return b.SortDesc
}

func (b *BaseSearchRequest) GetSortID() *string {
	if b == nil {
		return nil
	}
	return b.SortID
}

func (b *BaseSearchRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseSearchRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseSearchRequest) SetPage(page *int) {
	b.Page = page
	b.require(baseSearchRequestFieldPage)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseSearchRequest) SetSize(size *int) {
	b.Size = size
	b.require(baseSearchRequestFieldSize)
}

// SetSortDesc sets the SortDesc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseSearchRequest) SetSortDesc(sortDesc *bool) {
	b.SortDesc = sortDesc
	b.require(baseSearchRequestFieldSortDesc)
}

// SetSortID sets the SortID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseSearchRequest) SetSortID(sortID *string) {
	b.SortID = sortID
	b.require(baseSearchRequestFieldSortID)
}

func (b *BaseSearchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseSearchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseSearchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseSearchRequest) MarshalJSON() ([]byte, error) {
	type embed BaseSearchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseSearchRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Condition for boolean values
var (
	booleanConditionFieldValue = big.NewInt(1 << 0)
)

type BooleanCondition struct {
	// The expected boolean value (true or false)
	Value bool `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BooleanCondition) GetValue() bool {
	if b == nil {
		return false
	}
	return b.Value
}

func (b *BooleanCondition) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BooleanCondition) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BooleanCondition) SetValue(value bool) {
	b.Value = value
	b.require(booleanConditionFieldValue)
}

func (b *BooleanCondition) UnmarshalJSON(data []byte) error {
	type unmarshaler BooleanCondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BooleanCondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BooleanCondition) MarshalJSON() ([]byte, error) {
	type embed BooleanCondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BooleanCondition) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// This response should be rendered as a form which users can submit. Upon submission call the `submitActionForm` API.
var (
	botActionFormResponseFieldID          = big.NewInt(1 << 0)
	botActionFormResponseFieldActionID    = big.NewInt(1 << 1)
	botActionFormResponseFieldFormLabel   = big.NewInt(1 << 2)
	botActionFormResponseFieldFields      = big.NewInt(1 << 3)
	botActionFormResponseFieldSubmitLabel = big.NewInt(1 << 4)
)

type BotActionFormResponse struct {
	// The ID to use when submitting the form via the `submitActionForm` API.
	ID string `json:"id" url:"id"`
	// The ID of the action that will be executed when the form is submitted.
	ActionID *EntityIDWithoutAgent `json:"actionId" url:"actionId"`
	// Text which should be displayed to the user at the top of the form. Provided in the user's language.
	FormLabel string `json:"formLabel" url:"formLabel"`
	// The fields that should be displayed within the form.
	Fields []*ActionFormField `json:"fields" url:"fields"`
	// Text that should be displayed to the user on the submit button. Provided in the user's language.
	SubmitLabel string `json:"submitLabel" url:"submitLabel"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotActionFormResponse) GetID() string {
	if b == nil {
		return ""
	}
	return b.ID
}

func (b *BotActionFormResponse) GetActionID() *EntityIDWithoutAgent {
	if b == nil {
		return nil
	}
	return b.ActionID
}

func (b *BotActionFormResponse) GetFormLabel() string {
	if b == nil {
		return ""
	}
	return b.FormLabel
}

func (b *BotActionFormResponse) GetFields() []*ActionFormField {
	if b == nil {
		return nil
	}
	return b.Fields
}

func (b *BotActionFormResponse) GetSubmitLabel() string {
	if b == nil {
		return ""
	}
	return b.SubmitLabel
}

func (b *BotActionFormResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotActionFormResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotActionFormResponse) SetID(id string) {
	b.ID = id
	b.require(botActionFormResponseFieldID)
}

// SetActionID sets the ActionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotActionFormResponse) SetActionID(actionID *EntityIDWithoutAgent) {
	b.ActionID = actionID
	b.require(botActionFormResponseFieldActionID)
}

// SetFormLabel sets the FormLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotActionFormResponse) SetFormLabel(formLabel string) {
	b.FormLabel = formLabel
	b.require(botActionFormResponseFieldFormLabel)
}

// SetFields sets the Fields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotActionFormResponse) SetFields(fields []*ActionFormField) {
	b.Fields = fields
	b.require(botActionFormResponseFieldFields)
}

// SetSubmitLabel sets the SubmitLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotActionFormResponse) SetSubmitLabel(submitLabel string) {
	b.SubmitLabel = submitLabel
	b.require(botActionFormResponseFieldSubmitLabel)
}

func (b *BotActionFormResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BotActionFormResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotActionFormResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotActionFormResponse) MarshalJSON() ([]byte, error) {
	type embed BotActionFormResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotActionFormResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Will only be provided if the responseConfig contains the charts_highcharts_ts capability.
var (
	botChartResponseFieldLabel      = big.NewInt(1 << 0)
	botChartResponseFieldSpecSchema = big.NewInt(1 << 1)
	botChartResponseFieldSpec       = big.NewInt(1 << 2)
)

type BotChartResponse struct {
	// The label of the chart
	Label      string          `json:"label" url:"label"`
	SpecSchema ChartSpecSchema `json:"specSchema" url:"specSchema"`
	// The spec string for the chart. For HIGHCHARTS_TS charts, the spec is the json object that represents the chart options.
	Spec string `json:"spec" url:"spec"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotChartResponse) GetLabel() string {
	if b == nil {
		return ""
	}
	return b.Label
}

func (b *BotChartResponse) GetSpecSchema() ChartSpecSchema {
	if b == nil {
		return ""
	}
	return b.SpecSchema
}

func (b *BotChartResponse) GetSpec() string {
	if b == nil {
		return ""
	}
	return b.Spec
}

func (b *BotChartResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotChartResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotChartResponse) SetLabel(label string) {
	b.Label = label
	b.require(botChartResponseFieldLabel)
}

// SetSpecSchema sets the SpecSchema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotChartResponse) SetSpecSchema(specSchema ChartSpecSchema) {
	b.SpecSchema = specSchema
	b.require(botChartResponseFieldSpecSchema)
}

// SetSpec sets the Spec field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotChartResponse) SetSpec(spec string) {
	b.Spec = spec
	b.require(botChartResponseFieldSpec)
}

func (b *BotChartResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BotChartResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotChartResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotChartResponse) MarshalJSON() ([]byte, error) {
	type embed BotChartResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotChartResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BotConversationMessageType string

const (
	BotConversationMessageTypeBotResponse   BotConversationMessageType = "BOT_RESPONSE"
	BotConversationMessageTypeBotSuggestion BotConversationMessageType = "BOT_SUGGESTION"
)

func NewBotConversationMessageTypeFromString(s string) (BotConversationMessageType, error) {
	switch s {
	case "BOT_RESPONSE":
		return BotConversationMessageTypeBotResponse, nil
	case "BOT_SUGGESTION":
		return BotConversationMessageTypeBotSuggestion, nil
	}
	var t BotConversationMessageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BotConversationMessageType) Ptr() *BotConversationMessageType {
	return &b
}

var (
	botLogicFieldItems = big.NewInt(1 << 0)
)

type BotLogic struct {
	Items []*BotLogicItem `json:"items" url:"items"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogic) GetItems() []*BotLogicItem {
	if b == nil {
		return nil
	}
	return b.Items
}

func (b *BotLogic) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogic) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetItems sets the Items field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogic) SetItems(items []*BotLogicItem) {
	b.Items = items
	b.require(botLogicFieldItems)
}

func (b *BotLogic) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogic
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogic(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogic) MarshalJSON() ([]byte, error) {
	type embed BotLogic
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogic) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicActionExecutedDetailFieldActionID         = big.NewInt(1 << 0)
	botLogicActionExecutedDetailFieldActionName       = big.NewInt(1 << 1)
	botLogicActionExecutedDetailFieldActionParameters = big.NewInt(1 << 2)
	botLogicActionExecutedDetailFieldExecutionResult  = big.NewInt(1 << 3)
	botLogicActionExecutedDetailFieldExecutionError   = big.NewInt(1 << 4)
)

type BotLogicActionExecutedDetail struct {
	ActionID         *EntityIDWithoutAgent                 `json:"actionId" url:"actionId"`
	ActionName       string                                `json:"actionName" url:"actionName"`
	ActionParameters map[string]*ActionExecutionParamValue `json:"actionParameters" url:"actionParameters"`
	ExecutionResult  *string                               `json:"executionResult,omitempty" url:"executionResult,omitempty"`
	ExecutionError   *string                               `json:"executionError,omitempty" url:"executionError,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicActionExecutedDetail) GetActionID() *EntityIDWithoutAgent {
	if b == nil {
		return nil
	}
	return b.ActionID
}

func (b *BotLogicActionExecutedDetail) GetActionName() string {
	if b == nil {
		return ""
	}
	return b.ActionName
}

func (b *BotLogicActionExecutedDetail) GetActionParameters() map[string]*ActionExecutionParamValue {
	if b == nil {
		return nil
	}
	return b.ActionParameters
}

func (b *BotLogicActionExecutedDetail) GetExecutionResult() *string {
	if b == nil {
		return nil
	}
	return b.ExecutionResult
}

func (b *BotLogicActionExecutedDetail) GetExecutionError() *string {
	if b == nil {
		return nil
	}
	return b.ExecutionError
}

func (b *BotLogicActionExecutedDetail) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicActionExecutedDetail) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetActionID sets the ActionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionExecutedDetail) SetActionID(actionID *EntityIDWithoutAgent) {
	b.ActionID = actionID
	b.require(botLogicActionExecutedDetailFieldActionID)
}

// SetActionName sets the ActionName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionExecutedDetail) SetActionName(actionName string) {
	b.ActionName = actionName
	b.require(botLogicActionExecutedDetailFieldActionName)
}

// SetActionParameters sets the ActionParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionExecutedDetail) SetActionParameters(actionParameters map[string]*ActionExecutionParamValue) {
	b.ActionParameters = actionParameters
	b.require(botLogicActionExecutedDetailFieldActionParameters)
}

// SetExecutionResult sets the ExecutionResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionExecutedDetail) SetExecutionResult(executionResult *string) {
	b.ExecutionResult = executionResult
	b.require(botLogicActionExecutedDetailFieldExecutionResult)
}

// SetExecutionError sets the ExecutionError field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionExecutedDetail) SetExecutionError(executionError *string) {
	b.ExecutionError = executionError
	b.require(botLogicActionExecutedDetailFieldExecutionError)
}

func (b *BotLogicActionExecutedDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicActionExecutedDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicActionExecutedDetail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicActionExecutedDetail) MarshalJSON() ([]byte, error) {
	type embed BotLogicActionExecutedDetail
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicActionExecutedDetail) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicActionItemFieldActionsReviewed = big.NewInt(1 << 0)
	botLogicActionItemFieldActionsExecuted = big.NewInt(1 << 1)
)

type BotLogicActionItem struct {
	ActionsReviewed []*BotLogicActionReviewedDetail `json:"actionsReviewed" url:"actionsReviewed"`
	ActionsExecuted []*BotLogicActionExecutedDetail `json:"actionsExecuted" url:"actionsExecuted"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicActionItem) GetActionsReviewed() []*BotLogicActionReviewedDetail {
	if b == nil {
		return nil
	}
	return b.ActionsReviewed
}

func (b *BotLogicActionItem) GetActionsExecuted() []*BotLogicActionExecutedDetail {
	if b == nil {
		return nil
	}
	return b.ActionsExecuted
}

func (b *BotLogicActionItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicActionItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetActionsReviewed sets the ActionsReviewed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionItem) SetActionsReviewed(actionsReviewed []*BotLogicActionReviewedDetail) {
	b.ActionsReviewed = actionsReviewed
	b.require(botLogicActionItemFieldActionsReviewed)
}

// SetActionsExecuted sets the ActionsExecuted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionItem) SetActionsExecuted(actionsExecuted []*BotLogicActionExecutedDetail) {
	b.ActionsExecuted = actionsExecuted
	b.require(botLogicActionItemFieldActionsExecuted)
}

func (b *BotLogicActionItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicActionItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicActionItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicActionItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicActionItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicActionItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicActionReviewedDetailFieldActionID   = big.NewInt(1 << 0)
	botLogicActionReviewedDetailFieldActionName = big.NewInt(1 << 1)
)

type BotLogicActionReviewedDetail struct {
	ActionID   *EntityIDWithoutAgent `json:"actionId" url:"actionId"`
	ActionName string                `json:"actionName" url:"actionName"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicActionReviewedDetail) GetActionID() *EntityIDWithoutAgent {
	if b == nil {
		return nil
	}
	return b.ActionID
}

func (b *BotLogicActionReviewedDetail) GetActionName() string {
	if b == nil {
		return ""
	}
	return b.ActionName
}

func (b *BotLogicActionReviewedDetail) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicActionReviewedDetail) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetActionID sets the ActionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionReviewedDetail) SetActionID(actionID *EntityIDWithoutAgent) {
	b.ActionID = actionID
	b.require(botLogicActionReviewedDetailFieldActionID)
}

// SetActionName sets the ActionName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionReviewedDetail) SetActionName(actionName string) {
	b.ActionName = actionName
	b.require(botLogicActionReviewedDetailFieldActionName)
}

func (b *BotLogicActionReviewedDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicActionReviewedDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicActionReviewedDetail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicActionReviewedDetail) MarshalJSON() ([]byte, error) {
	type embed BotLogicActionReviewedDetail
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicActionReviewedDetail) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicFormSubmissionItemFieldActionID         = big.NewInt(1 << 0)
	botLogicFormSubmissionItemFieldActionName       = big.NewInt(1 << 1)
	botLogicFormSubmissionItemFieldActionParameters = big.NewInt(1 << 2)
	botLogicFormSubmissionItemFieldExecutionResult  = big.NewInt(1 << 3)
	botLogicFormSubmissionItemFieldExecutionError   = big.NewInt(1 << 4)
)

type BotLogicFormSubmissionItem struct {
	ActionID         *EntityIDWithoutAgent                 `json:"actionId" url:"actionId"`
	ActionName       string                                `json:"actionName" url:"actionName"`
	ActionParameters map[string]*ActionExecutionParamValue `json:"actionParameters" url:"actionParameters"`
	ExecutionResult  *string                               `json:"executionResult,omitempty" url:"executionResult,omitempty"`
	ExecutionError   *string                               `json:"executionError,omitempty" url:"executionError,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicFormSubmissionItem) GetActionID() *EntityIDWithoutAgent {
	if b == nil {
		return nil
	}
	return b.ActionID
}

func (b *BotLogicFormSubmissionItem) GetActionName() string {
	if b == nil {
		return ""
	}
	return b.ActionName
}

func (b *BotLogicFormSubmissionItem) GetActionParameters() map[string]*ActionExecutionParamValue {
	if b == nil {
		return nil
	}
	return b.ActionParameters
}

func (b *BotLogicFormSubmissionItem) GetExecutionResult() *string {
	if b == nil {
		return nil
	}
	return b.ExecutionResult
}

func (b *BotLogicFormSubmissionItem) GetExecutionError() *string {
	if b == nil {
		return nil
	}
	return b.ExecutionError
}

func (b *BotLogicFormSubmissionItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicFormSubmissionItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetActionID sets the ActionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicFormSubmissionItem) SetActionID(actionID *EntityIDWithoutAgent) {
	b.ActionID = actionID
	b.require(botLogicFormSubmissionItemFieldActionID)
}

// SetActionName sets the ActionName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicFormSubmissionItem) SetActionName(actionName string) {
	b.ActionName = actionName
	b.require(botLogicFormSubmissionItemFieldActionName)
}

// SetActionParameters sets the ActionParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicFormSubmissionItem) SetActionParameters(actionParameters map[string]*ActionExecutionParamValue) {
	b.ActionParameters = actionParameters
	b.require(botLogicFormSubmissionItemFieldActionParameters)
}

// SetExecutionResult sets the ExecutionResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicFormSubmissionItem) SetExecutionResult(executionResult *string) {
	b.ExecutionResult = executionResult
	b.require(botLogicFormSubmissionItemFieldExecutionResult)
}

// SetExecutionError sets the ExecutionError field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicFormSubmissionItem) SetExecutionError(executionError *string) {
	b.ExecutionError = executionError
	b.require(botLogicFormSubmissionItemFieldExecutionError)
}

func (b *BotLogicFormSubmissionItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicFormSubmissionItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicFormSubmissionItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicFormSubmissionItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicFormSubmissionItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicFormSubmissionItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BotLogicItem struct {
	Type      string
	Knowledge *BotLogicKnowledgeItem
	Actions   *BotLogicActionItem
	Form      *BotLogicFormSubmissionItem
	Safety    *BotLogicSafetyItem
	User      *BotLogicUserItem
	Segments  *BotLogicSegmentsItem
}

func (b *BotLogicItem) GetType() string {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BotLogicItem) GetKnowledge() *BotLogicKnowledgeItem {
	if b == nil {
		return nil
	}
	return b.Knowledge
}

func (b *BotLogicItem) GetActions() *BotLogicActionItem {
	if b == nil {
		return nil
	}
	return b.Actions
}

func (b *BotLogicItem) GetForm() *BotLogicFormSubmissionItem {
	if b == nil {
		return nil
	}
	return b.Form
}

func (b *BotLogicItem) GetSafety() *BotLogicSafetyItem {
	if b == nil {
		return nil
	}
	return b.Safety
}

func (b *BotLogicItem) GetUser() *BotLogicUserItem {
	if b == nil {
		return nil
	}
	return b.User
}

func (b *BotLogicItem) GetSegments() *BotLogicSegmentsItem {
	if b == nil {
		return nil
	}
	return b.Segments
}

func (b *BotLogicItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "knowledge":
		value := new(BotLogicKnowledgeItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Knowledge = value
	case "actions":
		value := new(BotLogicActionItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Actions = value
	case "form":
		value := new(BotLogicFormSubmissionItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Form = value
	case "safety":
		value := new(BotLogicSafetyItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Safety = value
	case "user":
		value := new(BotLogicUserItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.User = value
	case "segments":
		value := new(BotLogicSegmentsItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Segments = value
	}
	return nil
}

func (b BotLogicItem) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	if b.Knowledge != nil {
		return internal.MarshalJSONWithExtraProperty(b.Knowledge, "type", "knowledge")
	}
	if b.Actions != nil {
		return internal.MarshalJSONWithExtraProperty(b.Actions, "type", "actions")
	}
	if b.Form != nil {
		return internal.MarshalJSONWithExtraProperty(b.Form, "type", "form")
	}
	if b.Safety != nil {
		return internal.MarshalJSONWithExtraProperty(b.Safety, "type", "safety")
	}
	if b.User != nil {
		return internal.MarshalJSONWithExtraProperty(b.User, "type", "user")
	}
	if b.Segments != nil {
		return internal.MarshalJSONWithExtraProperty(b.Segments, "type", "segments")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BotLogicItemVisitor interface {
	VisitKnowledge(*BotLogicKnowledgeItem) error
	VisitActions(*BotLogicActionItem) error
	VisitForm(*BotLogicFormSubmissionItem) error
	VisitSafety(*BotLogicSafetyItem) error
	VisitUser(*BotLogicUserItem) error
	VisitSegments(*BotLogicSegmentsItem) error
}

func (b *BotLogicItem) Accept(visitor BotLogicItemVisitor) error {
	if b.Knowledge != nil {
		return visitor.VisitKnowledge(b.Knowledge)
	}
	if b.Actions != nil {
		return visitor.VisitActions(b.Actions)
	}
	if b.Form != nil {
		return visitor.VisitForm(b.Form)
	}
	if b.Safety != nil {
		return visitor.VisitSafety(b.Safety)
	}
	if b.User != nil {
		return visitor.VisitUser(b.User)
	}
	if b.Segments != nil {
		return visitor.VisitSegments(b.Segments)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

func (b *BotLogicItem) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Knowledge != nil {
		fields = append(fields, "knowledge")
	}
	if b.Actions != nil {
		fields = append(fields, "actions")
	}
	if b.Form != nil {
		fields = append(fields, "form")
	}
	if b.Safety != nil {
		fields = append(fields, "safety")
	}
	if b.User != nil {
		fields = append(fields, "user")
	}
	if b.Segments != nil {
		fields = append(fields, "segments")
	}
	if len(fields) == 0 {
		if b.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Type)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Type != "" {
		field := fields[0]
		if b.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Type,
				b,
			)
		}
	}
	return nil
}

var (
	botLogicKnowledgeDetailFieldKnowledgeBaseID = big.NewInt(1 << 0)
	botLogicKnowledgeDetailFieldDocumentID      = big.NewInt(1 << 1)
	botLogicKnowledgeDetailFieldDocumentName    = big.NewInt(1 << 2)
	botLogicKnowledgeDetailFieldDocumentExcerpt = big.NewInt(1 << 3)
)

type BotLogicKnowledgeDetail struct {
	KnowledgeBaseID *EntityIDWithoutAgent `json:"knowledgeBaseId" url:"knowledgeBaseId"`
	DocumentID      *EntityIDWithoutAgent `json:"documentId" url:"documentId"`
	DocumentName    string                `json:"documentName" url:"documentName"`
	DocumentExcerpt string                `json:"documentExcerpt" url:"documentExcerpt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicKnowledgeDetail) GetKnowledgeBaseID() *EntityIDWithoutAgent {
	if b == nil {
		return nil
	}
	return b.KnowledgeBaseID
}

func (b *BotLogicKnowledgeDetail) GetDocumentID() *EntityIDWithoutAgent {
	if b == nil {
		return nil
	}
	return b.DocumentID
}

func (b *BotLogicKnowledgeDetail) GetDocumentName() string {
	if b == nil {
		return ""
	}
	return b.DocumentName
}

func (b *BotLogicKnowledgeDetail) GetDocumentExcerpt() string {
	if b == nil {
		return ""
	}
	return b.DocumentExcerpt
}

func (b *BotLogicKnowledgeDetail) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicKnowledgeDetail) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetKnowledgeBaseID sets the KnowledgeBaseID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeDetail) SetKnowledgeBaseID(knowledgeBaseID *EntityIDWithoutAgent) {
	b.KnowledgeBaseID = knowledgeBaseID
	b.require(botLogicKnowledgeDetailFieldKnowledgeBaseID)
}

// SetDocumentID sets the DocumentID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeDetail) SetDocumentID(documentID *EntityIDWithoutAgent) {
	b.DocumentID = documentID
	b.require(botLogicKnowledgeDetailFieldDocumentID)
}

// SetDocumentName sets the DocumentName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeDetail) SetDocumentName(documentName string) {
	b.DocumentName = documentName
	b.require(botLogicKnowledgeDetailFieldDocumentName)
}

// SetDocumentExcerpt sets the DocumentExcerpt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeDetail) SetDocumentExcerpt(documentExcerpt string) {
	b.DocumentExcerpt = documentExcerpt
	b.require(botLogicKnowledgeDetailFieldDocumentExcerpt)
}

func (b *BotLogicKnowledgeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicKnowledgeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicKnowledgeDetail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicKnowledgeDetail) MarshalJSON() ([]byte, error) {
	type embed BotLogicKnowledgeDetail
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicKnowledgeDetail) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicKnowledgeItemFieldKnowledgeReviewed = big.NewInt(1 << 0)
	botLogicKnowledgeItemFieldKnowledgeUtilized = big.NewInt(1 << 1)
)

type BotLogicKnowledgeItem struct {
	KnowledgeReviewed []*BotLogicKnowledgeDetail `json:"knowledgeReviewed" url:"knowledgeReviewed"`
	KnowledgeUtilized []*BotLogicKnowledgeDetail `json:"knowledgeUtilized" url:"knowledgeUtilized"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicKnowledgeItem) GetKnowledgeReviewed() []*BotLogicKnowledgeDetail {
	if b == nil {
		return nil
	}
	return b.KnowledgeReviewed
}

func (b *BotLogicKnowledgeItem) GetKnowledgeUtilized() []*BotLogicKnowledgeDetail {
	if b == nil {
		return nil
	}
	return b.KnowledgeUtilized
}

func (b *BotLogicKnowledgeItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicKnowledgeItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetKnowledgeReviewed sets the KnowledgeReviewed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeItem) SetKnowledgeReviewed(knowledgeReviewed []*BotLogicKnowledgeDetail) {
	b.KnowledgeReviewed = knowledgeReviewed
	b.require(botLogicKnowledgeItemFieldKnowledgeReviewed)
}

// SetKnowledgeUtilized sets the KnowledgeUtilized field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeItem) SetKnowledgeUtilized(knowledgeUtilized []*BotLogicKnowledgeDetail) {
	b.KnowledgeUtilized = knowledgeUtilized
	b.require(botLogicKnowledgeItemFieldKnowledgeUtilized)
}

func (b *BotLogicKnowledgeItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicKnowledgeItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicKnowledgeItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicKnowledgeItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicKnowledgeItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicKnowledgeItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicSafetyItemFieldSafetyCheckPassed = big.NewInt(1 << 0)
	botLogicSafetyItemFieldReport            = big.NewInt(1 << 1)
)

type BotLogicSafetyItem struct {
	SafetyCheckPassed bool `json:"safetyCheckPassed" url:"safetyCheckPassed"`
	// If the safety check failed, this contains more details about the failure.
	Report *SafetyCheckReport `json:"report,omitempty" url:"report,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicSafetyItem) GetSafetyCheckPassed() bool {
	if b == nil {
		return false
	}
	return b.SafetyCheckPassed
}

func (b *BotLogicSafetyItem) GetReport() *SafetyCheckReport {
	if b == nil {
		return nil
	}
	return b.Report
}

func (b *BotLogicSafetyItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicSafetyItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetSafetyCheckPassed sets the SafetyCheckPassed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicSafetyItem) SetSafetyCheckPassed(safetyCheckPassed bool) {
	b.SafetyCheckPassed = safetyCheckPassed
	b.require(botLogicSafetyItemFieldSafetyCheckPassed)
}

// SetReport sets the Report field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicSafetyItem) SetReport(report *SafetyCheckReport) {
	b.Report = report
	b.require(botLogicSafetyItemFieldReport)
}

func (b *BotLogicSafetyItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicSafetyItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicSafetyItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicSafetyItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicSafetyItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicSafetyItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicSegmentsItemFieldMatchingSegmentIDs = big.NewInt(1 << 0)
)

type BotLogicSegmentsItem struct {
	MatchingSegmentIDs []*EntityID `json:"matchingSegmentIds" url:"matchingSegmentIds"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicSegmentsItem) GetMatchingSegmentIDs() []*EntityID {
	if b == nil {
		return nil
	}
	return b.MatchingSegmentIDs
}

func (b *BotLogicSegmentsItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicSegmentsItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetMatchingSegmentIDs sets the MatchingSegmentIDs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicSegmentsItem) SetMatchingSegmentIDs(matchingSegmentIDs []*EntityID) {
	b.MatchingSegmentIDs = matchingSegmentIDs
	b.require(botLogicSegmentsItemFieldMatchingSegmentIDs)
}

func (b *BotLogicSegmentsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicSegmentsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicSegmentsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicSegmentsItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicSegmentsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicSegmentsItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicUserItemFieldUserData = big.NewInt(1 << 0)
)

type BotLogicUserItem struct {
	UserData map[string]string `json:"userData" url:"userData"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicUserItem) GetUserData() map[string]string {
	if b == nil {
		return nil
	}
	return b.UserData
}

func (b *BotLogicUserItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicUserItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserData sets the UserData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicUserItem) SetUserData(userData map[string]string) {
	b.UserData = userData
	b.require(botLogicUserItemFieldUserData)
}

func (b *BotLogicUserItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicUserItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicUserItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicUserItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicUserItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicUserItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botMessageFieldCreatedAt             = big.NewInt(1 << 0)
	botMessageFieldUpdatedAt             = big.NewInt(1 << 1)
	botMessageFieldConversationMessageID = big.NewInt(1 << 2)
	botMessageFieldBotMessageType        = big.NewInt(1 << 3)
	botMessageFieldResponses             = big.NewInt(1 << 4)
	botMessageFieldMetadata              = big.NewInt(1 << 5)
	botMessageFieldStatus                = big.NewInt(1 << 6)
	botMessageFieldLogic                 = big.NewInt(1 << 7)
)

type BotMessage struct {
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// The ID that uniquely identifies this message within the conversation
	ConversationMessageID *EntityID                  `json:"conversationMessageId" url:"conversationMessageId"`
	BotMessageType        BotConversationMessageType `json:"botMessageType" url:"botMessageType"`
	Responses             []*BotResponse             `json:"responses" url:"responses"`
	Metadata              *BotResponseMetadata       `json:"metadata" url:"metadata"`
	Status                MessageStatus              `json:"status" url:"status"`
	// The logic that was used to generate the response. Response size may be large; only present on the getConversation request.
	Logic *BotLogic `json:"logic,omitempty" url:"logic,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotMessage) GetCreatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BotMessage) GetUpdatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.UpdatedAt
}

func (b *BotMessage) GetConversationMessageID() *EntityID {
	if b == nil {
		return nil
	}
	return b.ConversationMessageID
}

func (b *BotMessage) GetBotMessageType() BotConversationMessageType {
	if b == nil {
		return ""
	}
	return b.BotMessageType
}

func (b *BotMessage) GetResponses() []*BotResponse {
	if b == nil {
		return nil
	}
	return b.Responses
}

func (b *BotMessage) GetMetadata() *BotResponseMetadata {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BotMessage) GetStatus() MessageStatus {
	if b == nil {
		return ""
	}
	return b.Status
}

func (b *BotMessage) GetLogic() *BotLogic {
	if b == nil {
		return nil
	}
	return b.Logic
}

func (b *BotMessage) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotMessage) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetCreatedAt(createdAt *time.Time) {
	b.CreatedAt = createdAt
	b.require(botMessageFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetUpdatedAt(updatedAt *time.Time) {
	b.UpdatedAt = updatedAt
	b.require(botMessageFieldUpdatedAt)
}

// SetConversationMessageID sets the ConversationMessageID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetConversationMessageID(conversationMessageID *EntityID) {
	b.ConversationMessageID = conversationMessageID
	b.require(botMessageFieldConversationMessageID)
}

// SetBotMessageType sets the BotMessageType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetBotMessageType(botMessageType BotConversationMessageType) {
	b.BotMessageType = botMessageType
	b.require(botMessageFieldBotMessageType)
}

// SetResponses sets the Responses field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetResponses(responses []*BotResponse) {
	b.Responses = responses
	b.require(botMessageFieldResponses)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetMetadata(metadata *BotResponseMetadata) {
	b.Metadata = metadata
	b.require(botMessageFieldMetadata)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetStatus(status MessageStatus) {
	b.Status = status
	b.require(botMessageFieldStatus)
}

// SetLogic sets the Logic field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetLogic(logic *BotLogic) {
	b.Logic = logic
	b.require(botMessageFieldLogic)
}

func (b *BotMessage) UnmarshalJSON(data []byte) error {
	type embed BotMessage
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BotMessage(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotMessage) MarshalJSON() ([]byte, error) {
	type embed BotMessage
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewOptionalDateTime(b.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(b.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotMessage) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// This response should be rendered as a single button that starts an OAuth authorization flow.
var (
	botOAuthButtonResponseFieldButtonName = big.NewInt(1 << 0)
	botOAuthButtonResponseFieldURL        = big.NewInt(1 << 1)
)

type BotOAuthButtonResponse struct {
	// Text that should be displayed to the user on the button.
	ButtonName string `json:"buttonName" url:"buttonName"`
	// The OAuth authorization URL to open when the button is clicked. Will only be provided on ask responses.
	URL *string `json:"url,omitempty" url:"url,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotOAuthButtonResponse) GetButtonName() string {
	if b == nil {
		return ""
	}
	return b.ButtonName
}

func (b *BotOAuthButtonResponse) GetURL() *string {
	if b == nil {
		return nil
	}
	return b.URL
}

func (b *BotOAuthButtonResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotOAuthButtonResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetButtonName sets the ButtonName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotOAuthButtonResponse) SetButtonName(buttonName string) {
	b.ButtonName = buttonName
	b.require(botOAuthButtonResponseFieldButtonName)
}

// SetURL sets the URL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotOAuthButtonResponse) SetURL(url *string) {
	b.URL = url
	b.require(botOAuthButtonResponseFieldURL)
}

func (b *BotOAuthButtonResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BotOAuthButtonResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotOAuthButtonResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotOAuthButtonResponse) MarshalJSON() ([]byte, error) {
	type embed BotOAuthButtonResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotOAuthButtonResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A structured object generated by the bot in response to a schema-based generateObject request. Should be rendered as JSON.
var (
	botObjectResponseFieldLabel  = big.NewInt(1 << 0)
	botObjectResponseFieldObject = big.NewInt(1 << 1)
)

type BotObjectResponse struct {
	// A human-readable name for the generated object, for use in the UI.
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// The generated object conforming to the provided schema.
	Object interface{} `json:"object" url:"object"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotObjectResponse) GetLabel() *string {
	if b == nil {
		return nil
	}
	return b.Label
}

func (b *BotObjectResponse) GetObject() interface{} {
	if b == nil {
		return nil
	}
	return b.Object
}

func (b *BotObjectResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotObjectResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotObjectResponse) SetLabel(label *string) {
	b.Label = label
	b.require(botObjectResponseFieldLabel)
}

// SetObject sets the Object field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotObjectResponse) SetObject(object interface{}) {
	b.Object = object
	b.require(botObjectResponseFieldObject)
}

func (b *BotObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BotObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotObjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotObjectResponse) MarshalJSON() ([]byte, error) {
	type embed BotObjectResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotObjectResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BotResponse struct {
	Type        string
	Text        *BotTextResponse
	ActionForm  *BotActionFormResponse
	OauthButton *BotOAuthButtonResponse
	Chart       *BotChartResponse
	Object      *BotObjectResponse
}

func (b *BotResponse) GetType() string {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BotResponse) GetText() *BotTextResponse {
	if b == nil {
		return nil
	}
	return b.Text
}

func (b *BotResponse) GetActionForm() *BotActionFormResponse {
	if b == nil {
		return nil
	}
	return b.ActionForm
}

func (b *BotResponse) GetOauthButton() *BotOAuthButtonResponse {
	if b == nil {
		return nil
	}
	return b.OauthButton
}

func (b *BotResponse) GetChart() *BotChartResponse {
	if b == nil {
		return nil
	}
	return b.Chart
}

func (b *BotResponse) GetObject() *BotObjectResponse {
	if b == nil {
		return nil
	}
	return b.Object
}

func (b *BotResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(BotTextResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Text = value
	case "actionForm":
		value := new(BotActionFormResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.ActionForm = value
	case "oauthButton":
		value := new(BotOAuthButtonResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.OauthButton = value
	case "chart":
		value := new(BotChartResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Chart = value
	case "object":
		value := new(BotObjectResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Object = value
	}
	return nil
}

func (b BotResponse) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	if b.Text != nil {
		return internal.MarshalJSONWithExtraProperty(b.Text, "type", "text")
	}
	if b.ActionForm != nil {
		return internal.MarshalJSONWithExtraProperty(b.ActionForm, "type", "actionForm")
	}
	if b.OauthButton != nil {
		return internal.MarshalJSONWithExtraProperty(b.OauthButton, "type", "oauthButton")
	}
	if b.Chart != nil {
		return internal.MarshalJSONWithExtraProperty(b.Chart, "type", "chart")
	}
	if b.Object != nil {
		return internal.MarshalJSONWithExtraProperty(b.Object, "type", "object")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BotResponseVisitor interface {
	VisitText(*BotTextResponse) error
	VisitActionForm(*BotActionFormResponse) error
	VisitOauthButton(*BotOAuthButtonResponse) error
	VisitChart(*BotChartResponse) error
	VisitObject(*BotObjectResponse) error
}

func (b *BotResponse) Accept(visitor BotResponseVisitor) error {
	if b.Text != nil {
		return visitor.VisitText(b.Text)
	}
	if b.ActionForm != nil {
		return visitor.VisitActionForm(b.ActionForm)
	}
	if b.OauthButton != nil {
		return visitor.VisitOauthButton(b.OauthButton)
	}
	if b.Chart != nil {
		return visitor.VisitChart(b.Chart)
	}
	if b.Object != nil {
		return visitor.VisitObject(b.Object)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

func (b *BotResponse) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Text != nil {
		fields = append(fields, "text")
	}
	if b.ActionForm != nil {
		fields = append(fields, "actionForm")
	}
	if b.OauthButton != nil {
		fields = append(fields, "oauthButton")
	}
	if b.Chart != nil {
		fields = append(fields, "chart")
	}
	if b.Object != nil {
		fields = append(fields, "object")
	}
	if len(fields) == 0 {
		if b.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Type)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Type != "" {
		field := fields[0]
		if b.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Type,
				b,
			)
		}
	}
	return nil
}

var (
	botResponseMetadataFieldFollowupQuestions = big.NewInt(1 << 0)
	botResponseMetadataFieldSources           = big.NewInt(1 << 1)
	botResponseMetadataFieldLanguage          = big.NewInt(1 << 2)
)

type BotResponseMetadata struct {
	FollowupQuestions []string  `json:"followupQuestions" url:"followupQuestions"`
	Sources           []*Source `json:"sources" url:"sources"`
	// The language of the message in ISO 639-1 code format
	Language *string `json:"language,omitempty" url:"language,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotResponseMetadata) GetFollowupQuestions() []string {
	if b == nil {
		return nil
	}
	return b.FollowupQuestions
}

func (b *BotResponseMetadata) GetSources() []*Source {
	if b == nil {
		return nil
	}
	return b.Sources
}

func (b *BotResponseMetadata) GetLanguage() *string {
	if b == nil {
		return nil
	}
	return b.Language
}

func (b *BotResponseMetadata) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotResponseMetadata) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetFollowupQuestions sets the FollowupQuestions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotResponseMetadata) SetFollowupQuestions(followupQuestions []string) {
	b.FollowupQuestions = followupQuestions
	b.require(botResponseMetadataFieldFollowupQuestions)
}

// SetSources sets the Sources field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotResponseMetadata) SetSources(sources []*Source) {
	b.Sources = sources
	b.require(botResponseMetadataFieldSources)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotResponseMetadata) SetLanguage(language *string) {
	b.Language = language
	b.require(botResponseMetadataFieldLanguage)
}

func (b *BotResponseMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler BotResponseMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotResponseMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotResponseMetadata) MarshalJSON() ([]byte, error) {
	type embed BotResponseMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotResponseMetadata) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A text answer to the user's question. Should be rendered to the user.
var (
	botTextResponseFieldText = big.NewInt(1 << 0)
)

type BotTextResponse struct {
	Text string `json:"text" url:"text"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotTextResponse) GetText() string {
	if b == nil {
		return ""
	}
	return b.Text
}

func (b *BotTextResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotTextResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotTextResponse) SetText(text string) {
	b.Text = text
	b.require(botTextResponseFieldText)
}

func (b *BotTextResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BotTextResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotTextResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotTextResponse) MarshalJSON() ([]byte, error) {
	type embed BotTextResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotTextResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	browserInfoFieldType      = big.NewInt(1 << 0)
	browserInfoFieldName      = big.NewInt(1 << 1)
	browserInfoFieldVersion   = big.NewInt(1 << 2)
	browserInfoFieldUserAgent = big.NewInt(1 << 3)
)

type BrowserInfo struct {
	Type      BrowserType `json:"type" url:"type"`
	Name      *string     `json:"name,omitempty" url:"name,omitempty"`
	Version   *string     `json:"version,omitempty" url:"version,omitempty"`
	UserAgent *string     `json:"userAgent,omitempty" url:"userAgent,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BrowserInfo) GetType() BrowserType {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BrowserInfo) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *BrowserInfo) GetVersion() *string {
	if b == nil {
		return nil
	}
	return b.Version
}

func (b *BrowserInfo) GetUserAgent() *string {
	if b == nil {
		return nil
	}
	return b.UserAgent
}

func (b *BrowserInfo) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BrowserInfo) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfo) SetType(type_ BrowserType) {
	b.Type = type_
	b.require(browserInfoFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfo) SetName(name *string) {
	b.Name = name
	b.require(browserInfoFieldName)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfo) SetVersion(version *string) {
	b.Version = version
	b.require(browserInfoFieldVersion)
}

// SetUserAgent sets the UserAgent field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfo) SetUserAgent(userAgent *string) {
	b.UserAgent = userAgent
	b.require(browserInfoFieldUserAgent)
}

func (b *BrowserInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler BrowserInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrowserInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrowserInfo) MarshalJSON() ([]byte, error) {
	type embed BrowserInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BrowserInfo) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrowserType string

const (
	BrowserTypeChrome  BrowserType = "CHROME"
	BrowserTypeFirefox BrowserType = "FIREFOX"
	BrowserTypeSafari  BrowserType = "SAFARI"
	BrowserTypeOpera   BrowserType = "OPERA"
	BrowserTypeEdge    BrowserType = "EDGE"
	BrowserTypeOther   BrowserType = "OTHER"
)

func NewBrowserTypeFromString(s string) (BrowserType, error) {
	switch s {
	case "CHROME":
		return BrowserTypeChrome, nil
	case "FIREFOX":
		return BrowserTypeFirefox, nil
	case "SAFARI":
		return BrowserTypeSafari, nil
	case "OPERA":
		return BrowserTypeOpera, nil
	case "EDGE":
		return BrowserTypeEdge, nil
	case "OTHER":
		return BrowserTypeOther, nil
	}
	var t BrowserType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BrowserType) Ptr() *BrowserType {
	return &b
}

type Capability string

const (
	CapabilityMarkdown           Capability = "MARKDOWN"
	CapabilityForms              Capability = "FORMS"
	CapabilityImages             Capability = "IMAGES"
	CapabilityChartsHighchartsTs Capability = "CHARTS_HIGHCHARTS_TS"
	CapabilityAsync              Capability = "ASYNC"
	CapabilityOauthButtons       Capability = "OAUTH_BUTTONS"
)

func NewCapabilityFromString(s string) (Capability, error) {
	switch s {
	case "MARKDOWN":
		return CapabilityMarkdown, nil
	case "FORMS":
		return CapabilityForms, nil
	case "IMAGES":
		return CapabilityImages, nil
	case "CHARTS_HIGHCHARTS_TS":
		return CapabilityChartsHighchartsTs, nil
	case "ASYNC":
		return CapabilityAsync, nil
	case "OAUTH_BUTTONS":
		return CapabilityOauthButtons, nil
	}
	var t Capability
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Capability) Ptr() *Capability {
	return &c
}

type ChartSpecSchema string

const (
	ChartSpecSchemaHighchartsTs ChartSpecSchema = "HIGHCHARTS_TS"
)

func NewChartSpecSchemaFromString(s string) (ChartSpecSchema, error) {
	switch s {
	case "HIGHCHARTS_TS":
		return ChartSpecSchemaHighchartsTs, nil
	}
	var t ChartSpecSchema
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChartSpecSchema) Ptr() *ChartSpecSchema {
	return &c
}

var (
	checkboxSettingsSchemaEntryFieldKey          = big.NewInt(1 << 0)
	checkboxSettingsSchemaEntryFieldDisplayName  = big.NewInt(1 << 1)
	checkboxSettingsSchemaEntryFieldDescription  = big.NewInt(1 << 2)
	checkboxSettingsSchemaEntryFieldVisibility   = big.NewInt(1 << 3)
	checkboxSettingsSchemaEntryFieldRequired     = big.NewInt(1 << 4)
	checkboxSettingsSchemaEntryFieldDefaultValue = big.NewInt(1 << 5)
)

type CheckboxSettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required     *bool `json:"required,omitempty" url:"required,omitempty"`
	DefaultValue *bool `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CheckboxSettingsSchemaEntry) GetKey() string {
	if c == nil {
		return ""
	}
	return c.Key
}

func (c *CheckboxSettingsSchemaEntry) GetDisplayName() string {
	if c == nil {
		return ""
	}
	return c.DisplayName
}

func (c *CheckboxSettingsSchemaEntry) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *CheckboxSettingsSchemaEntry) GetVisibility() *VisibilityType {
	if c == nil {
		return nil
	}
	return c.Visibility
}

func (c *CheckboxSettingsSchemaEntry) GetRequired() *bool {
	if c == nil {
		return nil
	}
	return c.Required
}

func (c *CheckboxSettingsSchemaEntry) GetDefaultValue() *bool {
	if c == nil {
		return nil
	}
	return c.DefaultValue
}

func (c *CheckboxSettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CheckboxSettingsSchemaEntry) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CheckboxSettingsSchemaEntry) SetKey(key string) {
	c.Key = key
	c.require(checkboxSettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CheckboxSettingsSchemaEntry) SetDisplayName(displayName string) {
	c.DisplayName = displayName
	c.require(checkboxSettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CheckboxSettingsSchemaEntry) SetDescription(description *string) {
	c.Description = description
	c.require(checkboxSettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CheckboxSettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	c.Visibility = visibility
	c.require(checkboxSettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CheckboxSettingsSchemaEntry) SetRequired(required *bool) {
	c.Required = required
	c.require(checkboxSettingsSchemaEntryFieldRequired)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CheckboxSettingsSchemaEntry) SetDefaultValue(defaultValue *bool) {
	c.DefaultValue = defaultValue
	c.require(checkboxSettingsSchemaEntryFieldDefaultValue)
}

func (c *CheckboxSettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler CheckboxSettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CheckboxSettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CheckboxSettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed CheckboxSettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CheckboxSettingsSchemaEntry) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	colorSettingsSchemaEntryFieldKey          = big.NewInt(1 << 0)
	colorSettingsSchemaEntryFieldDisplayName  = big.NewInt(1 << 1)
	colorSettingsSchemaEntryFieldDescription  = big.NewInt(1 << 2)
	colorSettingsSchemaEntryFieldVisibility   = big.NewInt(1 << 3)
	colorSettingsSchemaEntryFieldRequired     = big.NewInt(1 << 4)
	colorSettingsSchemaEntryFieldDefaultValue = big.NewInt(1 << 5)
	colorSettingsSchemaEntryFieldValidation   = big.NewInt(1 << 6)
)

type ColorSettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required     *bool                     `json:"required,omitempty" url:"required,omitempty"`
	DefaultValue *string                   `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	Validation   *SettingsSchemaValidation `json:"validation,omitempty" url:"validation,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ColorSettingsSchemaEntry) GetKey() string {
	if c == nil {
		return ""
	}
	return c.Key
}

func (c *ColorSettingsSchemaEntry) GetDisplayName() string {
	if c == nil {
		return ""
	}
	return c.DisplayName
}

func (c *ColorSettingsSchemaEntry) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ColorSettingsSchemaEntry) GetVisibility() *VisibilityType {
	if c == nil {
		return nil
	}
	return c.Visibility
}

func (c *ColorSettingsSchemaEntry) GetRequired() *bool {
	if c == nil {
		return nil
	}
	return c.Required
}

func (c *ColorSettingsSchemaEntry) GetDefaultValue() *string {
	if c == nil {
		return nil
	}
	return c.DefaultValue
}

func (c *ColorSettingsSchemaEntry) GetValidation() *SettingsSchemaValidation {
	if c == nil {
		return nil
	}
	return c.Validation
}

func (c *ColorSettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ColorSettingsSchemaEntry) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ColorSettingsSchemaEntry) SetKey(key string) {
	c.Key = key
	c.require(colorSettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ColorSettingsSchemaEntry) SetDisplayName(displayName string) {
	c.DisplayName = displayName
	c.require(colorSettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ColorSettingsSchemaEntry) SetDescription(description *string) {
	c.Description = description
	c.require(colorSettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ColorSettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	c.Visibility = visibility
	c.require(colorSettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ColorSettingsSchemaEntry) SetRequired(required *bool) {
	c.Required = required
	c.require(colorSettingsSchemaEntryFieldRequired)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ColorSettingsSchemaEntry) SetDefaultValue(defaultValue *string) {
	c.DefaultValue = defaultValue
	c.require(colorSettingsSchemaEntryFieldDefaultValue)
}

// SetValidation sets the Validation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ColorSettingsSchemaEntry) SetValidation(validation *SettingsSchemaValidation) {
	c.Validation = validation
	c.require(colorSettingsSchemaEntryFieldValidation)
}

func (c *ColorSettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler ColorSettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ColorSettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ColorSettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed ColorSettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ColorSettingsSchemaEntry) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	complexArraySettingsSchemaEntryFieldKey         = big.NewInt(1 << 0)
	complexArraySettingsSchemaEntryFieldDisplayName = big.NewInt(1 << 1)
	complexArraySettingsSchemaEntryFieldDescription = big.NewInt(1 << 2)
	complexArraySettingsSchemaEntryFieldVisibility  = big.NewInt(1 << 3)
	complexArraySettingsSchemaEntryFieldRequired    = big.NewInt(1 << 4)
	complexArraySettingsSchemaEntryFieldFields      = big.NewInt(1 << 5)
)

type ComplexArraySettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required *bool           `json:"required,omitempty" url:"required,omitempty"`
	Fields   *SettingsSchema `json:"fields,omitempty" url:"fields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ComplexArraySettingsSchemaEntry) GetKey() string {
	if c == nil {
		return ""
	}
	return c.Key
}

func (c *ComplexArraySettingsSchemaEntry) GetDisplayName() string {
	if c == nil {
		return ""
	}
	return c.DisplayName
}

func (c *ComplexArraySettingsSchemaEntry) GetDescription() *string {
	if c == nil {
		return nil
	}
	return c.Description
}

func (c *ComplexArraySettingsSchemaEntry) GetVisibility() *VisibilityType {
	if c == nil {
		return nil
	}
	return c.Visibility
}

func (c *ComplexArraySettingsSchemaEntry) GetRequired() *bool {
	if c == nil {
		return nil
	}
	return c.Required
}

func (c *ComplexArraySettingsSchemaEntry) GetFields() *SettingsSchema {
	if c == nil {
		return nil
	}
	return c.Fields
}

func (c *ComplexArraySettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ComplexArraySettingsSchemaEntry) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComplexArraySettingsSchemaEntry) SetKey(key string) {
	c.Key = key
	c.require(complexArraySettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComplexArraySettingsSchemaEntry) SetDisplayName(displayName string) {
	c.DisplayName = displayName
	c.require(complexArraySettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComplexArraySettingsSchemaEntry) SetDescription(description *string) {
	c.Description = description
	c.require(complexArraySettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComplexArraySettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	c.Visibility = visibility
	c.require(complexArraySettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComplexArraySettingsSchemaEntry) SetRequired(required *bool) {
	c.Required = required
	c.require(complexArraySettingsSchemaEntryFieldRequired)
}

// SetFields sets the Fields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ComplexArraySettingsSchemaEntry) SetFields(fields *SettingsSchema) {
	c.Fields = fields
	c.require(complexArraySettingsSchemaEntryFieldFields)
}

func (c *ComplexArraySettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler ComplexArraySettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ComplexArraySettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ComplexArraySettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed ComplexArraySettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ComplexArraySettingsSchemaEntry) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	contextInfoFieldAdditionalData = big.NewInt(1 << 0)
)

type ContextInfo struct {
	AdditionalData map[string]string `json:"additionalData" url:"additionalData"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextInfo) GetAdditionalData() map[string]string {
	if c == nil {
		return nil
	}
	return c.AdditionalData
}

func (c *ContextInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextInfo) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetAdditionalData sets the AdditionalData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInfo) SetAdditionalData(additionalData map[string]string) {
	c.AdditionalData = additionalData
	c.require(contextInfoFieldAdditionalData)
}

func (c *ContextInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextInfo) MarshalJSON() ([]byte, error) {
	type embed ContextInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextInfo) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationAnalysisFieldUserRequest            = big.NewInt(1 << 0)
	conversationAnalysisFieldAgentResponse          = big.NewInt(1 << 1)
	conversationAnalysisFieldResolutionStatus       = big.NewInt(1 << 2)
	conversationAnalysisFieldCategory               = big.NewInt(1 << 3)
	conversationAnalysisFieldSentiment              = big.NewInt(1 << 4)
	conversationAnalysisFieldQuality                = big.NewInt(1 << 5)
	conversationAnalysisFieldQualityReason          = big.NewInt(1 << 6)
	conversationAnalysisFieldResolvedByMaven        = big.NewInt(1 << 7)
	conversationAnalysisFieldPrimaryLanguage        = big.NewInt(1 << 8)
	conversationAnalysisFieldPredictedNps           = big.NewInt(1 << 9)
	conversationAnalysisFieldCsat                   = big.NewInt(1 << 10)
	conversationAnalysisFieldIntelligentFieldValues = big.NewInt(1 << 11)
)

type ConversationAnalysis struct {
	// Generated user request summary of the conversation
	UserRequest *string `json:"userRequest,omitempty" url:"userRequest,omitempty"`
	// Generated agent response summary of the conversation
	AgentResponse *string `json:"agentResponse,omitempty" url:"agentResponse,omitempty"`
	// Generated resolution status of the conversation
	ResolutionStatus *string `json:"resolutionStatus,omitempty" url:"resolutionStatus,omitempty"`
	// Generated category of the conversation
	Category *string `json:"category,omitempty" url:"category,omitempty"`
	// Generated sentiment of the conversation
	Sentiment *Sentiment `json:"sentiment,omitempty" url:"sentiment,omitempty"`
	// Generated quality of the conversation
	Quality *Quality `json:"quality,omitempty" url:"quality,omitempty"`
	// If the quality of the conversation is `UNKNOWN` or `NEEDS_IMPROVEMENT` then a reason for the quality will be provided when possible.
	QualityReason *QualityReason `json:"qualityReason,omitempty" url:"qualityReason,omitempty"`
	// Whether the conversation was resolved by Maven
	ResolvedByMaven *bool `json:"resolvedByMaven,omitempty" url:"resolvedByMaven,omitempty"`
	// Primary language of the conversation in ISO 639-1 code format
	PrimaryLanguage *string `json:"primaryLanguage,omitempty" url:"primaryLanguage,omitempty"`
	// The predicted NPS of the conversation.
	PredictedNps *float64 `json:"predictedNps,omitempty" url:"predictedNps,omitempty"`
	// The CSAT of the conversation.
	Csat *float64 `json:"csat,omitempty" url:"csat,omitempty"`
	// Latest successful intelligent field values
	IntelligentFieldValues []*IntelligentFieldValueResponse `json:"intelligentFieldValues,omitempty" url:"intelligentFieldValues,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationAnalysis) GetUserRequest() *string {
	if c == nil {
		return nil
	}
	return c.UserRequest
}

func (c *ConversationAnalysis) GetAgentResponse() *string {
	if c == nil {
		return nil
	}
	return c.AgentResponse
}

func (c *ConversationAnalysis) GetResolutionStatus() *string {
	if c == nil {
		return nil
	}
	return c.ResolutionStatus
}

func (c *ConversationAnalysis) GetCategory() *string {
	if c == nil {
		return nil
	}
	return c.Category
}

func (c *ConversationAnalysis) GetSentiment() *Sentiment {
	if c == nil {
		return nil
	}
	return c.Sentiment
}

func (c *ConversationAnalysis) GetQuality() *Quality {
	if c == nil {
		return nil
	}
	return c.Quality
}

func (c *ConversationAnalysis) GetQualityReason() *QualityReason {
	if c == nil {
		return nil
	}
	return c.QualityReason
}

func (c *ConversationAnalysis) GetResolvedByMaven() *bool {
	if c == nil {
		return nil
	}
	return c.ResolvedByMaven
}

func (c *ConversationAnalysis) GetPrimaryLanguage() *string {
	if c == nil {
		return nil
	}
	return c.PrimaryLanguage
}

func (c *ConversationAnalysis) GetPredictedNps() *float64 {
	if c == nil {
		return nil
	}
	return c.PredictedNps
}

func (c *ConversationAnalysis) GetCsat() *float64 {
	if c == nil {
		return nil
	}
	return c.Csat
}

func (c *ConversationAnalysis) GetIntelligentFieldValues() []*IntelligentFieldValueResponse {
	if c == nil {
		return nil
	}
	return c.IntelligentFieldValues
}

func (c *ConversationAnalysis) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationAnalysis) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserRequest sets the UserRequest field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetUserRequest(userRequest *string) {
	c.UserRequest = userRequest
	c.require(conversationAnalysisFieldUserRequest)
}

// SetAgentResponse sets the AgentResponse field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetAgentResponse(agentResponse *string) {
	c.AgentResponse = agentResponse
	c.require(conversationAnalysisFieldAgentResponse)
}

// SetResolutionStatus sets the ResolutionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetResolutionStatus(resolutionStatus *string) {
	c.ResolutionStatus = resolutionStatus
	c.require(conversationAnalysisFieldResolutionStatus)
}

// SetCategory sets the Category field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetCategory(category *string) {
	c.Category = category
	c.require(conversationAnalysisFieldCategory)
}

// SetSentiment sets the Sentiment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetSentiment(sentiment *Sentiment) {
	c.Sentiment = sentiment
	c.require(conversationAnalysisFieldSentiment)
}

// SetQuality sets the Quality field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetQuality(quality *Quality) {
	c.Quality = quality
	c.require(conversationAnalysisFieldQuality)
}

// SetQualityReason sets the QualityReason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetQualityReason(qualityReason *QualityReason) {
	c.QualityReason = qualityReason
	c.require(conversationAnalysisFieldQualityReason)
}

// SetResolvedByMaven sets the ResolvedByMaven field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetResolvedByMaven(resolvedByMaven *bool) {
	c.ResolvedByMaven = resolvedByMaven
	c.require(conversationAnalysisFieldResolvedByMaven)
}

// SetPrimaryLanguage sets the PrimaryLanguage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetPrimaryLanguage(primaryLanguage *string) {
	c.PrimaryLanguage = primaryLanguage
	c.require(conversationAnalysisFieldPrimaryLanguage)
}

// SetPredictedNps sets the PredictedNps field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetPredictedNps(predictedNps *float64) {
	c.PredictedNps = predictedNps
	c.require(conversationAnalysisFieldPredictedNps)
}

// SetCsat sets the Csat field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetCsat(csat *float64) {
	c.Csat = csat
	c.require(conversationAnalysisFieldCsat)
}

// SetIntelligentFieldValues sets the IntelligentFieldValues field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetIntelligentFieldValues(intelligentFieldValues []*IntelligentFieldValueResponse) {
	c.IntelligentFieldValues = intelligentFieldValues
	c.require(conversationAnalysisFieldIntelligentFieldValues)
}

func (c *ConversationAnalysis) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationAnalysis
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationAnalysis(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationAnalysis) MarshalJSON() ([]byte, error) {
	type embed ConversationAnalysis
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationAnalysis) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationExecutedActionPreconditionFieldOperator = big.NewInt(1 << 0)
	conversationExecutedActionPreconditionFieldActionID = big.NewInt(1 << 1)
	conversationExecutedActionPreconditionFieldAppID    = big.NewInt(1 << 2)
)

type ConversationExecutedActionPrecondition struct {
	// Operator to apply to this precondition
	Operator *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`
	// ID of an action that must have executed in this conversation for the precondition to be met
	ActionID string `json:"actionId" url:"actionId"`
	// App ID that the given actionId belongs to. If not provided, the calling appId will be used.
	AppID *string `json:"appId,omitempty" url:"appId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationExecutedActionPrecondition) GetOperator() *PreconditionOperator {
	if c == nil {
		return nil
	}
	return c.Operator
}

func (c *ConversationExecutedActionPrecondition) GetActionID() string {
	if c == nil {
		return ""
	}
	return c.ActionID
}

func (c *ConversationExecutedActionPrecondition) GetAppID() *string {
	if c == nil {
		return nil
	}
	return c.AppID
}

func (c *ConversationExecutedActionPrecondition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationExecutedActionPrecondition) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationExecutedActionPrecondition) SetOperator(operator *PreconditionOperator) {
	c.Operator = operator
	c.require(conversationExecutedActionPreconditionFieldOperator)
}

// SetActionID sets the ActionID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationExecutedActionPrecondition) SetActionID(actionID string) {
	c.ActionID = actionID
	c.require(conversationExecutedActionPreconditionFieldActionID)
}

// SetAppID sets the AppID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationExecutedActionPrecondition) SetAppID(appID *string) {
	c.AppID = appID
	c.require(conversationExecutedActionPreconditionFieldAppID)
}

func (c *ConversationExecutedActionPrecondition) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationExecutedActionPrecondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationExecutedActionPrecondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationExecutedActionPrecondition) MarshalJSON() ([]byte, error) {
	type embed ConversationExecutedActionPrecondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationExecutedActionPrecondition) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationInformationFieldConversationID = big.NewInt(1 << 0)
)

type ConversationInformation struct {
	// Unique identifier for the conversation.
	ConversationID *EntityIDWithoutAgent `json:"conversationId" url:"conversationId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationInformation) GetConversationID() *EntityIDWithoutAgent {
	if c == nil {
		return nil
	}
	return c.ConversationID
}

func (c *ConversationInformation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationInformation) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetConversationID sets the ConversationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationInformation) SetConversationID(conversationID *EntityIDWithoutAgent) {
	c.ConversationID = conversationID
	c.require(conversationInformationFieldConversationID)
}

func (c *ConversationInformation) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationInformation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationInformation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationInformation) MarshalJSON() ([]byte, error) {
	type embed ConversationInformation
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationInformation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationMessageBaseFieldCreatedAt = big.NewInt(1 << 0)
	conversationMessageBaseFieldUpdatedAt = big.NewInt(1 << 1)
)

type ConversationMessageBase struct {
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationMessageBase) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *ConversationMessageBase) GetUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *ConversationMessageBase) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationMessageBase) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMessageBase) SetCreatedAt(createdAt *time.Time) {
	c.CreatedAt = createdAt
	c.require(conversationMessageBaseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMessageBase) SetUpdatedAt(updatedAt *time.Time) {
	c.UpdatedAt = updatedAt
	c.require(conversationMessageBaseFieldUpdatedAt)
}

func (c *ConversationMessageBase) UnmarshalJSON(data []byte) error {
	type embed ConversationMessageBase
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationMessageBase(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationMessageBase) MarshalJSON() ([]byte, error) {
	type embed ConversationMessageBase
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewOptionalDateTime(c.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationMessageBase) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConversationMessageResponse struct {
	Type string
	User *UserMessage
	Bot  *BotMessage
}

func (c *ConversationMessageResponse) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ConversationMessageResponse) GetUser() *UserMessage {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *ConversationMessageResponse) GetBot() *BotMessage {
	if c == nil {
		return nil
	}
	return c.Bot
}

func (c *ConversationMessageResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "user":
		value := new(UserMessage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.User = value
	case "bot":
		value := new(BotMessage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Bot = value
	}
	return nil
}

func (c ConversationMessageResponse) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.User != nil {
		return internal.MarshalJSONWithExtraProperty(c.User, "type", "user")
	}
	if c.Bot != nil {
		return internal.MarshalJSONWithExtraProperty(c.Bot, "type", "bot")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ConversationMessageResponseVisitor interface {
	VisitUser(*UserMessage) error
	VisitBot(*BotMessage) error
}

func (c *ConversationMessageResponse) Accept(visitor ConversationMessageResponseVisitor) error {
	if c.User != nil {
		return visitor.VisitUser(c.User)
	}
	if c.Bot != nil {
		return visitor.VisitBot(c.Bot)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *ConversationMessageResponse) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.User != nil {
		fields = append(fields, "user")
	}
	if c.Bot != nil {
		fields = append(fields, "bot")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

type ConversationPrecondition struct {
	ConversationPreconditionType string
	Tags                         *TagsPrecondition
	Metadata                     *MetadataPrecondition
	ActionExecuted               *ConversationExecutedActionPrecondition
	ResponseConfig               *ResponseConfigPrecondition
	App                          *AppPrecondition
	IntelligentField             *IntelligentFieldPrecondition
}

func (c *ConversationPrecondition) GetConversationPreconditionType() string {
	if c == nil {
		return ""
	}
	return c.ConversationPreconditionType
}

func (c *ConversationPrecondition) GetTags() *TagsPrecondition {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *ConversationPrecondition) GetMetadata() *MetadataPrecondition {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ConversationPrecondition) GetActionExecuted() *ConversationExecutedActionPrecondition {
	if c == nil {
		return nil
	}
	return c.ActionExecuted
}

func (c *ConversationPrecondition) GetResponseConfig() *ResponseConfigPrecondition {
	if c == nil {
		return nil
	}
	return c.ResponseConfig
}

func (c *ConversationPrecondition) GetApp() *AppPrecondition {
	if c == nil {
		return nil
	}
	return c.App
}

func (c *ConversationPrecondition) GetIntelligentField() *IntelligentFieldPrecondition {
	if c == nil {
		return nil
	}
	return c.IntelligentField
}

func (c *ConversationPrecondition) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ConversationPreconditionType string `json:"conversationPreconditionType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.ConversationPreconditionType = unmarshaler.ConversationPreconditionType
	if unmarshaler.ConversationPreconditionType == "" {
		return fmt.Errorf("%T did not include discriminant conversationPreconditionType", c)
	}
	switch unmarshaler.ConversationPreconditionType {
	case "tags":
		value := new(TagsPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Tags = value
	case "metadata":
		value := new(MetadataPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Metadata = value
	case "actionExecuted":
		value := new(ConversationExecutedActionPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ActionExecuted = value
	case "responseConfig":
		value := new(ResponseConfigPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ResponseConfig = value
	case "app":
		value := new(AppPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.App = value
	case "intelligentField":
		value := new(IntelligentFieldPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.IntelligentField = value
	}
	return nil
}

func (c ConversationPrecondition) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.Tags != nil {
		return internal.MarshalJSONWithExtraProperty(c.Tags, "conversationPreconditionType", "tags")
	}
	if c.Metadata != nil {
		return internal.MarshalJSONWithExtraProperty(c.Metadata, "conversationPreconditionType", "metadata")
	}
	if c.ActionExecuted != nil {
		return internal.MarshalJSONWithExtraProperty(c.ActionExecuted, "conversationPreconditionType", "actionExecuted")
	}
	if c.ResponseConfig != nil {
		return internal.MarshalJSONWithExtraProperty(c.ResponseConfig, "conversationPreconditionType", "responseConfig")
	}
	if c.App != nil {
		return internal.MarshalJSONWithExtraProperty(c.App, "conversationPreconditionType", "app")
	}
	if c.IntelligentField != nil {
		return internal.MarshalJSONWithExtraProperty(c.IntelligentField, "conversationPreconditionType", "intelligentField")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ConversationPreconditionVisitor interface {
	VisitTags(*TagsPrecondition) error
	VisitMetadata(*MetadataPrecondition) error
	VisitActionExecuted(*ConversationExecutedActionPrecondition) error
	VisitResponseConfig(*ResponseConfigPrecondition) error
	VisitApp(*AppPrecondition) error
	VisitIntelligentField(*IntelligentFieldPrecondition) error
}

func (c *ConversationPrecondition) Accept(visitor ConversationPreconditionVisitor) error {
	if c.Tags != nil {
		return visitor.VisitTags(c.Tags)
	}
	if c.Metadata != nil {
		return visitor.VisitMetadata(c.Metadata)
	}
	if c.ActionExecuted != nil {
		return visitor.VisitActionExecuted(c.ActionExecuted)
	}
	if c.ResponseConfig != nil {
		return visitor.VisitResponseConfig(c.ResponseConfig)
	}
	if c.App != nil {
		return visitor.VisitApp(c.App)
	}
	if c.IntelligentField != nil {
		return visitor.VisitIntelligentField(c.IntelligentField)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *ConversationPrecondition) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.Tags != nil {
		fields = append(fields, "tags")
	}
	if c.Metadata != nil {
		fields = append(fields, "metadata")
	}
	if c.ActionExecuted != nil {
		fields = append(fields, "actionExecuted")
	}
	if c.ResponseConfig != nil {
		fields = append(fields, "responseConfig")
	}
	if c.App != nil {
		fields = append(fields, "app")
	}
	if c.IntelligentField != nil {
		fields = append(fields, "intelligentField")
	}
	if len(fields) == 0 {
		if c.ConversationPreconditionType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.ConversationPreconditionType)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.ConversationPreconditionType != "" {
		field := fields[0]
		if c.ConversationPreconditionType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.ConversationPreconditionType,
				c,
			)
		}
	}
	return nil
}

var (
	conversationPreviewFieldResponseConfig    = big.NewInt(1 << 0)
	conversationPreviewFieldSubject           = big.NewInt(1 << 1)
	conversationPreviewFieldURL               = big.NewInt(1 << 2)
	conversationPreviewFieldCreatedAt         = big.NewInt(1 << 3)
	conversationPreviewFieldUpdatedAt         = big.NewInt(1 << 4)
	conversationPreviewFieldTags              = big.NewInt(1 << 5)
	conversationPreviewFieldMetadata          = big.NewInt(1 << 6)
	conversationPreviewFieldAllMetadata       = big.NewInt(1 << 7)
	conversationPreviewFieldConversationID    = big.NewInt(1 << 8)
	conversationPreviewFieldAnalysis          = big.NewInt(1 << 9)
	conversationPreviewFieldSummary           = big.NewInt(1 << 10)
	conversationPreviewFieldDeleted           = big.NewInt(1 << 11)
	conversationPreviewFieldOpen              = big.NewInt(1 << 12)
	conversationPreviewFieldLlmEnabled        = big.NewInt(1 << 13)
	conversationPreviewFieldSimulationContext = big.NewInt(1 << 14)
)

type ConversationPreview struct {
	// Optional configurations for responses to this conversation
	ResponseConfig *ResponseConfig `json:"responseConfig,omitempty" url:"responseConfig,omitempty"`
	// The subject of the conversation
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The url of the conversation
	URL *string `json:"url,omitempty" url:"url,omitempty"`
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// The tags of the conversation. Used for filtering in Agent Designer.
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// The metadata of the conversation supplied by the app which created the conversation.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// All metadata for the conversation. Keyed by appId.
	AllMetadata map[string]map[string]string `json:"allMetadata" url:"allMetadata"`
	// The ID that uniquely identifies this conversation
	ConversationID *EntityID `json:"conversationId" url:"conversationId"`
	// An analysis of the conversation. Fields are generated by Maven via an analysis of user messages. This object is calculated on a delay. Fields will not be up to date on ask requests.
	Analysis *ConversationAnalysis `json:"analysis" url:"analysis"`
	// A summary of the conversation. Fields are calculated from conversation data. Unlike analysis, all fields can be derived from other data available in the API. This object is provided as a convenience and is calculated on a delay. Fields will not be up to date on ask requests.
	Summary *ConversationSummary `json:"summary" url:"summary"`
	// Whether the conversation user-specific data has been deleted. See `deleteConversation` for details.
	Deleted bool `json:"deleted" url:"deleted"`
	// Whether the conversation is able to receive asynchronous messages.
	// Only applicable if a conversation is initialized with the `ASYNC` capability. Defaults to true. Can be closed using the `PATCH` API.
	Open bool `json:"open" url:"open"`
	// Whether the LLM is enabled for this conversation.
	// If true, `USER` messages sent via the ask API will be sent to the LLM and a `BOT_RESPONSE` or `BOT_SUGGESTION` message will be generated.
	// If false, `USER` messages will not be sent to the LLM.
	LlmEnabled bool `json:"llmEnabled" url:"llmEnabled"`
	// Additional context used for simulation runs. When present, this conversation is treated as a simulation.
	// Simulation conversations are excluded from normal search results unless explicitly included via the `simulationFilter` field.
	SimulationContext *SimulationContext `json:"simulationContext,omitempty" url:"simulationContext,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationPreview) GetResponseConfig() *ResponseConfig {
	if c == nil {
		return nil
	}
	return c.ResponseConfig
}

func (c *ConversationPreview) GetSubject() *string {
	if c == nil {
		return nil
	}
	return c.Subject
}

func (c *ConversationPreview) GetURL() *string {
	if c == nil {
		return nil
	}
	return c.URL
}

func (c *ConversationPreview) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *ConversationPreview) GetUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *ConversationPreview) GetTags() []string {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *ConversationPreview) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ConversationPreview) GetAllMetadata() map[string]map[string]string {
	if c == nil {
		return nil
	}
	return c.AllMetadata
}

func (c *ConversationPreview) GetConversationID() *EntityID {
	if c == nil {
		return nil
	}
	return c.ConversationID
}

func (c *ConversationPreview) GetAnalysis() *ConversationAnalysis {
	if c == nil {
		return nil
	}
	return c.Analysis
}

func (c *ConversationPreview) GetSummary() *ConversationSummary {
	if c == nil {
		return nil
	}
	return c.Summary
}

func (c *ConversationPreview) GetDeleted() bool {
	if c == nil {
		return false
	}
	return c.Deleted
}

func (c *ConversationPreview) GetOpen() bool {
	if c == nil {
		return false
	}
	return c.Open
}

func (c *ConversationPreview) GetLlmEnabled() bool {
	if c == nil {
		return false
	}
	return c.LlmEnabled
}

func (c *ConversationPreview) GetSimulationContext() *SimulationContext {
	if c == nil {
		return nil
	}
	return c.SimulationContext
}

func (c *ConversationPreview) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationPreview) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetResponseConfig sets the ResponseConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetResponseConfig(responseConfig *ResponseConfig) {
	c.ResponseConfig = responseConfig
	c.require(conversationPreviewFieldResponseConfig)
}

// SetSubject sets the Subject field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetSubject(subject *string) {
	c.Subject = subject
	c.require(conversationPreviewFieldSubject)
}

// SetURL sets the URL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetURL(url *string) {
	c.URL = url
	c.require(conversationPreviewFieldURL)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetCreatedAt(createdAt *time.Time) {
	c.CreatedAt = createdAt
	c.require(conversationPreviewFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetUpdatedAt(updatedAt *time.Time) {
	c.UpdatedAt = updatedAt
	c.require(conversationPreviewFieldUpdatedAt)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetTags(tags []string) {
	c.Tags = tags
	c.require(conversationPreviewFieldTags)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetMetadata(metadata map[string]string) {
	c.Metadata = metadata
	c.require(conversationPreviewFieldMetadata)
}

// SetAllMetadata sets the AllMetadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetAllMetadata(allMetadata map[string]map[string]string) {
	c.AllMetadata = allMetadata
	c.require(conversationPreviewFieldAllMetadata)
}

// SetConversationID sets the ConversationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetConversationID(conversationID *EntityID) {
	c.ConversationID = conversationID
	c.require(conversationPreviewFieldConversationID)
}

// SetAnalysis sets the Analysis field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetAnalysis(analysis *ConversationAnalysis) {
	c.Analysis = analysis
	c.require(conversationPreviewFieldAnalysis)
}

// SetSummary sets the Summary field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetSummary(summary *ConversationSummary) {
	c.Summary = summary
	c.require(conversationPreviewFieldSummary)
}

// SetDeleted sets the Deleted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetDeleted(deleted bool) {
	c.Deleted = deleted
	c.require(conversationPreviewFieldDeleted)
}

// SetOpen sets the Open field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetOpen(open bool) {
	c.Open = open
	c.require(conversationPreviewFieldOpen)
}

// SetLlmEnabled sets the LlmEnabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetLlmEnabled(llmEnabled bool) {
	c.LlmEnabled = llmEnabled
	c.require(conversationPreviewFieldLlmEnabled)
}

// SetSimulationContext sets the SimulationContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetSimulationContext(simulationContext *SimulationContext) {
	c.SimulationContext = simulationContext
	c.require(conversationPreviewFieldSimulationContext)
}

func (c *ConversationPreview) UnmarshalJSON(data []byte) error {
	type embed ConversationPreview
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationPreview(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationPreview) MarshalJSON() ([]byte, error) {
	type embed ConversationPreview
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewOptionalDateTime(c.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationPreview) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationResponseFieldResponseConfig    = big.NewInt(1 << 0)
	conversationResponseFieldSubject           = big.NewInt(1 << 1)
	conversationResponseFieldURL               = big.NewInt(1 << 2)
	conversationResponseFieldCreatedAt         = big.NewInt(1 << 3)
	conversationResponseFieldUpdatedAt         = big.NewInt(1 << 4)
	conversationResponseFieldTags              = big.NewInt(1 << 5)
	conversationResponseFieldMetadata          = big.NewInt(1 << 6)
	conversationResponseFieldAllMetadata       = big.NewInt(1 << 7)
	conversationResponseFieldConversationID    = big.NewInt(1 << 8)
	conversationResponseFieldAnalysis          = big.NewInt(1 << 9)
	conversationResponseFieldSummary           = big.NewInt(1 << 10)
	conversationResponseFieldDeleted           = big.NewInt(1 << 11)
	conversationResponseFieldOpen              = big.NewInt(1 << 12)
	conversationResponseFieldLlmEnabled        = big.NewInt(1 << 13)
	conversationResponseFieldSimulationContext = big.NewInt(1 << 14)
	conversationResponseFieldMessages          = big.NewInt(1 << 15)
	conversationResponseFieldAttachments       = big.NewInt(1 << 16)
)

type ConversationResponse struct {
	// Optional configurations for responses to this conversation
	ResponseConfig *ResponseConfig `json:"responseConfig,omitempty" url:"responseConfig,omitempty"`
	// The subject of the conversation
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The url of the conversation
	URL *string `json:"url,omitempty" url:"url,omitempty"`
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// The tags of the conversation. Used for filtering in Agent Designer.
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// The metadata of the conversation supplied by the app which created the conversation.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// All metadata for the conversation. Keyed by appId.
	AllMetadata map[string]map[string]string `json:"allMetadata" url:"allMetadata"`
	// The ID that uniquely identifies this conversation
	ConversationID *EntityID `json:"conversationId" url:"conversationId"`
	// An analysis of the conversation. Fields are generated by Maven via an analysis of user messages. This object is calculated on a delay. Fields will not be up to date on ask requests.
	Analysis *ConversationAnalysis `json:"analysis" url:"analysis"`
	// A summary of the conversation. Fields are calculated from conversation data. Unlike analysis, all fields can be derived from other data available in the API. This object is provided as a convenience and is calculated on a delay. Fields will not be up to date on ask requests.
	Summary *ConversationSummary `json:"summary" url:"summary"`
	// Whether the conversation user-specific data has been deleted. See `deleteConversation` for details.
	Deleted bool `json:"deleted" url:"deleted"`
	// Whether the conversation is able to receive asynchronous messages.
	// Only applicable if a conversation is initialized with the `ASYNC` capability. Defaults to true. Can be closed using the `PATCH` API.
	Open bool `json:"open" url:"open"`
	// Whether the LLM is enabled for this conversation.
	// If true, `USER` messages sent via the ask API will be sent to the LLM and a `BOT_RESPONSE` or `BOT_SUGGESTION` message will be generated.
	// If false, `USER` messages will not be sent to the LLM.
	LlmEnabled bool `json:"llmEnabled" url:"llmEnabled"`
	// Additional context used for simulation runs. When present, this conversation is treated as a simulation.
	// Simulation conversations are excluded from normal search results unless explicitly included via the `simulationFilter` field.
	SimulationContext *SimulationContext `json:"simulationContext,omitempty" url:"simulationContext,omitempty"`
	// The messages in the conversation
	Messages []*ConversationMessageResponse `json:"messages" url:"messages"`
	// The attachments associated with this conversation. Additional attachments may be associated to individual messages.
	//
	// Message attachments are included in LLM context, conversation attachments are not.
	Attachments []*AttachmentResponse `json:"attachments" url:"attachments"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationResponse) GetResponseConfig() *ResponseConfig {
	if c == nil {
		return nil
	}
	return c.ResponseConfig
}

func (c *ConversationResponse) GetSubject() *string {
	if c == nil {
		return nil
	}
	return c.Subject
}

func (c *ConversationResponse) GetURL() *string {
	if c == nil {
		return nil
	}
	return c.URL
}

func (c *ConversationResponse) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *ConversationResponse) GetUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *ConversationResponse) GetTags() []string {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *ConversationResponse) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ConversationResponse) GetAllMetadata() map[string]map[string]string {
	if c == nil {
		return nil
	}
	return c.AllMetadata
}

func (c *ConversationResponse) GetConversationID() *EntityID {
	if c == nil {
		return nil
	}
	return c.ConversationID
}

func (c *ConversationResponse) GetAnalysis() *ConversationAnalysis {
	if c == nil {
		return nil
	}
	return c.Analysis
}

func (c *ConversationResponse) GetSummary() *ConversationSummary {
	if c == nil {
		return nil
	}
	return c.Summary
}

func (c *ConversationResponse) GetDeleted() bool {
	if c == nil {
		return false
	}
	return c.Deleted
}

func (c *ConversationResponse) GetOpen() bool {
	if c == nil {
		return false
	}
	return c.Open
}

func (c *ConversationResponse) GetLlmEnabled() bool {
	if c == nil {
		return false
	}
	return c.LlmEnabled
}

func (c *ConversationResponse) GetSimulationContext() *SimulationContext {
	if c == nil {
		return nil
	}
	return c.SimulationContext
}

func (c *ConversationResponse) GetMessages() []*ConversationMessageResponse {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *ConversationResponse) GetAttachments() []*AttachmentResponse {
	if c == nil {
		return nil
	}
	return c.Attachments
}

func (c *ConversationResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetResponseConfig sets the ResponseConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetResponseConfig(responseConfig *ResponseConfig) {
	c.ResponseConfig = responseConfig
	c.require(conversationResponseFieldResponseConfig)
}

// SetSubject sets the Subject field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetSubject(subject *string) {
	c.Subject = subject
	c.require(conversationResponseFieldSubject)
}

// SetURL sets the URL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetURL(url *string) {
	c.URL = url
	c.require(conversationResponseFieldURL)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetCreatedAt(createdAt *time.Time) {
	c.CreatedAt = createdAt
	c.require(conversationResponseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetUpdatedAt(updatedAt *time.Time) {
	c.UpdatedAt = updatedAt
	c.require(conversationResponseFieldUpdatedAt)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetTags(tags []string) {
	c.Tags = tags
	c.require(conversationResponseFieldTags)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetMetadata(metadata map[string]string) {
	c.Metadata = metadata
	c.require(conversationResponseFieldMetadata)
}

// SetAllMetadata sets the AllMetadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetAllMetadata(allMetadata map[string]map[string]string) {
	c.AllMetadata = allMetadata
	c.require(conversationResponseFieldAllMetadata)
}

// SetConversationID sets the ConversationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetConversationID(conversationID *EntityID) {
	c.ConversationID = conversationID
	c.require(conversationResponseFieldConversationID)
}

// SetAnalysis sets the Analysis field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetAnalysis(analysis *ConversationAnalysis) {
	c.Analysis = analysis
	c.require(conversationResponseFieldAnalysis)
}

// SetSummary sets the Summary field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetSummary(summary *ConversationSummary) {
	c.Summary = summary
	c.require(conversationResponseFieldSummary)
}

// SetDeleted sets the Deleted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetDeleted(deleted bool) {
	c.Deleted = deleted
	c.require(conversationResponseFieldDeleted)
}

// SetOpen sets the Open field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetOpen(open bool) {
	c.Open = open
	c.require(conversationResponseFieldOpen)
}

// SetLlmEnabled sets the LlmEnabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetLlmEnabled(llmEnabled bool) {
	c.LlmEnabled = llmEnabled
	c.require(conversationResponseFieldLlmEnabled)
}

// SetSimulationContext sets the SimulationContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetSimulationContext(simulationContext *SimulationContext) {
	c.SimulationContext = simulationContext
	c.require(conversationResponseFieldSimulationContext)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetMessages(messages []*ConversationMessageResponse) {
	c.Messages = messages
	c.require(conversationResponseFieldMessages)
}

// SetAttachments sets the Attachments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetAttachments(attachments []*AttachmentResponse) {
	c.Attachments = attachments
	c.require(conversationResponseFieldAttachments)
}

func (c *ConversationResponse) UnmarshalJSON(data []byte) error {
	type embed ConversationResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationResponse) MarshalJSON() ([]byte, error) {
	type embed ConversationResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewOptionalDateTime(c.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationSummaryFieldActionIDs               = big.NewInt(1 << 0)
	conversationSummaryFieldIncompleteActionIDs     = big.NewInt(1 << 1)
	conversationSummaryFieldInsertCount             = big.NewInt(1 << 2)
	conversationSummaryFieldThumbsUpCount           = big.NewInt(1 << 3)
	conversationSummaryFieldThumbsDownCount         = big.NewInt(1 << 4)
	conversationSummaryFieldHandoffCount            = big.NewInt(1 << 5)
	conversationSummaryFieldUserMessageCount        = big.NewInt(1 << 6)
	conversationSummaryFieldBotMessageCount         = big.NewInt(1 << 7)
	conversationSummaryFieldCsat                    = big.NewInt(1 << 8)
	conversationSummaryFieldHandleTime              = big.NewInt(1 << 9)
	conversationSummaryFieldHumanAgentResponseDelay = big.NewInt(1 << 10)
	conversationSummaryFieldHumanAgents             = big.NewInt(1 << 11)
	conversationSummaryFieldHumanAgentsWithInserts  = big.NewInt(1 << 12)
	conversationSummaryFieldUsers                   = big.NewInt(1 << 13)
	conversationSummaryFieldUserIdentifiers         = big.NewInt(1 << 14)
	conversationSummaryFieldLastUserMessage         = big.NewInt(1 << 15)
	conversationSummaryFieldLastBotMessage          = big.NewInt(1 << 16)
	conversationSummaryFieldInvolvedAppIDs          = big.NewInt(1 << 17)
)

type ConversationSummary struct {
	// The IDs of the actions that were taken by Maven in the conversation
	ActionIDs []*EntityIDWithoutAgent `json:"actionIds" url:"actionIds"`
	// The IDs of the actions that were taken by Maven but not completed in the conversation. Occurs when the user is shown an action form but does not submit it.
	IncompleteActionIDs []*EntityIDWithoutAgent `json:"incompleteActionIds" url:"incompleteActionIds"`
	// The number of insert events on messages in the conversation.
	InsertCount int `json:"insertCount" url:"insertCount"`
	// The number of thumbs up events on messages in the conversation.
	ThumbsUpCount int `json:"thumbsUpCount" url:"thumbsUpCount"`
	// The number of thumbs down events on messages in the conversation.
	ThumbsDownCount int `json:"thumbsDownCount" url:"thumbsDownCount"`
	// The number of bot response messages that failed and returned the Agent's system fallback message.
	HandoffCount int `json:"handoffCount" url:"handoffCount"`
	// The number of messages of type `USER` in the conversation.
	UserMessageCount int `json:"userMessageCount" url:"userMessageCount"`
	// The number of bot answer messages in the conversation.
	BotMessageCount int `json:"botMessageCount" url:"botMessageCount"`
	// The CSAT score for the conversation
	Csat *float64 `json:"csat,omitempty" url:"csat,omitempty"`
	// The total time in milliseconds that the user spent interacting with the conversation.
	// Calculated by taking the timestamp of the last message in the conversation minus the timestamp of the first message.
	HandleTime *int64 `json:"handleTime,omitempty" url:"handleTime,omitempty"`
	// The time in milliseconds that elapsed before a human agent responded to the conversation.
	// Calculated by taking the timestamp of the first message of type `HUMAN_AGENT`
	// minus the timestamp of the first message in the conversation.
	//
	// Will not be provided if the conversation does not have a message of type `HUMAN_AGENT`.
	HumanAgentResponseDelay *int64 `json:"humanAgentResponseDelay,omitempty" url:"humanAgentResponseDelay,omitempty"`
	// The names of all users that have a message of type `HUMAN_AGENT` on the conversation.
	HumanAgents []string `json:"humanAgents" url:"humanAgents"`
	// The names of all users that have an associated insert event on the conversation.
	HumanAgentsWithInserts []string `json:"humanAgentsWithInserts" url:"humanAgentsWithInserts"`
	// The names of all users that have a message of type `USER` on the conversation.
	Users []string `json:"users" url:"users"`
	// The user identifiers (typically email addresses or phone numbers) of all users that have a message of type `USER` on the conversation.
	UserIdentifiers []string `json:"userIdentifiers" url:"userIdentifiers"`
	// The text of the last user message in the conversation.
	LastUserMessage *string `json:"lastUserMessage,omitempty" url:"lastUserMessage,omitempty"`
	// The text of the last bot message in the conversation.
	LastBotMessage *string `json:"lastBotMessage,omitempty" url:"lastBotMessage,omitempty"`
	// The set of app IDs that are involved in this conversation. This includes:
	// - The app ID that created the conversation
	// - The app IDs of all messages created in the conversation
	// - The app IDs of all actions selected by the LLM in the conversation (including unsubmitted forms)
	// - The app IDs of all documents referenced by LLM responses in the conversation (does not include document search results not utilized by the LLM)
	InvolvedAppIDs []string `json:"involvedAppIds" url:"involvedAppIds"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationSummary) GetActionIDs() []*EntityIDWithoutAgent {
	if c == nil {
		return nil
	}
	return c.ActionIDs
}

func (c *ConversationSummary) GetIncompleteActionIDs() []*EntityIDWithoutAgent {
	if c == nil {
		return nil
	}
	return c.IncompleteActionIDs
}

func (c *ConversationSummary) GetInsertCount() int {
	if c == nil {
		return 0
	}
	return c.InsertCount
}

func (c *ConversationSummary) GetThumbsUpCount() int {
	if c == nil {
		return 0
	}
	return c.ThumbsUpCount
}

func (c *ConversationSummary) GetThumbsDownCount() int {
	if c == nil {
		return 0
	}
	return c.ThumbsDownCount
}

func (c *ConversationSummary) GetHandoffCount() int {
	if c == nil {
		return 0
	}
	return c.HandoffCount
}

func (c *ConversationSummary) GetUserMessageCount() int {
	if c == nil {
		return 0
	}
	return c.UserMessageCount
}

func (c *ConversationSummary) GetBotMessageCount() int {
	if c == nil {
		return 0
	}
	return c.BotMessageCount
}

func (c *ConversationSummary) GetCsat() *float64 {
	if c == nil {
		return nil
	}
	return c.Csat
}

func (c *ConversationSummary) GetHandleTime() *int64 {
	if c == nil {
		return nil
	}
	return c.HandleTime
}

func (c *ConversationSummary) GetHumanAgentResponseDelay() *int64 {
	if c == nil {
		return nil
	}
	return c.HumanAgentResponseDelay
}

func (c *ConversationSummary) GetHumanAgents() []string {
	if c == nil {
		return nil
	}
	return c.HumanAgents
}

func (c *ConversationSummary) GetHumanAgentsWithInserts() []string {
	if c == nil {
		return nil
	}
	return c.HumanAgentsWithInserts
}

func (c *ConversationSummary) GetUsers() []string {
	if c == nil {
		return nil
	}
	return c.Users
}

func (c *ConversationSummary) GetUserIdentifiers() []string {
	if c == nil {
		return nil
	}
	return c.UserIdentifiers
}

func (c *ConversationSummary) GetLastUserMessage() *string {
	if c == nil {
		return nil
	}
	return c.LastUserMessage
}

func (c *ConversationSummary) GetLastBotMessage() *string {
	if c == nil {
		return nil
	}
	return c.LastBotMessage
}

func (c *ConversationSummary) GetInvolvedAppIDs() []string {
	if c == nil {
		return nil
	}
	return c.InvolvedAppIDs
}

func (c *ConversationSummary) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationSummary) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetActionIDs sets the ActionIDs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetActionIDs(actionIDs []*EntityIDWithoutAgent) {
	c.ActionIDs = actionIDs
	c.require(conversationSummaryFieldActionIDs)
}

// SetIncompleteActionIDs sets the IncompleteActionIDs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetIncompleteActionIDs(incompleteActionIDs []*EntityIDWithoutAgent) {
	c.IncompleteActionIDs = incompleteActionIDs
	c.require(conversationSummaryFieldIncompleteActionIDs)
}

// SetInsertCount sets the InsertCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetInsertCount(insertCount int) {
	c.InsertCount = insertCount
	c.require(conversationSummaryFieldInsertCount)
}

// SetThumbsUpCount sets the ThumbsUpCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetThumbsUpCount(thumbsUpCount int) {
	c.ThumbsUpCount = thumbsUpCount
	c.require(conversationSummaryFieldThumbsUpCount)
}

// SetThumbsDownCount sets the ThumbsDownCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetThumbsDownCount(thumbsDownCount int) {
	c.ThumbsDownCount = thumbsDownCount
	c.require(conversationSummaryFieldThumbsDownCount)
}

// SetHandoffCount sets the HandoffCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetHandoffCount(handoffCount int) {
	c.HandoffCount = handoffCount
	c.require(conversationSummaryFieldHandoffCount)
}

// SetUserMessageCount sets the UserMessageCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetUserMessageCount(userMessageCount int) {
	c.UserMessageCount = userMessageCount
	c.require(conversationSummaryFieldUserMessageCount)
}

// SetBotMessageCount sets the BotMessageCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetBotMessageCount(botMessageCount int) {
	c.BotMessageCount = botMessageCount
	c.require(conversationSummaryFieldBotMessageCount)
}

// SetCsat sets the Csat field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetCsat(csat *float64) {
	c.Csat = csat
	c.require(conversationSummaryFieldCsat)
}

// SetHandleTime sets the HandleTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetHandleTime(handleTime *int64) {
	c.HandleTime = handleTime
	c.require(conversationSummaryFieldHandleTime)
}

// SetHumanAgentResponseDelay sets the HumanAgentResponseDelay field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetHumanAgentResponseDelay(humanAgentResponseDelay *int64) {
	c.HumanAgentResponseDelay = humanAgentResponseDelay
	c.require(conversationSummaryFieldHumanAgentResponseDelay)
}

// SetHumanAgents sets the HumanAgents field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetHumanAgents(humanAgents []string) {
	c.HumanAgents = humanAgents
	c.require(conversationSummaryFieldHumanAgents)
}

// SetHumanAgentsWithInserts sets the HumanAgentsWithInserts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetHumanAgentsWithInserts(humanAgentsWithInserts []string) {
	c.HumanAgentsWithInserts = humanAgentsWithInserts
	c.require(conversationSummaryFieldHumanAgentsWithInserts)
}

// SetUsers sets the Users field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetUsers(users []string) {
	c.Users = users
	c.require(conversationSummaryFieldUsers)
}

// SetUserIdentifiers sets the UserIdentifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetUserIdentifiers(userIdentifiers []string) {
	c.UserIdentifiers = userIdentifiers
	c.require(conversationSummaryFieldUserIdentifiers)
}

// SetLastUserMessage sets the LastUserMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetLastUserMessage(lastUserMessage *string) {
	c.LastUserMessage = lastUserMessage
	c.require(conversationSummaryFieldLastUserMessage)
}

// SetLastBotMessage sets the LastBotMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetLastBotMessage(lastBotMessage *string) {
	c.LastBotMessage = lastBotMessage
	c.require(conversationSummaryFieldLastBotMessage)
}

// SetInvolvedAppIDs sets the InvolvedAppIDs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetInvolvedAppIDs(involvedAppIDs []string) {
	c.InvolvedAppIDs = involvedAppIDs
	c.require(conversationSummaryFieldInvolvedAppIDs)
}

func (c *ConversationSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationSummary) MarshalJSON() ([]byte, error) {
	type embed ConversationSummary
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationSummary) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	csatInfoFieldRating    = big.NewInt(1 << 0)
	csatInfoFieldMaxRating = big.NewInt(1 << 1)
)

type CsatInfo struct {
	// The rating of the CSAT rating
	Rating *float64 `json:"rating,omitempty" url:"rating,omitempty"`
	// The max rating of the CSAT value (default 5)
	MaxRating *float64 `json:"maxRating,omitempty" url:"maxRating,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *CsatInfo) GetRating() *float64 {
	if c == nil {
		return nil
	}
	return c.Rating
}

func (c *CsatInfo) GetMaxRating() *float64 {
	if c == nil {
		return nil
	}
	return c.MaxRating
}

func (c *CsatInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *CsatInfo) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetRating sets the Rating field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CsatInfo) SetRating(rating *float64) {
	c.Rating = rating
	c.require(csatInfoFieldRating)
}

// SetMaxRating sets the MaxRating field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *CsatInfo) SetMaxRating(maxRating *float64) {
	c.MaxRating = maxRating
	c.require(csatInfoFieldMaxRating)
}

func (c *CsatInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler CsatInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CsatInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *CsatInfo) MarshalJSON() ([]byte, error) {
	type embed CsatInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *CsatInfo) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	deviceInfoFieldType    = big.NewInt(1 << 0)
	deviceInfoFieldName    = big.NewInt(1 << 1)
	deviceInfoFieldVersion = big.NewInt(1 << 2)
	deviceInfoFieldOsInfo  = big.NewInt(1 << 3)
)

type DeviceInfo struct {
	Type    DeviceType `json:"type" url:"type"`
	Name    *string    `json:"name,omitempty" url:"name,omitempty"`
	Version *string    `json:"version,omitempty" url:"version,omitempty"`
	OsInfo  *OsInfo    `json:"osInfo,omitempty" url:"osInfo,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceInfo) GetType() DeviceType {
	if d == nil {
		return ""
	}
	return d.Type
}

func (d *DeviceInfo) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeviceInfo) GetVersion() *string {
	if d == nil {
		return nil
	}
	return d.Version
}

func (d *DeviceInfo) GetOsInfo() *OsInfo {
	if d == nil {
		return nil
	}
	return d.OsInfo
}

func (d *DeviceInfo) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceInfo) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceInfo) SetType(type_ DeviceType) {
	d.Type = type_
	d.require(deviceInfoFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceInfo) SetName(name *string) {
	d.Name = name
	d.require(deviceInfoFieldName)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceInfo) SetVersion(version *string) {
	d.Version = version
	d.require(deviceInfoFieldVersion)
}

// SetOsInfo sets the OsInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceInfo) SetOsInfo(osInfo *OsInfo) {
	d.OsInfo = osInfo
	d.require(deviceInfoFieldOsInfo)
}

func (d *DeviceInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceInfo) MarshalJSON() ([]byte, error) {
	type embed DeviceInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeviceInfo) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceType string

const (
	DeviceTypeDesktop DeviceType = "DESKTOP"
	DeviceTypeMobile  DeviceType = "MOBILE"
	DeviceTypeTablet  DeviceType = "TABLET"
	DeviceTypeOther   DeviceType = "OTHER"
)

func NewDeviceTypeFromString(s string) (DeviceType, error) {
	switch s {
	case "DESKTOP":
		return DeviceTypeDesktop, nil
	case "MOBILE":
		return DeviceTypeMobile, nil
	case "TABLET":
		return DeviceTypeTablet, nil
	case "OTHER":
		return DeviceTypeOther, nil
	}
	var t DeviceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeviceType) Ptr() *DeviceType {
	return &d
}

var (
	documentInformationFieldKnowledgeBaseID = big.NewInt(1 << 0)
	documentInformationFieldDocumentID      = big.NewInt(1 << 1)
	documentInformationFieldTitle           = big.NewInt(1 << 2)
	documentInformationFieldSnippet         = big.NewInt(1 << 3)
)

type DocumentInformation struct {
	// Unique identifier for the knowledge base.
	KnowledgeBaseID *EntityIDWithoutAgent `json:"knowledgeBaseId" url:"knowledgeBaseId"`
	// Unique identifier for the document.
	DocumentID *EntityIDWithoutAgent `json:"documentId" url:"documentId"`
	// Title of the document.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Snippet or summary of the document.
	Snippet *string `json:"snippet,omitempty" url:"snippet,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentInformation) GetKnowledgeBaseID() *EntityIDWithoutAgent {
	if d == nil {
		return nil
	}
	return d.KnowledgeBaseID
}

func (d *DocumentInformation) GetDocumentID() *EntityIDWithoutAgent {
	if d == nil {
		return nil
	}
	return d.DocumentID
}

func (d *DocumentInformation) GetTitle() *string {
	if d == nil {
		return nil
	}
	return d.Title
}

func (d *DocumentInformation) GetSnippet() *string {
	if d == nil {
		return nil
	}
	return d.Snippet
}

func (d *DocumentInformation) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentInformation) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetKnowledgeBaseID sets the KnowledgeBaseID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DocumentInformation) SetKnowledgeBaseID(knowledgeBaseID *EntityIDWithoutAgent) {
	d.KnowledgeBaseID = knowledgeBaseID
	d.require(documentInformationFieldKnowledgeBaseID)
}

// SetDocumentID sets the DocumentID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DocumentInformation) SetDocumentID(documentID *EntityIDWithoutAgent) {
	d.DocumentID = documentID
	d.require(documentInformationFieldDocumentID)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DocumentInformation) SetTitle(title *string) {
	d.Title = title
	d.require(documentInformationFieldTitle)
}

// SetSnippet sets the Snippet field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DocumentInformation) SetSnippet(snippet *string) {
	d.Snippet = snippet
	d.require(documentInformationFieldSnippet)
}

func (d *DocumentInformation) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentInformation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentInformation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentInformation) MarshalJSON() ([]byte, error) {
	type embed DocumentInformation
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DocumentInformation) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

var (
	dropdownSettingsSchemaEntryFieldKey             = big.NewInt(1 << 0)
	dropdownSettingsSchemaEntryFieldDisplayName     = big.NewInt(1 << 1)
	dropdownSettingsSchemaEntryFieldDescription     = big.NewInt(1 << 2)
	dropdownSettingsSchemaEntryFieldVisibility      = big.NewInt(1 << 3)
	dropdownSettingsSchemaEntryFieldRequired        = big.NewInt(1 << 4)
	dropdownSettingsSchemaEntryFieldDropdownOptions = big.NewInt(1 << 5)
	dropdownSettingsSchemaEntryFieldDefaultValue    = big.NewInt(1 << 6)
)

type DropdownSettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required        *bool    `json:"required,omitempty" url:"required,omitempty"`
	DropdownOptions []string `json:"dropdownOptions" url:"dropdownOptions"`
	DefaultValue    *string  `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DropdownSettingsSchemaEntry) GetKey() string {
	if d == nil {
		return ""
	}
	return d.Key
}

func (d *DropdownSettingsSchemaEntry) GetDisplayName() string {
	if d == nil {
		return ""
	}
	return d.DisplayName
}

func (d *DropdownSettingsSchemaEntry) GetDescription() *string {
	if d == nil {
		return nil
	}
	return d.Description
}

func (d *DropdownSettingsSchemaEntry) GetVisibility() *VisibilityType {
	if d == nil {
		return nil
	}
	return d.Visibility
}

func (d *DropdownSettingsSchemaEntry) GetRequired() *bool {
	if d == nil {
		return nil
	}
	return d.Required
}

func (d *DropdownSettingsSchemaEntry) GetDropdownOptions() []string {
	if d == nil {
		return nil
	}
	return d.DropdownOptions
}

func (d *DropdownSettingsSchemaEntry) GetDefaultValue() *string {
	if d == nil {
		return nil
	}
	return d.DefaultValue
}

func (d *DropdownSettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DropdownSettingsSchemaEntry) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DropdownSettingsSchemaEntry) SetKey(key string) {
	d.Key = key
	d.require(dropdownSettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DropdownSettingsSchemaEntry) SetDisplayName(displayName string) {
	d.DisplayName = displayName
	d.require(dropdownSettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DropdownSettingsSchemaEntry) SetDescription(description *string) {
	d.Description = description
	d.require(dropdownSettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DropdownSettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	d.Visibility = visibility
	d.require(dropdownSettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DropdownSettingsSchemaEntry) SetRequired(required *bool) {
	d.Required = required
	d.require(dropdownSettingsSchemaEntryFieldRequired)
}

// SetDropdownOptions sets the DropdownOptions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DropdownSettingsSchemaEntry) SetDropdownOptions(dropdownOptions []string) {
	d.DropdownOptions = dropdownOptions
	d.require(dropdownSettingsSchemaEntryFieldDropdownOptions)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DropdownSettingsSchemaEntry) SetDefaultValue(defaultValue *string) {
	d.DefaultValue = defaultValue
	d.require(dropdownSettingsSchemaEntryFieldDefaultValue)
}

func (d *DropdownSettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler DropdownSettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DropdownSettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DropdownSettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed DropdownSettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DropdownSettingsSchemaEntry) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A fully specified object ID, unique across the entire system.
var (
	entityIDFieldReferenceID    = big.NewInt(1 << 0)
	entityIDFieldType           = big.NewInt(1 << 1)
	entityIDFieldAppID          = big.NewInt(1 << 2)
	entityIDFieldOrganizationID = big.NewInt(1 << 3)
	entityIDFieldAgentID        = big.NewInt(1 << 4)
)

type EntityID struct {
	// Externally supplied ID to uniquely identify this object. Is globally unique when combined with all other entityId fields (type, appId, organizationId, agentId).
	//
	// Must be less than 192 characters and contain only:
	// - alphanumeric characters (`a-z`, `A-Z`, `0-9`)
	// - hyphens (`-`)
	// - underscores (`_`)
	// - plus signs (`+`)
	// - periods (`.`)
	// - at symbol (`@`)
	// - pipe symbol (`|`)
	ReferenceID string `json:"referenceId" url:"referenceId"`
	// The object type
	Type EntityType `json:"type" url:"type"`
	// The ID of the application that created this object
	AppID string `json:"appId" url:"appId"`
	// The ID of the organization that this object belongs to
	OrganizationID string `json:"organizationId" url:"organizationId"`
	// The ID of the agent that this object belongs to
	AgentID string `json:"agentId" url:"agentId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityID) GetReferenceID() string {
	if e == nil {
		return ""
	}
	return e.ReferenceID
}

func (e *EntityID) GetType() EntityType {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EntityID) GetAppID() string {
	if e == nil {
		return ""
	}
	return e.AppID
}

func (e *EntityID) GetOrganizationID() string {
	if e == nil {
		return ""
	}
	return e.OrganizationID
}

func (e *EntityID) GetAgentID() string {
	if e == nil {
		return ""
	}
	return e.AgentID
}

func (e *EntityID) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityID) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetReferenceID sets the ReferenceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityID) SetReferenceID(referenceID string) {
	e.ReferenceID = referenceID
	e.require(entityIDFieldReferenceID)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityID) SetType(type_ EntityType) {
	e.Type = type_
	e.require(entityIDFieldType)
}

// SetAppID sets the AppID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityID) SetAppID(appID string) {
	e.AppID = appID
	e.require(entityIDFieldAppID)
}

// SetOrganizationID sets the OrganizationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityID) SetOrganizationID(organizationID string) {
	e.OrganizationID = organizationID
	e.require(entityIDFieldOrganizationID)
}

// SetAgentID sets the AgentID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityID) SetAgentID(agentID string) {
	e.AgentID = agentID
	e.require(entityIDFieldAgentID)
}

func (e *EntityID) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityID
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityID(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityID) MarshalJSON() ([]byte, error) {
	type embed EntityID
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityID) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// All other entityId fields are inferred from the API request.
var (
	entityIDBaseFieldReferenceID = big.NewInt(1 << 0)
)

type EntityIDBase struct {
	// Externally supplied ID to uniquely identify this object. Is globally unique when combined with all other entityId fields (type, appId, organizationId, agentId).
	//
	// Must be less than 192 characters and contain only:
	// - alphanumeric characters (`a-z`, `A-Z`, `0-9`)
	// - hyphens (`-`)
	// - underscores (`_`)
	// - plus signs (`+`)
	// - periods (`.`)
	// - at symbol (`@`)
	// - pipe symbol (`|`)
	ReferenceID string `json:"referenceId" url:"referenceId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityIDBase) GetReferenceID() string {
	if e == nil {
		return ""
	}
	return e.ReferenceID
}

func (e *EntityIDBase) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityIDBase) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetReferenceID sets the ReferenceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIDBase) SetReferenceID(referenceID string) {
	e.ReferenceID = referenceID
	e.require(entityIDBaseFieldReferenceID)
}

func (e *EntityIDBase) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityIDBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityIDBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityIDBase) MarshalJSON() ([]byte, error) {
	type embed EntityIDBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityIDBase) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	entityIDFilterFieldReferenceID = big.NewInt(1 << 0)
	entityIDFilterFieldAppID       = big.NewInt(1 << 1)
)

type EntityIDFilter struct {
	ReferenceID string `json:"referenceId" url:"referenceId"`
	AppID       string `json:"appId" url:"appId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityIDFilter) GetReferenceID() string {
	if e == nil {
		return ""
	}
	return e.ReferenceID
}

func (e *EntityIDFilter) GetAppID() string {
	if e == nil {
		return ""
	}
	return e.AppID
}

func (e *EntityIDFilter) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityIDFilter) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetReferenceID sets the ReferenceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIDFilter) SetReferenceID(referenceID string) {
	e.ReferenceID = referenceID
	e.require(entityIDFilterFieldReferenceID)
}

// SetAppID sets the AppID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIDFilter) SetAppID(appID string) {
	e.AppID = appID
	e.require(entityIDFilterFieldAppID)
}

func (e *EntityIDFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityIDFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityIDFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityIDFilter) MarshalJSON() ([]byte, error) {
	type embed EntityIDFilter
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityIDFilter) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The organizationId and agentId are inferred from the context.
var (
	entityIDWithoutAgentFieldReferenceID = big.NewInt(1 << 0)
	entityIDWithoutAgentFieldType        = big.NewInt(1 << 1)
	entityIDWithoutAgentFieldAppID       = big.NewInt(1 << 2)
)

type EntityIDWithoutAgent struct {
	// Externally supplied ID to uniquely identify this object. Is globally unique when combined with all other entityId fields (type, appId, organizationId, agentId).
	//
	// Must be less than 192 characters and contain only:
	// - alphanumeric characters (`a-z`, `A-Z`, `0-9`)
	// - hyphens (`-`)
	// - underscores (`_`)
	// - plus signs (`+`)
	// - periods (`.`)
	// - at symbol (`@`)
	// - pipe symbol (`|`)
	ReferenceID string `json:"referenceId" url:"referenceId"`
	// The object type
	Type EntityType `json:"type" url:"type"`
	// The ID of the application that created this object
	AppID string `json:"appId" url:"appId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityIDWithoutAgent) GetReferenceID() string {
	if e == nil {
		return ""
	}
	return e.ReferenceID
}

func (e *EntityIDWithoutAgent) GetType() EntityType {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EntityIDWithoutAgent) GetAppID() string {
	if e == nil {
		return ""
	}
	return e.AppID
}

func (e *EntityIDWithoutAgent) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityIDWithoutAgent) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetReferenceID sets the ReferenceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIDWithoutAgent) SetReferenceID(referenceID string) {
	e.ReferenceID = referenceID
	e.require(entityIDWithoutAgentFieldReferenceID)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIDWithoutAgent) SetType(type_ EntityType) {
	e.Type = type_
	e.require(entityIDWithoutAgentFieldType)
}

// SetAppID sets the AppID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIDWithoutAgent) SetAppID(appID string) {
	e.AppID = appID
	e.require(entityIDWithoutAgentFieldAppID)
}

func (e *EntityIDWithoutAgent) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityIDWithoutAgent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityIDWithoutAgent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityIDWithoutAgent) MarshalJSON() ([]byte, error) {
	type embed EntityIDWithoutAgent
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityIDWithoutAgent) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	entityResultFieldReferenceID = big.NewInt(1 << 0)
	entityResultFieldAppID       = big.NewInt(1 << 1)
	entityResultFieldName        = big.NewInt(1 << 2)
)

type EntityResult struct {
	ReferenceID string `json:"referenceId" url:"referenceId"`
	AppID       string `json:"appId" url:"appId"`
	// Human-readable name for the referenced entity (e.g., action name or document title).
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityResult) GetReferenceID() string {
	if e == nil {
		return ""
	}
	return e.ReferenceID
}

func (e *EntityResult) GetAppID() string {
	if e == nil {
		return ""
	}
	return e.AppID
}

func (e *EntityResult) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EntityResult) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityResult) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetReferenceID sets the ReferenceID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityResult) SetReferenceID(referenceID string) {
	e.ReferenceID = referenceID
	e.require(entityResultFieldReferenceID)
}

// SetAppID sets the AppID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityResult) SetAppID(appID string) {
	e.AppID = appID
	e.require(entityResultFieldAppID)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityResult) SetName(name *string) {
	e.Name = name
	e.require(entityResultFieldName)
}

func (e *EntityResult) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityResult) MarshalJSON() ([]byte, error) {
	type embed EntityResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityResult) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityType string

const (
	EntityTypeAgent                EntityType = "AGENT"
	EntityTypeConversation         EntityType = "CONVERSATION"
	EntityTypeConversationMessage  EntityType = "CONVERSATION_MESSAGE"
	EntityTypeKnowledgeBase        EntityType = "KNOWLEDGE_BASE"
	EntityTypeKnowledgeBaseVersion EntityType = "KNOWLEDGE_BASE_VERSION"
	EntityTypeKnowledgeDocument    EntityType = "KNOWLEDGE_DOCUMENT"
	EntityTypeAction               EntityType = "ACTION"
	EntityTypeUser                 EntityType = "USER"
	EntityTypeEvent                EntityType = "EVENT"
	EntityTypeEventTrigger         EntityType = "EVENT_TRIGGER"
	EntityTypeUserProfile          EntityType = "USER_PROFILE"
	EntityTypeFeedback             EntityType = "FEEDBACK"
	EntityTypeInboxItem            EntityType = "INBOX_ITEM"
	EntityTypeInboxItemFix         EntityType = "INBOX_ITEM_FIX"
	EntityTypeSegment              EntityType = "SEGMENT"
	EntityTypeCustomer             EntityType = "CUSTOMER"
	EntityTypeIntelligentField     EntityType = "INTELLIGENT_FIELD"
)

func NewEntityTypeFromString(s string) (EntityType, error) {
	switch s {
	case "AGENT":
		return EntityTypeAgent, nil
	case "CONVERSATION":
		return EntityTypeConversation, nil
	case "CONVERSATION_MESSAGE":
		return EntityTypeConversationMessage, nil
	case "KNOWLEDGE_BASE":
		return EntityTypeKnowledgeBase, nil
	case "KNOWLEDGE_BASE_VERSION":
		return EntityTypeKnowledgeBaseVersion, nil
	case "KNOWLEDGE_DOCUMENT":
		return EntityTypeKnowledgeDocument, nil
	case "ACTION":
		return EntityTypeAction, nil
	case "USER":
		return EntityTypeUser, nil
	case "EVENT":
		return EntityTypeEvent, nil
	case "EVENT_TRIGGER":
		return EntityTypeEventTrigger, nil
	case "USER_PROFILE":
		return EntityTypeUserProfile, nil
	case "FEEDBACK":
		return EntityTypeFeedback, nil
	case "INBOX_ITEM":
		return EntityTypeInboxItem, nil
	case "INBOX_ITEM_FIX":
		return EntityTypeInboxItemFix, nil
	case "SEGMENT":
		return EntityTypeSegment, nil
	case "CUSTOMER":
		return EntityTypeCustomer, nil
	case "INTELLIGENT_FIELD":
		return EntityTypeIntelligentField, nil
	}
	var t EntityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityType) Ptr() *EntityType {
	return &e
}

var (
	errorMessageFieldMessage = big.NewInt(1 << 0)
)

type ErrorMessage struct {
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ErrorMessage) GetMessage() *string {
	if e == nil {
		return nil
	}
	return e.Message
}

func (e *ErrorMessage) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorMessage) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ErrorMessage) SetMessage(message *string) {
	e.Message = message
	e.require(errorMessageFieldMessage)
}

func (e *ErrorMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorMessage) MarshalJSON() ([]byte, error) {
	type embed ErrorMessage
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ErrorMessage) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventBaseNoIDFieldTimestamp   = big.NewInt(1 << 0)
	eventBaseNoIDFieldReferences  = big.NewInt(1 << 1)
	eventBaseNoIDFieldSourceInfo  = big.NewInt(1 << 2)
	eventBaseNoIDFieldSessionInfo = big.NewInt(1 << 3)
	eventBaseNoIDFieldContextInfo = big.NewInt(1 << 4)
)

type EventBaseNoID struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventBaseNoID) GetTimestamp() *time.Time {
	if e == nil {
		return nil
	}
	return e.Timestamp
}

func (e *EventBaseNoID) GetReferences() []*ScopedEntity {
	if e == nil {
		return nil
	}
	return e.References
}

func (e *EventBaseNoID) GetSourceInfo() *SourceInfo {
	if e == nil {
		return nil
	}
	return e.SourceInfo
}

func (e *EventBaseNoID) GetSessionInfo() *SessionInfo {
	if e == nil {
		return nil
	}
	return e.SessionInfo
}

func (e *EventBaseNoID) GetContextInfo() *ContextInfo {
	if e == nil {
		return nil
	}
	return e.ContextInfo
}

func (e *EventBaseNoID) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventBaseNoID) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBaseNoID) SetTimestamp(timestamp *time.Time) {
	e.Timestamp = timestamp
	e.require(eventBaseNoIDFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBaseNoID) SetReferences(references []*ScopedEntity) {
	e.References = references
	e.require(eventBaseNoIDFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBaseNoID) SetSourceInfo(sourceInfo *SourceInfo) {
	e.SourceInfo = sourceInfo
	e.require(eventBaseNoIDFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBaseNoID) SetSessionInfo(sessionInfo *SessionInfo) {
	e.SessionInfo = sessionInfo
	e.require(eventBaseNoIDFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBaseNoID) SetContextInfo(contextInfo *ContextInfo) {
	e.ContextInfo = contextInfo
	e.require(eventBaseNoIDFieldContextInfo)
}

func (e *EventBaseNoID) UnmarshalJSON(data []byte) error {
	type embed EventBaseNoID
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EventBaseNoID(unmarshaler.embed)
	e.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventBaseNoID) MarshalJSON() ([]byte, error) {
	type embed EventBaseNoID
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*e),
		Timestamp: internal.NewOptionalDateTime(e.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventBaseNoID) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventField string

const (
	EventFieldCreatedAt          EventField = "CREATED_AT"
	EventFieldEventName          EventField = "EVENT_NAME"
	EventFieldEventType          EventField = "EVENT_TYPE"
	EventFieldApp                EventField = "APP"
	EventFieldSessionID          EventField = "SESSION_ID"
	EventFieldSourceType         EventField = "SOURCE_TYPE"
	EventFieldSourceLanguageCode EventField = "SOURCE_LANGUAGE_CODE"
	EventFieldSourceDeviceType   EventField = "SOURCE_DEVICE_TYPE"
	EventFieldSourceDeviceName   EventField = "SOURCE_DEVICE_NAME"
	EventFieldSourceBrowserType  EventField = "SOURCE_BROWSER_TYPE"
	EventFieldSourceBrowserName  EventField = "SOURCE_BROWSER_NAME"
	EventFieldSourceGeoCity      EventField = "SOURCE_GEO_CITY"
	EventFieldSourceGeoState     EventField = "SOURCE_GEO_STATE"
	EventFieldSourceGeoCountry   EventField = "SOURCE_GEO_COUNTRY"
	EventFieldUserReferenceID    EventField = "USER_REFERENCE_ID"
	EventFieldAgentUserID        EventField = "AGENT_USER_ID"
	EventFieldTimestamp          EventField = "TIMESTAMP"
)

func NewEventFieldFromString(s string) (EventField, error) {
	switch s {
	case "CREATED_AT":
		return EventFieldCreatedAt, nil
	case "EVENT_NAME":
		return EventFieldEventName, nil
	case "EVENT_TYPE":
		return EventFieldEventType, nil
	case "APP":
		return EventFieldApp, nil
	case "SESSION_ID":
		return EventFieldSessionID, nil
	case "SOURCE_TYPE":
		return EventFieldSourceType, nil
	case "SOURCE_LANGUAGE_CODE":
		return EventFieldSourceLanguageCode, nil
	case "SOURCE_DEVICE_TYPE":
		return EventFieldSourceDeviceType, nil
	case "SOURCE_DEVICE_NAME":
		return EventFieldSourceDeviceName, nil
	case "SOURCE_BROWSER_TYPE":
		return EventFieldSourceBrowserType, nil
	case "SOURCE_BROWSER_NAME":
		return EventFieldSourceBrowserName, nil
	case "SOURCE_GEO_CITY":
		return EventFieldSourceGeoCity, nil
	case "SOURCE_GEO_STATE":
		return EventFieldSourceGeoState, nil
	case "SOURCE_GEO_COUNTRY":
		return EventFieldSourceGeoCountry, nil
	case "USER_REFERENCE_ID":
		return EventFieldUserReferenceID, nil
	case "AGENT_USER_ID":
		return EventFieldAgentUserID, nil
	case "TIMESTAMP":
		return EventFieldTimestamp, nil
	}
	var t EventField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventField) Ptr() *EventField {
	return &e
}

var (
	eventFilterFieldSearch              = big.NewInt(1 << 0)
	eventFilterFieldCreatedAfter        = big.NewInt(1 << 1)
	eventFilterFieldCreatedBefore       = big.NewInt(1 << 2)
	eventFilterFieldReferences          = big.NewInt(1 << 3)
	eventFilterFieldEventTypes          = big.NewInt(1 << 4)
	eventFilterFieldUserEventNames      = big.NewInt(1 << 5)
	eventFilterFieldSystemEventNames    = big.NewInt(1 << 6)
	eventFilterFieldAgentUserIDs        = big.NewInt(1 << 7)
	eventFilterFieldLegacyFeedbackTypes = big.NewInt(1 << 8)
	eventFilterFieldHasEventText        = big.NewInt(1 << 9)
)

type EventFilter struct {
	Search              *string           `json:"search,omitempty" url:"search,omitempty"`
	CreatedAfter        *time.Time        `json:"createdAfter,omitempty" url:"createdAfter,omitempty"`
	CreatedBefore       *time.Time        `json:"createdBefore,omitempty" url:"createdBefore,omitempty"`
	References          []*ScopedEntity   `json:"references,omitempty" url:"references,omitempty"`
	EventTypes          []EventType       `json:"eventTypes,omitempty" url:"eventTypes,omitempty"`
	UserEventNames      []UserEventName   `json:"userEventNames,omitempty" url:"userEventNames,omitempty"`
	SystemEventNames    []SystemEventName `json:"systemEventNames,omitempty" url:"systemEventNames,omitempty"`
	AgentUserIDs        []string          `json:"agentUserIds,omitempty" url:"agentUserIds,omitempty"`
	LegacyFeedbackTypes []FeedbackType    `json:"legacyFeedbackTypes,omitempty" url:"legacyFeedbackTypes,omitempty"`
	HasEventText        *bool             `json:"hasEventText,omitempty" url:"hasEventText,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventFilter) GetSearch() *string {
	if e == nil {
		return nil
	}
	return e.Search
}

func (e *EventFilter) GetCreatedAfter() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedAfter
}

func (e *EventFilter) GetCreatedBefore() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedBefore
}

func (e *EventFilter) GetReferences() []*ScopedEntity {
	if e == nil {
		return nil
	}
	return e.References
}

func (e *EventFilter) GetEventTypes() []EventType {
	if e == nil {
		return nil
	}
	return e.EventTypes
}

func (e *EventFilter) GetUserEventNames() []UserEventName {
	if e == nil {
		return nil
	}
	return e.UserEventNames
}

func (e *EventFilter) GetSystemEventNames() []SystemEventName {
	if e == nil {
		return nil
	}
	return e.SystemEventNames
}

func (e *EventFilter) GetAgentUserIDs() []string {
	if e == nil {
		return nil
	}
	return e.AgentUserIDs
}

func (e *EventFilter) GetLegacyFeedbackTypes() []FeedbackType {
	if e == nil {
		return nil
	}
	return e.LegacyFeedbackTypes
}

func (e *EventFilter) GetHasEventText() *bool {
	if e == nil {
		return nil
	}
	return e.HasEventText
}

func (e *EventFilter) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventFilter) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetSearch sets the Search field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetSearch(search *string) {
	e.Search = search
	e.require(eventFilterFieldSearch)
}

// SetCreatedAfter sets the CreatedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetCreatedAfter(createdAfter *time.Time) {
	e.CreatedAfter = createdAfter
	e.require(eventFilterFieldCreatedAfter)
}

// SetCreatedBefore sets the CreatedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetCreatedBefore(createdBefore *time.Time) {
	e.CreatedBefore = createdBefore
	e.require(eventFilterFieldCreatedBefore)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetReferences(references []*ScopedEntity) {
	e.References = references
	e.require(eventFilterFieldReferences)
}

// SetEventTypes sets the EventTypes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetEventTypes(eventTypes []EventType) {
	e.EventTypes = eventTypes
	e.require(eventFilterFieldEventTypes)
}

// SetUserEventNames sets the UserEventNames field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetUserEventNames(userEventNames []UserEventName) {
	e.UserEventNames = userEventNames
	e.require(eventFilterFieldUserEventNames)
}

// SetSystemEventNames sets the SystemEventNames field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetSystemEventNames(systemEventNames []SystemEventName) {
	e.SystemEventNames = systemEventNames
	e.require(eventFilterFieldSystemEventNames)
}

// SetAgentUserIDs sets the AgentUserIDs field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetAgentUserIDs(agentUserIDs []string) {
	e.AgentUserIDs = agentUserIDs
	e.require(eventFilterFieldAgentUserIDs)
}

// SetLegacyFeedbackTypes sets the LegacyFeedbackTypes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetLegacyFeedbackTypes(legacyFeedbackTypes []FeedbackType) {
	e.LegacyFeedbackTypes = legacyFeedbackTypes
	e.require(eventFilterFieldLegacyFeedbackTypes)
}

// SetHasEventText sets the HasEventText field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetHasEventText(hasEventText *bool) {
	e.HasEventText = hasEventText
	e.require(eventFilterFieldHasEventText)
}

func (e *EventFilter) UnmarshalJSON(data []byte) error {
	type embed EventFilter
	var unmarshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EventFilter(unmarshaler.embed)
	e.CreatedAfter = unmarshaler.CreatedAfter.TimePtr()
	e.CreatedBefore = unmarshaler.CreatedBefore.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventFilter) MarshalJSON() ([]byte, error) {
	type embed EventFilter
	var marshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed:         embed(*e),
		CreatedAfter:  internal.NewOptionalDateTime(e.CreatedAfter),
		CreatedBefore: internal.NewOptionalDateTime(e.CreatedBefore),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventFilter) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventRequest struct {
	EventType   string
	UserEvent   *NovelUserEvent
	SystemEvent *NovelSystemEvent
}

func (e *EventRequest) GetEventType() string {
	if e == nil {
		return ""
	}
	return e.EventType
}

func (e *EventRequest) GetUserEvent() *NovelUserEvent {
	if e == nil {
		return nil
	}
	return e.UserEvent
}

func (e *EventRequest) GetSystemEvent() *NovelSystemEvent {
	if e == nil {
		return nil
	}
	return e.SystemEvent
}

func (e *EventRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"eventType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.EventType = unmarshaler.EventType
	if unmarshaler.EventType == "" {
		return fmt.Errorf("%T did not include discriminant eventType", e)
	}
	switch unmarshaler.EventType {
	case "userEvent":
		value := new(NovelUserEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.UserEvent = value
	case "systemEvent":
		value := new(NovelSystemEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SystemEvent = value
	}
	return nil
}

func (e EventRequest) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.UserEvent != nil {
		return internal.MarshalJSONWithExtraProperty(e.UserEvent, "eventType", "userEvent")
	}
	if e.SystemEvent != nil {
		return internal.MarshalJSONWithExtraProperty(e.SystemEvent, "eventType", "systemEvent")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EventRequestVisitor interface {
	VisitUserEvent(*NovelUserEvent) error
	VisitSystemEvent(*NovelSystemEvent) error
}

func (e *EventRequest) Accept(visitor EventRequestVisitor) error {
	if e.UserEvent != nil {
		return visitor.VisitUserEvent(e.UserEvent)
	}
	if e.SystemEvent != nil {
		return visitor.VisitSystemEvent(e.SystemEvent)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *EventRequest) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.UserEvent != nil {
		fields = append(fields, "userEvent")
	}
	if e.SystemEvent != nil {
		fields = append(fields, "systemEvent")
	}
	if len(fields) == 0 {
		if e.EventType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.EventType)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.EventType != "" {
		field := fields[0]
		if e.EventType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.EventType,
				e,
			)
		}
	}
	return nil
}

type EventResponse struct {
	EventType   string
	UserEvent   *UserEvent
	SystemEvent *SystemEvent
}

func (e *EventResponse) GetEventType() string {
	if e == nil {
		return ""
	}
	return e.EventType
}

func (e *EventResponse) GetUserEvent() *UserEvent {
	if e == nil {
		return nil
	}
	return e.UserEvent
}

func (e *EventResponse) GetSystemEvent() *SystemEvent {
	if e == nil {
		return nil
	}
	return e.SystemEvent
}

func (e *EventResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"eventType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.EventType = unmarshaler.EventType
	if unmarshaler.EventType == "" {
		return fmt.Errorf("%T did not include discriminant eventType", e)
	}
	switch unmarshaler.EventType {
	case "userEvent":
		value := new(UserEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.UserEvent = value
	case "systemEvent":
		value := new(SystemEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SystemEvent = value
	}
	return nil
}

func (e EventResponse) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.UserEvent != nil {
		return internal.MarshalJSONWithExtraProperty(e.UserEvent, "eventType", "userEvent")
	}
	if e.SystemEvent != nil {
		return internal.MarshalJSONWithExtraProperty(e.SystemEvent, "eventType", "systemEvent")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EventResponseVisitor interface {
	VisitUserEvent(*UserEvent) error
	VisitSystemEvent(*SystemEvent) error
}

func (e *EventResponse) Accept(visitor EventResponseVisitor) error {
	if e.UserEvent != nil {
		return visitor.VisitUserEvent(e.UserEvent)
	}
	if e.SystemEvent != nil {
		return visitor.VisitSystemEvent(e.SystemEvent)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *EventResponse) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.UserEvent != nil {
		fields = append(fields, "userEvent")
	}
	if e.SystemEvent != nil {
		fields = append(fields, "systemEvent")
	}
	if len(fields) == 0 {
		if e.EventType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.EventType)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.EventType != "" {
		field := fields[0]
		if e.EventType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.EventType,
				e,
			)
		}
	}
	return nil
}

type EventTriggerType string

const (
	EventTriggerTypeConversationCreated EventTriggerType = "CONVERSATION_CREATED"
	EventTriggerTypeFeedbackCreated     EventTriggerType = "FEEDBACK_CREATED"
	EventTriggerTypeInboxItemCreated    EventTriggerType = "INBOX_ITEM_CREATED"
	EventTriggerTypeEventCreated        EventTriggerType = "EVENT_CREATED"
)

func NewEventTriggerTypeFromString(s string) (EventTriggerType, error) {
	switch s {
	case "CONVERSATION_CREATED":
		return EventTriggerTypeConversationCreated, nil
	case "FEEDBACK_CREATED":
		return EventTriggerTypeFeedbackCreated, nil
	case "INBOX_ITEM_CREATED":
		return EventTriggerTypeInboxItemCreated, nil
	case "EVENT_CREATED":
		return EventTriggerTypeEventCreated, nil
	}
	var t EventTriggerType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventTriggerType) Ptr() *EventTriggerType {
	return &e
}

type EventType string

const (
	EventTypeUser   EventType = "USER"
	EventTypeSystem EventType = "SYSTEM"
)

func NewEventTypeFromString(s string) (EventType, error) {
	switch s {
	case "USER":
		return EventTypeUser, nil
	case "SYSTEM":
		return EventTypeSystem, nil
	}
	var t EventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventType) Ptr() *EventType {
	return &e
}

var (
	eventUserInfoFieldID              = big.NewInt(1 << 0)
	eventUserInfoFieldUserDisplayName = big.NewInt(1 << 1)
)

type EventUserInfo struct {
	ID              *EntityID `json:"id,omitempty" url:"id,omitempty"`
	UserDisplayName *string   `json:"userDisplayName,omitempty" url:"userDisplayName,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventUserInfo) GetID() *EntityID {
	if e == nil {
		return nil
	}
	return e.ID
}

func (e *EventUserInfo) GetUserDisplayName() *string {
	if e == nil {
		return nil
	}
	return e.UserDisplayName
}

func (e *EventUserInfo) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventUserInfo) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventUserInfo) SetID(id *EntityID) {
	e.ID = id
	e.require(eventUserInfoFieldID)
}

// SetUserDisplayName sets the UserDisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventUserInfo) SetUserDisplayName(userDisplayName *string) {
	e.UserDisplayName = userDisplayName
	e.require(eventUserInfoFieldUserDisplayName)
}

func (e *EventUserInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler EventUserInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventUserInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventUserInfo) MarshalJSON() ([]byte, error) {
	type embed EventUserInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventUserInfo) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventUserInfoBaseFieldID = big.NewInt(1 << 0)
)

type EventUserInfoBase struct {
	ID *EntityIDBase `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventUserInfoBase) GetID() *EntityIDBase {
	if e == nil {
		return nil
	}
	return e.ID
}

func (e *EventUserInfoBase) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventUserInfoBase) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventUserInfoBase) SetID(id *EntityIDBase) {
	e.ID = id
	e.require(eventUserInfoBaseFieldID)
}

func (e *EventUserInfoBase) UnmarshalJSON(data []byte) error {
	type unmarshaler EventUserInfoBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventUserInfoBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventUserInfoBase) MarshalJSON() ([]byte, error) {
	type embed EventUserInfoBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventUserInfoBase) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventsSearchRequestFieldPage     = big.NewInt(1 << 0)
	eventsSearchRequestFieldSize     = big.NewInt(1 << 1)
	eventsSearchRequestFieldSortDesc = big.NewInt(1 << 2)
	eventsSearchRequestFieldSort     = big.NewInt(1 << 3)
	eventsSearchRequestFieldFilter   = big.NewInt(1 << 4)
)

type EventsSearchRequest struct {
	// Page number to return, defaults to 0
	Page *int `json:"page,omitempty" url:"page,omitempty"`
	// The size of the page to return, defaults to 20
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Whether to sort descending, defaults to true
	SortDesc *bool        `json:"sortDesc,omitempty" url:"sortDesc,omitempty"`
	Sort     *EventField  `json:"sort,omitempty" url:"sort,omitempty"`
	Filter   *EventFilter `json:"filter,omitempty" url:"filter,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventsSearchRequest) GetPage() *int {
	if e == nil {
		return nil
	}
	return e.Page
}

func (e *EventsSearchRequest) GetSize() *int {
	if e == nil {
		return nil
	}
	return e.Size
}

func (e *EventsSearchRequest) GetSortDesc() *bool {
	if e == nil {
		return nil
	}
	return e.SortDesc
}

func (e *EventsSearchRequest) GetSort() *EventField {
	if e == nil {
		return nil
	}
	return e.Sort
}

func (e *EventsSearchRequest) GetFilter() *EventFilter {
	if e == nil {
		return nil
	}
	return e.Filter
}

func (e *EventsSearchRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventsSearchRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchRequest) SetPage(page *int) {
	e.Page = page
	e.require(eventsSearchRequestFieldPage)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchRequest) SetSize(size *int) {
	e.Size = size
	e.require(eventsSearchRequestFieldSize)
}

// SetSortDesc sets the SortDesc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchRequest) SetSortDesc(sortDesc *bool) {
	e.SortDesc = sortDesc
	e.require(eventsSearchRequestFieldSortDesc)
}

// SetSort sets the Sort field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchRequest) SetSort(sort *EventField) {
	e.Sort = sort
	e.require(eventsSearchRequestFieldSort)
}

// SetFilter sets the Filter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchRequest) SetFilter(filter *EventFilter) {
	e.Filter = filter
	e.require(eventsSearchRequestFieldFilter)
}

func (e *EventsSearchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EventsSearchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventsSearchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventsSearchRequest) MarshalJSON() ([]byte, error) {
	type embed EventsSearchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventsSearchRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventsSearchResponseFieldNumber        = big.NewInt(1 << 0)
	eventsSearchResponseFieldSize          = big.NewInt(1 << 1)
	eventsSearchResponseFieldTotalElements = big.NewInt(1 << 2)
	eventsSearchResponseFieldTotalPages    = big.NewInt(1 << 3)
	eventsSearchResponseFieldEvents        = big.NewInt(1 << 4)
)

type EventsSearchResponse struct {
	// The page being returned, starts at 0
	Number int `json:"number" url:"number"`
	// The number of elements in this page
	Size int `json:"size" url:"size"`
	// The total number of elements in the collection
	TotalElements int64 `json:"totalElements" url:"totalElements"`
	// The total number of pages in the collection
	TotalPages int `json:"totalPages" url:"totalPages"`
	// The list of events
	Events []*EventResponse `json:"events" url:"events"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventsSearchResponse) GetNumber() int {
	if e == nil {
		return 0
	}
	return e.Number
}

func (e *EventsSearchResponse) GetSize() int {
	if e == nil {
		return 0
	}
	return e.Size
}

func (e *EventsSearchResponse) GetTotalElements() int64 {
	if e == nil {
		return 0
	}
	return e.TotalElements
}

func (e *EventsSearchResponse) GetTotalPages() int {
	if e == nil {
		return 0
	}
	return e.TotalPages
}

func (e *EventsSearchResponse) GetEvents() []*EventResponse {
	if e == nil {
		return nil
	}
	return e.Events
}

func (e *EventsSearchResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventsSearchResponse) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetNumber sets the Number field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchResponse) SetNumber(number int) {
	e.Number = number
	e.require(eventsSearchResponseFieldNumber)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchResponse) SetSize(size int) {
	e.Size = size
	e.require(eventsSearchResponseFieldSize)
}

// SetTotalElements sets the TotalElements field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchResponse) SetTotalElements(totalElements int64) {
	e.TotalElements = totalElements
	e.require(eventsSearchResponseFieldTotalElements)
}

// SetTotalPages sets the TotalPages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchResponse) SetTotalPages(totalPages int) {
	e.TotalPages = totalPages
	e.require(eventsSearchResponseFieldTotalPages)
}

// SetEvents sets the Events field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchResponse) SetEvents(events []*EventResponse) {
	e.Events = events
	e.require(eventsSearchResponseFieldEvents)
}

func (e *EventsSearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EventsSearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventsSearchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventsSearchResponse) MarshalJSON() ([]byte, error) {
	type embed EventsSearchResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventsSearchResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	feedbackFieldType                  = big.NewInt(1 << 0)
	feedbackFieldText                  = big.NewInt(1 << 1)
	feedbackFieldFeedbackID            = big.NewInt(1 << 2)
	feedbackFieldConversationID        = big.NewInt(1 << 3)
	feedbackFieldConversationMessageID = big.NewInt(1 << 4)
	feedbackFieldUserID                = big.NewInt(1 << 5)
	feedbackFieldCreatedAt             = big.NewInt(1 << 6)
)

type Feedback struct {
	// The type of feedback
	Type FeedbackType `json:"type" url:"type"`
	// The feedback text
	Text *string `json:"text,omitempty" url:"text,omitempty"`
	// The ID of the piece of feedback
	FeedbackID *EntityID `json:"feedbackId" url:"feedbackId"`
	// The ID of the conversation the feedback is about
	ConversationID *EntityID `json:"conversationId" url:"conversationId"`
	// The ID of the conversation message the feedback is about
	ConversationMessageID *EntityID `json:"conversationMessageId" url:"conversationMessageId"`
	// The ID of the user who created the feedback
	UserID *EntityID `json:"userId,omitempty" url:"userId,omitempty"`
	// The date and time the feedback was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Feedback) GetType() FeedbackType {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *Feedback) GetText() *string {
	if f == nil {
		return nil
	}
	return f.Text
}

func (f *Feedback) GetFeedbackID() *EntityID {
	if f == nil {
		return nil
	}
	return f.FeedbackID
}

func (f *Feedback) GetConversationID() *EntityID {
	if f == nil {
		return nil
	}
	return f.ConversationID
}

func (f *Feedback) GetConversationMessageID() *EntityID {
	if f == nil {
		return nil
	}
	return f.ConversationMessageID
}

func (f *Feedback) GetUserID() *EntityID {
	if f == nil {
		return nil
	}
	return f.UserID
}

func (f *Feedback) GetCreatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.CreatedAt
}

func (f *Feedback) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Feedback) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetType(type_ FeedbackType) {
	f.Type = type_
	f.require(feedbackFieldType)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetText(text *string) {
	f.Text = text
	f.require(feedbackFieldText)
}

// SetFeedbackID sets the FeedbackID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetFeedbackID(feedbackID *EntityID) {
	f.FeedbackID = feedbackID
	f.require(feedbackFieldFeedbackID)
}

// SetConversationID sets the ConversationID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetConversationID(conversationID *EntityID) {
	f.ConversationID = conversationID
	f.require(feedbackFieldConversationID)
}

// SetConversationMessageID sets the ConversationMessageID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetConversationMessageID(conversationMessageID *EntityID) {
	f.ConversationMessageID = conversationMessageID
	f.require(feedbackFieldConversationMessageID)
}

// SetUserID sets the UserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetUserID(userID *EntityID) {
	f.UserID = userID
	f.require(feedbackFieldUserID)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetCreatedAt(createdAt *time.Time) {
	f.CreatedAt = createdAt
	f.require(feedbackFieldCreatedAt)
}

func (f *Feedback) UnmarshalJSON(data []byte) error {
	type embed Feedback
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = Feedback(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Feedback) MarshalJSON() ([]byte, error) {
	type embed Feedback
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
	}{
		embed:     embed(*f),
		CreatedAt: internal.NewOptionalDateTime(f.CreatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *Feedback) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	feedbackBaseFieldType = big.NewInt(1 << 0)
	feedbackBaseFieldText = big.NewInt(1 << 1)
)

type FeedbackBase struct {
	// The type of feedback
	Type FeedbackType `json:"type" url:"type"`
	// The feedback text
	Text *string `json:"text,omitempty" url:"text,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackBase) GetType() FeedbackType {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FeedbackBase) GetText() *string {
	if f == nil {
		return nil
	}
	return f.Text
}

func (f *FeedbackBase) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackBase) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackBase) SetType(type_ FeedbackType) {
	f.Type = type_
	f.require(feedbackBaseFieldType)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackBase) SetText(text *string) {
	f.Text = text
	f.require(feedbackBaseFieldText)
}

func (f *FeedbackBase) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackBase) MarshalJSON() ([]byte, error) {
	type embed FeedbackBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackBase) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	feedbackInfoFieldRating  = big.NewInt(1 << 0)
	feedbackInfoFieldThumbUp = big.NewInt(1 << 1)
	feedbackInfoFieldSurvey  = big.NewInt(1 << 2)
)

type FeedbackInfo struct {
	// The rating of the feedback as a ratio [0.0, 1.0]
	Rating *float64 `json:"rating,omitempty" url:"rating,omitempty"`
	// Whether the feedback was marked as a thumbs up
	ThumbUp *bool `json:"thumbUp,omitempty" url:"thumbUp,omitempty"`
	// A question and answer associated with the feedback
	Survey *SurveyInfo `json:"survey,omitempty" url:"survey,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackInfo) GetRating() *float64 {
	if f == nil {
		return nil
	}
	return f.Rating
}

func (f *FeedbackInfo) GetThumbUp() *bool {
	if f == nil {
		return nil
	}
	return f.ThumbUp
}

func (f *FeedbackInfo) GetSurvey() *SurveyInfo {
	if f == nil {
		return nil
	}
	return f.Survey
}

func (f *FeedbackInfo) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackInfo) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetRating sets the Rating field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackInfo) SetRating(rating *float64) {
	f.Rating = rating
	f.require(feedbackInfoFieldRating)
}

// SetThumbUp sets the ThumbUp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackInfo) SetThumbUp(thumbUp *bool) {
	f.ThumbUp = thumbUp
	f.require(feedbackInfoFieldThumbUp)
}

// SetSurvey sets the Survey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackInfo) SetSurvey(survey *SurveyInfo) {
	f.Survey = survey
	f.require(feedbackInfoFieldSurvey)
}

func (f *FeedbackInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackInfo) MarshalJSON() ([]byte, error) {
	type embed FeedbackInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackInfo) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The type of feedback
type FeedbackType string

const (
	FeedbackTypeThumbsUp   FeedbackType = "THUMBS_UP"
	FeedbackTypeThumbsDown FeedbackType = "THUMBS_DOWN"
	FeedbackTypeInsert     FeedbackType = "INSERT"
	FeedbackTypeHandoff    FeedbackType = "HANDOFF"
)

func NewFeedbackTypeFromString(s string) (FeedbackType, error) {
	switch s {
	case "THUMBS_UP":
		return FeedbackTypeThumbsUp, nil
	case "THUMBS_DOWN":
		return FeedbackTypeThumbsDown, nil
	case "INSERT":
		return FeedbackTypeInsert, nil
	case "HANDOFF":
		return FeedbackTypeHandoff, nil
	}
	var t FeedbackType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FeedbackType) Ptr() *FeedbackType {
	return &f
}

var (
	geoInfoFieldCity      = big.NewInt(1 << 0)
	geoInfoFieldState     = big.NewInt(1 << 1)
	geoInfoFieldCountry   = big.NewInt(1 << 2)
	geoInfoFieldRegion    = big.NewInt(1 << 3)
	geoInfoFieldLatitude  = big.NewInt(1 << 4)
	geoInfoFieldLongitude = big.NewInt(1 << 5)
)

type GeoInfo struct {
	City      *string  `json:"city,omitempty" url:"city,omitempty"`
	State     *string  `json:"state,omitempty" url:"state,omitempty"`
	Country   *string  `json:"country,omitempty" url:"country,omitempty"`
	Region    *string  `json:"region,omitempty" url:"region,omitempty"`
	Latitude  *float64 `json:"latitude,omitempty" url:"latitude,omitempty"`
	Longitude *float64 `json:"longitude,omitempty" url:"longitude,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeoInfo) GetCity() *string {
	if g == nil {
		return nil
	}
	return g.City
}

func (g *GeoInfo) GetState() *string {
	if g == nil {
		return nil
	}
	return g.State
}

func (g *GeoInfo) GetCountry() *string {
	if g == nil {
		return nil
	}
	return g.Country
}

func (g *GeoInfo) GetRegion() *string {
	if g == nil {
		return nil
	}
	return g.Region
}

func (g *GeoInfo) GetLatitude() *float64 {
	if g == nil {
		return nil
	}
	return g.Latitude
}

func (g *GeoInfo) GetLongitude() *float64 {
	if g == nil {
		return nil
	}
	return g.Longitude
}

func (g *GeoInfo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeoInfo) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetCity sets the City field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetCity(city *string) {
	g.City = city
	g.require(geoInfoFieldCity)
}

// SetState sets the State field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetState(state *string) {
	g.State = state
	g.require(geoInfoFieldState)
}

// SetCountry sets the Country field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetCountry(country *string) {
	g.Country = country
	g.require(geoInfoFieldCountry)
}

// SetRegion sets the Region field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetRegion(region *string) {
	g.Region = region
	g.require(geoInfoFieldRegion)
}

// SetLatitude sets the Latitude field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetLatitude(latitude *float64) {
	g.Latitude = latitude
	g.require(geoInfoFieldLatitude)
}

// SetLongitude sets the Longitude field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetLongitude(longitude *float64) {
	g.Longitude = longitude
	g.require(geoInfoFieldLongitude)
}

func (g *GeoInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler GeoInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeoInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeoInfo) MarshalJSON() ([]byte, error) {
	type embed GeoInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GeoInfo) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

var (
	harmfulContentAnalysisFieldCategory               = big.NewInt(1 << 0)
	harmfulContentAnalysisFieldHarmfulContentDetected = big.NewInt(1 << 1)
	harmfulContentAnalysisFieldSeverity               = big.NewInt(1 << 2)
	harmfulContentAnalysisFieldThreshold              = big.NewInt(1 << 3)
)

type HarmfulContentAnalysis struct {
	// The category of harmful content analysis.
	Category string `json:"category" url:"category"`
	// Whether the analysis detected harmful content for this category. Will be true if the severity is greater than or equal to the threshold.
	HarmfulContentDetected bool `json:"harmfulContentDetected" url:"harmfulContentDetected"`
	// The severity of the harmful content analysis. Will be 0 if the category was not detected.
	Severity int `json:"severity" url:"severity"`
	// The threshold for the content safety analysis. If the severity is greater than or equal to the threshold, the analysis will be considered harmful.
	Threshold int `json:"threshold" url:"threshold"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (h *HarmfulContentAnalysis) GetCategory() string {
	if h == nil {
		return ""
	}
	return h.Category
}

func (h *HarmfulContentAnalysis) GetHarmfulContentDetected() bool {
	if h == nil {
		return false
	}
	return h.HarmfulContentDetected
}

func (h *HarmfulContentAnalysis) GetSeverity() int {
	if h == nil {
		return 0
	}
	return h.Severity
}

func (h *HarmfulContentAnalysis) GetThreshold() int {
	if h == nil {
		return 0
	}
	return h.Threshold
}

func (h *HarmfulContentAnalysis) GetExtraProperties() map[string]interface{} {
	return h.extraProperties
}

func (h *HarmfulContentAnalysis) require(field *big.Int) {
	if h.explicitFields == nil {
		h.explicitFields = big.NewInt(0)
	}
	h.explicitFields.Or(h.explicitFields, field)
}

// SetCategory sets the Category field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HarmfulContentAnalysis) SetCategory(category string) {
	h.Category = category
	h.require(harmfulContentAnalysisFieldCategory)
}

// SetHarmfulContentDetected sets the HarmfulContentDetected field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HarmfulContentAnalysis) SetHarmfulContentDetected(harmfulContentDetected bool) {
	h.HarmfulContentDetected = harmfulContentDetected
	h.require(harmfulContentAnalysisFieldHarmfulContentDetected)
}

// SetSeverity sets the Severity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HarmfulContentAnalysis) SetSeverity(severity int) {
	h.Severity = severity
	h.require(harmfulContentAnalysisFieldSeverity)
}

// SetThreshold sets the Threshold field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (h *HarmfulContentAnalysis) SetThreshold(threshold int) {
	h.Threshold = threshold
	h.require(harmfulContentAnalysisFieldThreshold)
}

func (h *HarmfulContentAnalysis) UnmarshalJSON(data []byte) error {
	type unmarshaler HarmfulContentAnalysis
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*h = HarmfulContentAnalysis(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *h)
	if err != nil {
		return err
	}
	h.extraProperties = extraProperties
	h.rawJSON = json.RawMessage(data)
	return nil
}

func (h *HarmfulContentAnalysis) MarshalJSON() ([]byte, error) {
	type embed HarmfulContentAnalysis
	var marshaler = struct {
		embed
	}{
		embed: embed(*h),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, h.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (h *HarmfulContentAnalysis) String() string {
	if len(h.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(h.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(h); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", h)
}

var (
	imageSettingsSchemaEntryFieldKey          = big.NewInt(1 << 0)
	imageSettingsSchemaEntryFieldDisplayName  = big.NewInt(1 << 1)
	imageSettingsSchemaEntryFieldDescription  = big.NewInt(1 << 2)
	imageSettingsSchemaEntryFieldVisibility   = big.NewInt(1 << 3)
	imageSettingsSchemaEntryFieldRequired     = big.NewInt(1 << 4)
	imageSettingsSchemaEntryFieldDefaultValue = big.NewInt(1 << 5)
)

type ImageSettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required     *bool   `json:"required,omitempty" url:"required,omitempty"`
	DefaultValue *string `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *ImageSettingsSchemaEntry) GetKey() string {
	if i == nil {
		return ""
	}
	return i.Key
}

func (i *ImageSettingsSchemaEntry) GetDisplayName() string {
	if i == nil {
		return ""
	}
	return i.DisplayName
}

func (i *ImageSettingsSchemaEntry) GetDescription() *string {
	if i == nil {
		return nil
	}
	return i.Description
}

func (i *ImageSettingsSchemaEntry) GetVisibility() *VisibilityType {
	if i == nil {
		return nil
	}
	return i.Visibility
}

func (i *ImageSettingsSchemaEntry) GetRequired() *bool {
	if i == nil {
		return nil
	}
	return i.Required
}

func (i *ImageSettingsSchemaEntry) GetDefaultValue() *string {
	if i == nil {
		return nil
	}
	return i.DefaultValue
}

func (i *ImageSettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *ImageSettingsSchemaEntry) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ImageSettingsSchemaEntry) SetKey(key string) {
	i.Key = key
	i.require(imageSettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ImageSettingsSchemaEntry) SetDisplayName(displayName string) {
	i.DisplayName = displayName
	i.require(imageSettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ImageSettingsSchemaEntry) SetDescription(description *string) {
	i.Description = description
	i.require(imageSettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ImageSettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	i.Visibility = visibility
	i.require(imageSettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ImageSettingsSchemaEntry) SetRequired(required *bool) {
	i.Required = required
	i.require(imageSettingsSchemaEntryFieldRequired)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *ImageSettingsSchemaEntry) SetDefaultValue(defaultValue *string) {
	i.DefaultValue = defaultValue
	i.require(imageSettingsSchemaEntryFieldDefaultValue)
}

func (i *ImageSettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler ImageSettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = ImageSettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *ImageSettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed ImageSettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *ImageSettingsSchemaEntry) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InboxItem struct {
	Type               string
	DuplicateDocuments *InboxItemDuplicateDocuments
	MissingKnowledge   *InboxItemMissingKnowledge
	Custom             *InboxItemCustom
}

func (i *InboxItem) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InboxItem) GetDuplicateDocuments() *InboxItemDuplicateDocuments {
	if i == nil {
		return nil
	}
	return i.DuplicateDocuments
}

func (i *InboxItem) GetMissingKnowledge() *InboxItemMissingKnowledge {
	if i == nil {
		return nil
	}
	return i.MissingKnowledge
}

func (i *InboxItem) GetCustom() *InboxItemCustom {
	if i == nil {
		return nil
	}
	return i.Custom
}

func (i *InboxItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "duplicateDocuments":
		value := new(InboxItemDuplicateDocuments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.DuplicateDocuments = value
	case "missingKnowledge":
		value := new(InboxItemMissingKnowledge)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.MissingKnowledge = value
	case "custom":
		value := new(InboxItemCustom)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Custom = value
	}
	return nil
}

func (i InboxItem) MarshalJSON() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	if i.DuplicateDocuments != nil {
		return internal.MarshalJSONWithExtraProperty(i.DuplicateDocuments, "type", "duplicateDocuments")
	}
	if i.MissingKnowledge != nil {
		return internal.MarshalJSONWithExtraProperty(i.MissingKnowledge, "type", "missingKnowledge")
	}
	if i.Custom != nil {
		return internal.MarshalJSONWithExtraProperty(i.Custom, "type", "custom")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type InboxItemVisitor interface {
	VisitDuplicateDocuments(*InboxItemDuplicateDocuments) error
	VisitMissingKnowledge(*InboxItemMissingKnowledge) error
	VisitCustom(*InboxItemCustom) error
}

func (i *InboxItem) Accept(visitor InboxItemVisitor) error {
	if i.DuplicateDocuments != nil {
		return visitor.VisitDuplicateDocuments(i.DuplicateDocuments)
	}
	if i.MissingKnowledge != nil {
		return visitor.VisitMissingKnowledge(i.MissingKnowledge)
	}
	if i.Custom != nil {
		return visitor.VisitCustom(i.Custom)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

func (i *InboxItem) validate() error {
	if i == nil {
		return fmt.Errorf("type %T is nil", i)
	}
	var fields []string
	if i.DuplicateDocuments != nil {
		fields = append(fields, "duplicateDocuments")
	}
	if i.MissingKnowledge != nil {
		fields = append(fields, "missingKnowledge")
	}
	if i.Custom != nil {
		fields = append(fields, "custom")
	}
	if len(fields) == 0 {
		if i.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", i, i.Type)
		}
		return fmt.Errorf("type %T is empty", i)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", i, fields)
	}
	if i.Type != "" {
		field := fields[0]
		if i.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				i,
				i.Type,
				i,
			)
		}
	}
	return nil
}

var (
	inboxItemBaseFieldID        = big.NewInt(1 << 0)
	inboxItemBaseFieldCreatedAt = big.NewInt(1 << 1)
	inboxItemBaseFieldUpdatedAt = big.NewInt(1 << 2)
	inboxItemBaseFieldStatus    = big.NewInt(1 << 3)
	inboxItemBaseFieldSeverity  = big.NewInt(1 << 4)
)

type InboxItemBase struct {
	// Unique identifier for the inbox item.
	ID *EntityID `json:"id" url:"id"`
	// Timestamp when the inbox item was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Timestamp when the inbox item was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Status of the inbox item.
	Status InboxItemStatus `json:"status" url:"status"`
	// Severity of the inbox item.
	Severity InboxItemSeverity `json:"severity" url:"severity"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemBase) GetID() *EntityID {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InboxItemBase) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InboxItemBase) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InboxItemBase) GetStatus() InboxItemStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InboxItemBase) GetSeverity() InboxItemSeverity {
	if i == nil {
		return ""
	}
	return i.Severity
}

func (i *InboxItemBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemBase) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemBase) SetID(id *EntityID) {
	i.ID = id
	i.require(inboxItemBaseFieldID)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemBase) SetCreatedAt(createdAt time.Time) {
	i.CreatedAt = createdAt
	i.require(inboxItemBaseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemBase) SetUpdatedAt(updatedAt time.Time) {
	i.UpdatedAt = updatedAt
	i.require(inboxItemBaseFieldUpdatedAt)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemBase) SetStatus(status InboxItemStatus) {
	i.Status = status
	i.require(inboxItemBaseFieldStatus)
}

// SetSeverity sets the Severity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemBase) SetSeverity(severity InboxItemSeverity) {
	i.Severity = severity
	i.require(inboxItemBaseFieldSeverity)
}

func (i *InboxItemBase) UnmarshalJSON(data []byte) error {
	type embed InboxItemBase
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InboxItemBase(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemBase) MarshalJSON() ([]byte, error) {
	type embed InboxItemBase
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
		UpdatedAt: internal.NewDateTime(i.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	inboxItemCustomFieldID        = big.NewInt(1 << 0)
	inboxItemCustomFieldCreatedAt = big.NewInt(1 << 1)
	inboxItemCustomFieldUpdatedAt = big.NewInt(1 << 2)
	inboxItemCustomFieldStatus    = big.NewInt(1 << 3)
	inboxItemCustomFieldSeverity  = big.NewInt(1 << 4)
	inboxItemCustomFieldMetadata  = big.NewInt(1 << 5)
)

type InboxItemCustom struct {
	// Unique identifier for the inbox item.
	ID *EntityID `json:"id" url:"id"`
	// Timestamp when the inbox item was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Timestamp when the inbox item was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Status of the inbox item.
	Status InboxItemStatus `json:"status" url:"status"`
	// Severity of the inbox item.
	Severity InboxItemSeverity `json:"severity" url:"severity"`
	// Additional metadata associated with the inbox item.
	Metadata map[string]string `json:"metadata" url:"metadata"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemCustom) GetID() *EntityID {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InboxItemCustom) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InboxItemCustom) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InboxItemCustom) GetStatus() InboxItemStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InboxItemCustom) GetSeverity() InboxItemSeverity {
	if i == nil {
		return ""
	}
	return i.Severity
}

func (i *InboxItemCustom) GetMetadata() map[string]string {
	if i == nil {
		return nil
	}
	return i.Metadata
}

func (i *InboxItemCustom) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemCustom) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemCustom) SetID(id *EntityID) {
	i.ID = id
	i.require(inboxItemCustomFieldID)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemCustom) SetCreatedAt(createdAt time.Time) {
	i.CreatedAt = createdAt
	i.require(inboxItemCustomFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemCustom) SetUpdatedAt(updatedAt time.Time) {
	i.UpdatedAt = updatedAt
	i.require(inboxItemCustomFieldUpdatedAt)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemCustom) SetStatus(status InboxItemStatus) {
	i.Status = status
	i.require(inboxItemCustomFieldStatus)
}

// SetSeverity sets the Severity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemCustom) SetSeverity(severity InboxItemSeverity) {
	i.Severity = severity
	i.require(inboxItemCustomFieldSeverity)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemCustom) SetMetadata(metadata map[string]string) {
	i.Metadata = metadata
	i.require(inboxItemCustomFieldMetadata)
}

func (i *InboxItemCustom) UnmarshalJSON(data []byte) error {
	type embed InboxItemCustom
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InboxItemCustom(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemCustom) MarshalJSON() ([]byte, error) {
	type embed InboxItemCustom
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
		UpdatedAt: internal.NewDateTime(i.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemCustom) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	inboxItemDuplicateDocumentsFieldID               = big.NewInt(1 << 0)
	inboxItemDuplicateDocumentsFieldCreatedAt        = big.NewInt(1 << 1)
	inboxItemDuplicateDocumentsFieldUpdatedAt        = big.NewInt(1 << 2)
	inboxItemDuplicateDocumentsFieldStatus           = big.NewInt(1 << 3)
	inboxItemDuplicateDocumentsFieldSeverity         = big.NewInt(1 << 4)
	inboxItemDuplicateDocumentsFieldRecommendedFixes = big.NewInt(1 << 5)
	inboxItemDuplicateDocumentsFieldOtherFixes       = big.NewInt(1 << 6)
	inboxItemDuplicateDocumentsFieldSourceDocument   = big.NewInt(1 << 7)
	inboxItemDuplicateDocumentsFieldDocuments        = big.NewInt(1 << 8)
)

type InboxItemDuplicateDocuments struct {
	// Unique identifier for the inbox item.
	ID *EntityID `json:"id" url:"id"`
	// Timestamp when the inbox item was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Timestamp when the inbox item was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Status of the inbox item.
	Status InboxItemStatus `json:"status" url:"status"`
	// Severity of the inbox item.
	Severity InboxItemSeverity `json:"severity" url:"severity"`
	// The fix recommended for being applied
	RecommendedFixes []*InboxItemFixDeactivateDocument `json:"recommendedFixes" url:"recommendedFixes"`
	// List of fixes associated with the inbox item.
	OtherFixes []*InboxItemFixDeactivateDocument `json:"otherFixes" url:"otherFixes"`
	// Information about the source document associated with the inbox item.
	SourceDocument *DocumentInformation `json:"sourceDocument" url:"sourceDocument"`
	// List of Document information objects related to the inbox item.
	Documents []*DocumentInformation `json:"documents" url:"documents"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemDuplicateDocuments) GetID() *EntityID {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InboxItemDuplicateDocuments) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InboxItemDuplicateDocuments) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InboxItemDuplicateDocuments) GetStatus() InboxItemStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InboxItemDuplicateDocuments) GetSeverity() InboxItemSeverity {
	if i == nil {
		return ""
	}
	return i.Severity
}

func (i *InboxItemDuplicateDocuments) GetRecommendedFixes() []*InboxItemFixDeactivateDocument {
	if i == nil {
		return nil
	}
	return i.RecommendedFixes
}

func (i *InboxItemDuplicateDocuments) GetOtherFixes() []*InboxItemFixDeactivateDocument {
	if i == nil {
		return nil
	}
	return i.OtherFixes
}

func (i *InboxItemDuplicateDocuments) GetSourceDocument() *DocumentInformation {
	if i == nil {
		return nil
	}
	return i.SourceDocument
}

func (i *InboxItemDuplicateDocuments) GetDocuments() []*DocumentInformation {
	if i == nil {
		return nil
	}
	return i.Documents
}

func (i *InboxItemDuplicateDocuments) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemDuplicateDocuments) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetID(id *EntityID) {
	i.ID = id
	i.require(inboxItemDuplicateDocumentsFieldID)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetCreatedAt(createdAt time.Time) {
	i.CreatedAt = createdAt
	i.require(inboxItemDuplicateDocumentsFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetUpdatedAt(updatedAt time.Time) {
	i.UpdatedAt = updatedAt
	i.require(inboxItemDuplicateDocumentsFieldUpdatedAt)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetStatus(status InboxItemStatus) {
	i.Status = status
	i.require(inboxItemDuplicateDocumentsFieldStatus)
}

// SetSeverity sets the Severity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetSeverity(severity InboxItemSeverity) {
	i.Severity = severity
	i.require(inboxItemDuplicateDocumentsFieldSeverity)
}

// SetRecommendedFixes sets the RecommendedFixes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetRecommendedFixes(recommendedFixes []*InboxItemFixDeactivateDocument) {
	i.RecommendedFixes = recommendedFixes
	i.require(inboxItemDuplicateDocumentsFieldRecommendedFixes)
}

// SetOtherFixes sets the OtherFixes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetOtherFixes(otherFixes []*InboxItemFixDeactivateDocument) {
	i.OtherFixes = otherFixes
	i.require(inboxItemDuplicateDocumentsFieldOtherFixes)
}

// SetSourceDocument sets the SourceDocument field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetSourceDocument(sourceDocument *DocumentInformation) {
	i.SourceDocument = sourceDocument
	i.require(inboxItemDuplicateDocumentsFieldSourceDocument)
}

// SetDocuments sets the Documents field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetDocuments(documents []*DocumentInformation) {
	i.Documents = documents
	i.require(inboxItemDuplicateDocumentsFieldDocuments)
}

func (i *InboxItemDuplicateDocuments) UnmarshalJSON(data []byte) error {
	type embed InboxItemDuplicateDocuments
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InboxItemDuplicateDocuments(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemDuplicateDocuments) MarshalJSON() ([]byte, error) {
	type embed InboxItemDuplicateDocuments
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
		UpdatedAt: internal.NewDateTime(i.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemDuplicateDocuments) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InboxItemFix struct {
	Type               string
	AddDocument        *InboxItemFixAddDocument
	DeactivateDocument *InboxItemFixDeactivateDocument
}

func (i *InboxItemFix) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InboxItemFix) GetAddDocument() *InboxItemFixAddDocument {
	if i == nil {
		return nil
	}
	return i.AddDocument
}

func (i *InboxItemFix) GetDeactivateDocument() *InboxItemFixDeactivateDocument {
	if i == nil {
		return nil
	}
	return i.DeactivateDocument
}

func (i *InboxItemFix) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "addDocument":
		value := new(InboxItemFixAddDocument)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.AddDocument = value
	case "deactivateDocument":
		value := new(InboxItemFixDeactivateDocument)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.DeactivateDocument = value
	}
	return nil
}

func (i InboxItemFix) MarshalJSON() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	if i.AddDocument != nil {
		return internal.MarshalJSONWithExtraProperty(i.AddDocument, "type", "addDocument")
	}
	if i.DeactivateDocument != nil {
		return internal.MarshalJSONWithExtraProperty(i.DeactivateDocument, "type", "deactivateDocument")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type InboxItemFixVisitor interface {
	VisitAddDocument(*InboxItemFixAddDocument) error
	VisitDeactivateDocument(*InboxItemFixDeactivateDocument) error
}

func (i *InboxItemFix) Accept(visitor InboxItemFixVisitor) error {
	if i.AddDocument != nil {
		return visitor.VisitAddDocument(i.AddDocument)
	}
	if i.DeactivateDocument != nil {
		return visitor.VisitDeactivateDocument(i.DeactivateDocument)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

func (i *InboxItemFix) validate() error {
	if i == nil {
		return fmt.Errorf("type %T is nil", i)
	}
	var fields []string
	if i.AddDocument != nil {
		fields = append(fields, "addDocument")
	}
	if i.DeactivateDocument != nil {
		fields = append(fields, "deactivateDocument")
	}
	if len(fields) == 0 {
		if i.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", i, i.Type)
		}
		return fmt.Errorf("type %T is empty", i)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", i, fields)
	}
	if i.Type != "" {
		field := fields[0]
		if i.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				i,
				i.Type,
				i,
			)
		}
	}
	return nil
}

var (
	inboxItemFixAddDocumentFieldID                 = big.NewInt(1 << 0)
	inboxItemFixAddDocumentFieldSuggestedTextTitle = big.NewInt(1 << 1)
	inboxItemFixAddDocumentFieldSuggestedText      = big.NewInt(1 << 2)
)

type InboxItemFixAddDocument struct {
	// Unique identifier for the inbox item fix.
	ID *EntityID `json:"id" url:"id"`
	// Suggested document title if the fix type is ADD_DOCUMENT.
	SuggestedTextTitle string `json:"suggestedTextTitle" url:"suggestedTextTitle"`
	// Suggested document text if the fix type is ADD_DOCUMENT.
	SuggestedText string `json:"suggestedText" url:"suggestedText"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemFixAddDocument) GetID() *EntityID {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InboxItemFixAddDocument) GetSuggestedTextTitle() string {
	if i == nil {
		return ""
	}
	return i.SuggestedTextTitle
}

func (i *InboxItemFixAddDocument) GetSuggestedText() string {
	if i == nil {
		return ""
	}
	return i.SuggestedText
}

func (i *InboxItemFixAddDocument) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemFixAddDocument) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixAddDocument) SetID(id *EntityID) {
	i.ID = id
	i.require(inboxItemFixAddDocumentFieldID)
}

// SetSuggestedTextTitle sets the SuggestedTextTitle field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixAddDocument) SetSuggestedTextTitle(suggestedTextTitle string) {
	i.SuggestedTextTitle = suggestedTextTitle
	i.require(inboxItemFixAddDocumentFieldSuggestedTextTitle)
}

// SetSuggestedText sets the SuggestedText field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixAddDocument) SetSuggestedText(suggestedText string) {
	i.SuggestedText = suggestedText
	i.require(inboxItemFixAddDocumentFieldSuggestedText)
}

func (i *InboxItemFixAddDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler InboxItemFixAddDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InboxItemFixAddDocument(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemFixAddDocument) MarshalJSON() ([]byte, error) {
	type embed InboxItemFixAddDocument
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemFixAddDocument) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	inboxItemFixBaseFieldID = big.NewInt(1 << 0)
)

type InboxItemFixBase struct {
	// Unique identifier for the inbox item fix.
	ID *EntityID `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemFixBase) GetID() *EntityID {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InboxItemFixBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemFixBase) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixBase) SetID(id *EntityID) {
	i.ID = id
	i.require(inboxItemFixBaseFieldID)
}

func (i *InboxItemFixBase) UnmarshalJSON(data []byte) error {
	type unmarshaler InboxItemFixBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InboxItemFixBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemFixBase) MarshalJSON() ([]byte, error) {
	type embed InboxItemFixBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemFixBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	inboxItemFixDeactivateDocumentFieldID                  = big.NewInt(1 << 0)
	inboxItemFixDeactivateDocumentFieldDocumentInformation = big.NewInt(1 << 1)
)

type InboxItemFixDeactivateDocument struct {
	// Unique identifier for the inbox item fix.
	ID *EntityID `json:"id" url:"id"`
	// Information about the document associated with this fix.
	DocumentInformation *DocumentInformation `json:"documentInformation" url:"documentInformation"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemFixDeactivateDocument) GetID() *EntityID {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InboxItemFixDeactivateDocument) GetDocumentInformation() *DocumentInformation {
	if i == nil {
		return nil
	}
	return i.DocumentInformation
}

func (i *InboxItemFixDeactivateDocument) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemFixDeactivateDocument) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixDeactivateDocument) SetID(id *EntityID) {
	i.ID = id
	i.require(inboxItemFixDeactivateDocumentFieldID)
}

// SetDocumentInformation sets the DocumentInformation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixDeactivateDocument) SetDocumentInformation(documentInformation *DocumentInformation) {
	i.DocumentInformation = documentInformation
	i.require(inboxItemFixDeactivateDocumentFieldDocumentInformation)
}

func (i *InboxItemFixDeactivateDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler InboxItemFixDeactivateDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InboxItemFixDeactivateDocument(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemFixDeactivateDocument) MarshalJSON() ([]byte, error) {
	type embed InboxItemFixDeactivateDocument
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemFixDeactivateDocument) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	inboxItemMissingKnowledgeFieldID            = big.NewInt(1 << 0)
	inboxItemMissingKnowledgeFieldCreatedAt     = big.NewInt(1 << 1)
	inboxItemMissingKnowledgeFieldUpdatedAt     = big.NewInt(1 << 2)
	inboxItemMissingKnowledgeFieldStatus        = big.NewInt(1 << 3)
	inboxItemMissingKnowledgeFieldSeverity      = big.NewInt(1 << 4)
	inboxItemMissingKnowledgeFieldFix           = big.NewInt(1 << 5)
	inboxItemMissingKnowledgeFieldConversations = big.NewInt(1 << 6)
)

type InboxItemMissingKnowledge struct {
	// Unique identifier for the inbox item.
	ID *EntityID `json:"id" url:"id"`
	// Timestamp when the inbox item was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Timestamp when the inbox item was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Status of the inbox item.
	Status InboxItemStatus `json:"status" url:"status"`
	// Severity of the inbox item.
	Severity InboxItemSeverity `json:"severity" url:"severity"`
	// Fix associated with the inbox item.
	Fix *InboxItemFixAddDocument `json:"fix" url:"fix"`
	// List of Conversation information objects related to the inbox item.
	Conversations []*ConversationInformation `json:"conversations" url:"conversations"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemMissingKnowledge) GetID() *EntityID {
	if i == nil {
		return nil
	}
	return i.ID
}

func (i *InboxItemMissingKnowledge) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InboxItemMissingKnowledge) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InboxItemMissingKnowledge) GetStatus() InboxItemStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InboxItemMissingKnowledge) GetSeverity() InboxItemSeverity {
	if i == nil {
		return ""
	}
	return i.Severity
}

func (i *InboxItemMissingKnowledge) GetFix() *InboxItemFixAddDocument {
	if i == nil {
		return nil
	}
	return i.Fix
}

func (i *InboxItemMissingKnowledge) GetConversations() []*ConversationInformation {
	if i == nil {
		return nil
	}
	return i.Conversations
}

func (i *InboxItemMissingKnowledge) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemMissingKnowledge) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetID(id *EntityID) {
	i.ID = id
	i.require(inboxItemMissingKnowledgeFieldID)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetCreatedAt(createdAt time.Time) {
	i.CreatedAt = createdAt
	i.require(inboxItemMissingKnowledgeFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetUpdatedAt(updatedAt time.Time) {
	i.UpdatedAt = updatedAt
	i.require(inboxItemMissingKnowledgeFieldUpdatedAt)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetStatus(status InboxItemStatus) {
	i.Status = status
	i.require(inboxItemMissingKnowledgeFieldStatus)
}

// SetSeverity sets the Severity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetSeverity(severity InboxItemSeverity) {
	i.Severity = severity
	i.require(inboxItemMissingKnowledgeFieldSeverity)
}

// SetFix sets the Fix field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetFix(fix *InboxItemFixAddDocument) {
	i.Fix = fix
	i.require(inboxItemMissingKnowledgeFieldFix)
}

// SetConversations sets the Conversations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetConversations(conversations []*ConversationInformation) {
	i.Conversations = conversations
	i.require(inboxItemMissingKnowledgeFieldConversations)
}

func (i *InboxItemMissingKnowledge) UnmarshalJSON(data []byte) error {
	type embed InboxItemMissingKnowledge
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InboxItemMissingKnowledge(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemMissingKnowledge) MarshalJSON() ([]byte, error) {
	type embed InboxItemMissingKnowledge
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
		UpdatedAt: internal.NewDateTime(i.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemMissingKnowledge) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InboxItemSeverity string

const (
	InboxItemSeverityLow    InboxItemSeverity = "LOW"
	InboxItemSeverityMedium InboxItemSeverity = "MEDIUM"
	InboxItemSeverityHigh   InboxItemSeverity = "HIGH"
)

func NewInboxItemSeverityFromString(s string) (InboxItemSeverity, error) {
	switch s {
	case "LOW":
		return InboxItemSeverityLow, nil
	case "MEDIUM":
		return InboxItemSeverityMedium, nil
	case "HIGH":
		return InboxItemSeverityHigh, nil
	}
	var t InboxItemSeverity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InboxItemSeverity) Ptr() *InboxItemSeverity {
	return &i
}

type InboxItemStatus string

const (
	// The inbox item is open.
	InboxItemStatusOpen InboxItemStatus = "OPEN"
	// The inbox item was resolved by the user.
	InboxItemStatusUserResolved InboxItemStatus = "USER_RESOLVED"
	// The inbox item was resolved by the system.
	InboxItemStatusSystemResolved InboxItemStatus = "SYSTEM_RESOLVED"
	// The inbox item has regressed.
	InboxItemStatusRegressed InboxItemStatus = "REGRESSED"
	// The inbox item was ignored.
	InboxItemStatusIgnored InboxItemStatus = "IGNORED"
)

func NewInboxItemStatusFromString(s string) (InboxItemStatus, error) {
	switch s {
	case "OPEN":
		return InboxItemStatusOpen, nil
	case "USER_RESOLVED":
		return InboxItemStatusUserResolved, nil
	case "SYSTEM_RESOLVED":
		return InboxItemStatusSystemResolved, nil
	case "REGRESSED":
		return InboxItemStatusRegressed, nil
	case "IGNORED":
		return InboxItemStatusIgnored, nil
	}
	var t InboxItemStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InboxItemStatus) Ptr() *InboxItemStatus {
	return &i
}

type InboxItemType string

const (
	// The inbox item is a duplicate document.
	InboxItemTypeDuplicateDocument InboxItemType = "DUPLICATE_DOCUMENT"
	// The inbox item is missing knowledge.
	InboxItemTypeMissingKnowledge InboxItemType = "MISSING_KNOWLEDGE"
	// The inbox item is a custom api-provided inbox item.
	InboxItemTypeCustom InboxItemType = "CUSTOM"
)

func NewInboxItemTypeFromString(s string) (InboxItemType, error) {
	switch s {
	case "DUPLICATE_DOCUMENT":
		return InboxItemTypeDuplicateDocument, nil
	case "MISSING_KNOWLEDGE":
		return InboxItemTypeMissingKnowledge, nil
	case "CUSTOM":
		return InboxItemTypeCustom, nil
	}
	var t InboxItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InboxItemType) Ptr() *InboxItemType {
	return &i
}

// The condition to evaluate against an intelligent field's value.
// Use the appropriate type based on the field's validationType:
// - `string`: For STRING and MULTILINE fields
// - `numeric`: For NUMBER fields
// - `boolean`: For BOOLEAN fields
// - `set`: For MULTI_SELECT fields (unordered set of values)
//
// Note: single select fields are represented as STRING/NUMBER with a list of
// enumOptions.
//
// The caller is responsible for querying the validationType and enumOptions
// from the intelligent field API to ensure the values are valid enumOptions.
type IntelligentFieldCondition struct {
	FieldValidationType string
	String              *StringCondition
	Numeric             *NumericCondition
	Boolean             *BooleanCondition
	Set                 *SetCondition
}

func (i *IntelligentFieldCondition) GetFieldValidationType() string {
	if i == nil {
		return ""
	}
	return i.FieldValidationType
}

func (i *IntelligentFieldCondition) GetString() *StringCondition {
	if i == nil {
		return nil
	}
	return i.String
}

func (i *IntelligentFieldCondition) GetNumeric() *NumericCondition {
	if i == nil {
		return nil
	}
	return i.Numeric
}

func (i *IntelligentFieldCondition) GetBoolean() *BooleanCondition {
	if i == nil {
		return nil
	}
	return i.Boolean
}

func (i *IntelligentFieldCondition) GetSet() *SetCondition {
	if i == nil {
		return nil
	}
	return i.Set
}

func (i *IntelligentFieldCondition) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		FieldValidationType string `json:"fieldValidationType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.FieldValidationType = unmarshaler.FieldValidationType
	if unmarshaler.FieldValidationType == "" {
		return fmt.Errorf("%T did not include discriminant fieldValidationType", i)
	}
	switch unmarshaler.FieldValidationType {
	case "string":
		var valueUnmarshaler struct {
			String *StringCondition `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.String = valueUnmarshaler.String
	case "numeric":
		var valueUnmarshaler struct {
			Numeric *NumericCondition `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.Numeric = valueUnmarshaler.Numeric
	case "boolean":
		value := new(BooleanCondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Boolean = value
	case "set":
		var valueUnmarshaler struct {
			Set *SetCondition `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		i.Set = valueUnmarshaler.Set
	}
	return nil
}

func (i IntelligentFieldCondition) MarshalJSON() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	if i.String != nil {
		var marshaler = struct {
			FieldValidationType string           `json:"fieldValidationType"`
			String              *StringCondition `json:"value"`
		}{
			FieldValidationType: "string",
			String:              i.String,
		}
		return json.Marshal(marshaler)
	}
	if i.Numeric != nil {
		var marshaler = struct {
			FieldValidationType string            `json:"fieldValidationType"`
			Numeric             *NumericCondition `json:"value"`
		}{
			FieldValidationType: "numeric",
			Numeric:             i.Numeric,
		}
		return json.Marshal(marshaler)
	}
	if i.Boolean != nil {
		return internal.MarshalJSONWithExtraProperty(i.Boolean, "fieldValidationType", "boolean")
	}
	if i.Set != nil {
		var marshaler = struct {
			FieldValidationType string        `json:"fieldValidationType"`
			Set                 *SetCondition `json:"value"`
		}{
			FieldValidationType: "set",
			Set:                 i.Set,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type IntelligentFieldConditionVisitor interface {
	VisitString(*StringCondition) error
	VisitNumeric(*NumericCondition) error
	VisitBoolean(*BooleanCondition) error
	VisitSet(*SetCondition) error
}

func (i *IntelligentFieldCondition) Accept(visitor IntelligentFieldConditionVisitor) error {
	if i.String != nil {
		return visitor.VisitString(i.String)
	}
	if i.Numeric != nil {
		return visitor.VisitNumeric(i.Numeric)
	}
	if i.Boolean != nil {
		return visitor.VisitBoolean(i.Boolean)
	}
	if i.Set != nil {
		return visitor.VisitSet(i.Set)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

func (i *IntelligentFieldCondition) validate() error {
	if i == nil {
		return fmt.Errorf("type %T is nil", i)
	}
	var fields []string
	if i.String != nil {
		fields = append(fields, "string")
	}
	if i.Numeric != nil {
		fields = append(fields, "numeric")
	}
	if i.Boolean != nil {
		fields = append(fields, "boolean")
	}
	if i.Set != nil {
		fields = append(fields, "set")
	}
	if len(fields) == 0 {
		if i.FieldValidationType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", i, i.FieldValidationType)
		}
		return fmt.Errorf("type %T is empty", i)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", i, fields)
	}
	if i.FieldValidationType != "" {
		field := fields[0]
		if i.FieldValidationType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				i,
				i.FieldValidationType,
				i,
			)
		}
	}
	return nil
}

// A precondition based on the computed value of an intelligent field on the conversation.
//
// The structure of this precondition follows `LHS OP RHS`, where the LHS is
// the ID of the intelligent field (<referenceId, appId>).  Available
// operators and the corresponding types of the RHS depends on the
// validationType of the intelligent field.
//
// Note: in early beta, only opt-in apps and organizations/agents can
// specify intelligent field preconditions.  Otherwise, the request will be
// rejected.
var (
	intelligentFieldPreconditionFieldFieldIDWithoutAgent = big.NewInt(1 << 0)
	intelligentFieldPreconditionFieldFieldCondition      = big.NewInt(1 << 1)
)

type IntelligentFieldPrecondition struct {
	// The ID of the intelligent field.
	FieldIDWithoutAgent *EntityIDWithoutAgent `json:"fieldIdWithoutAgent" url:"fieldIdWithoutAgent"`
	// The condition to evaluate against the field's value.
	FieldCondition *IntelligentFieldCondition `json:"fieldCondition" url:"fieldCondition"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IntelligentFieldPrecondition) GetFieldIDWithoutAgent() *EntityIDWithoutAgent {
	if i == nil {
		return nil
	}
	return i.FieldIDWithoutAgent
}

func (i *IntelligentFieldPrecondition) GetFieldCondition() *IntelligentFieldCondition {
	if i == nil {
		return nil
	}
	return i.FieldCondition
}

func (i *IntelligentFieldPrecondition) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntelligentFieldPrecondition) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetFieldIDWithoutAgent sets the FieldIDWithoutAgent field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntelligentFieldPrecondition) SetFieldIDWithoutAgent(fieldIDWithoutAgent *EntityIDWithoutAgent) {
	i.FieldIDWithoutAgent = fieldIDWithoutAgent
	i.require(intelligentFieldPreconditionFieldFieldIDWithoutAgent)
}

// SetFieldCondition sets the FieldCondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntelligentFieldPrecondition) SetFieldCondition(fieldCondition *IntelligentFieldCondition) {
	i.FieldCondition = fieldCondition
	i.require(intelligentFieldPreconditionFieldFieldCondition)
}

func (i *IntelligentFieldPrecondition) UnmarshalJSON(data []byte) error {
	type unmarshaler IntelligentFieldPrecondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IntelligentFieldPrecondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntelligentFieldPrecondition) MarshalJSON() ([]byte, error) {
	type embed IntelligentFieldPrecondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IntelligentFieldPrecondition) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

// A single computed value for an intelligent field on a specific entity
var (
	intelligentFieldValueResponseFieldFieldID    = big.NewInt(1 << 0)
	intelligentFieldValueResponseFieldEntityID   = big.NewInt(1 << 1)
	intelligentFieldValueResponseFieldValue      = big.NewInt(1 << 2)
	intelligentFieldValueResponseFieldConfidence = big.NewInt(1 << 3)
	intelligentFieldValueResponseFieldRationale  = big.NewInt(1 << 4)
	intelligentFieldValueResponseFieldCreatedAt  = big.NewInt(1 << 5)
)

type IntelligentFieldValueResponse struct {
	// The intelligent field that this value belongs to
	FieldID *EntityID `json:"fieldId" url:"fieldId"`
	// The entity this value is for
	EntityID *EntityID `json:"entityId" url:"entityId"`
	// The computed value (typed according to validationType)
	Value interface{} `json:"value,omitempty" url:"value,omitempty"`
	// Optional model-provided confidence for the value
	Confidence *float64 `json:"confidence,omitempty" url:"confidence,omitempty"`
	// Optional short rationale/explanation from the model
	Rationale *string `json:"rationale,omitempty" url:"rationale,omitempty"`
	// The date and time this value was computed
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IntelligentFieldValueResponse) GetFieldID() *EntityID {
	if i == nil {
		return nil
	}
	return i.FieldID
}

func (i *IntelligentFieldValueResponse) GetEntityID() *EntityID {
	if i == nil {
		return nil
	}
	return i.EntityID
}

func (i *IntelligentFieldValueResponse) GetValue() interface{} {
	if i == nil {
		return nil
	}
	return i.Value
}

func (i *IntelligentFieldValueResponse) GetConfidence() *float64 {
	if i == nil {
		return nil
	}
	return i.Confidence
}

func (i *IntelligentFieldValueResponse) GetRationale() *string {
	if i == nil {
		return nil
	}
	return i.Rationale
}

func (i *IntelligentFieldValueResponse) GetCreatedAt() *time.Time {
	if i == nil {
		return nil
	}
	return i.CreatedAt
}

func (i *IntelligentFieldValueResponse) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IntelligentFieldValueResponse) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetFieldID sets the FieldID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntelligentFieldValueResponse) SetFieldID(fieldID *EntityID) {
	i.FieldID = fieldID
	i.require(intelligentFieldValueResponseFieldFieldID)
}

// SetEntityID sets the EntityID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntelligentFieldValueResponse) SetEntityID(entityID *EntityID) {
	i.EntityID = entityID
	i.require(intelligentFieldValueResponseFieldEntityID)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntelligentFieldValueResponse) SetValue(value interface{}) {
	i.Value = value
	i.require(intelligentFieldValueResponseFieldValue)
}

// SetConfidence sets the Confidence field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntelligentFieldValueResponse) SetConfidence(confidence *float64) {
	i.Confidence = confidence
	i.require(intelligentFieldValueResponseFieldConfidence)
}

// SetRationale sets the Rationale field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntelligentFieldValueResponse) SetRationale(rationale *string) {
	i.Rationale = rationale
	i.require(intelligentFieldValueResponseFieldRationale)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IntelligentFieldValueResponse) SetCreatedAt(createdAt *time.Time) {
	i.CreatedAt = createdAt
	i.require(intelligentFieldValueResponseFieldCreatedAt)
}

func (i *IntelligentFieldValueResponse) UnmarshalJSON(data []byte) error {
	type embed IntelligentFieldValueResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = IntelligentFieldValueResponse(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IntelligentFieldValueResponse) MarshalJSON() ([]byte, error) {
	type embed IntelligentFieldValueResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewOptionalDateTime(i.CreatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IntelligentFieldValueResponse) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	iPInfoFieldIP = big.NewInt(1 << 0)
)

type IPInfo struct {
	IP *string `json:"ip,omitempty" url:"ip,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IPInfo) GetIP() *string {
	if i == nil {
		return nil
	}
	return i.IP
}

func (i *IPInfo) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IPInfo) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetIP sets the IP field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IPInfo) SetIP(ip *string) {
	i.IP = ip
	i.require(iPInfoFieldIP)
}

func (i *IPInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler IPInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IPInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IPInfo) MarshalJSON() ([]byte, error) {
	type embed IPInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IPInfo) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	knowledgeContextByEntitiesFieldEntities = big.NewInt(1 << 0)
)

type KnowledgeContextByEntities struct {
	Entities []*ScopedEntity `json:"entities" url:"entities"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeContextByEntities) GetEntities() []*ScopedEntity {
	if k == nil {
		return nil
	}
	return k.Entities
}

func (k *KnowledgeContextByEntities) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeContextByEntities) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetEntities sets the Entities field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeContextByEntities) SetEntities(entities []*ScopedEntity) {
	k.Entities = entities
	k.require(knowledgeContextByEntitiesFieldEntities)
}

func (k *KnowledgeContextByEntities) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeContextByEntities
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeContextByEntities(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeContextByEntities) MarshalJSON() ([]byte, error) {
	type embed KnowledgeContextByEntities
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeContextByEntities) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

var (
	knowledgeContextByEntityTypesFieldEntityTypes = big.NewInt(1 << 0)
)

type KnowledgeContextByEntityTypes struct {
	EntityTypes []EntityType `json:"entityTypes" url:"entityTypes"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (k *KnowledgeContextByEntityTypes) GetEntityTypes() []EntityType {
	if k == nil {
		return nil
	}
	return k.EntityTypes
}

func (k *KnowledgeContextByEntityTypes) GetExtraProperties() map[string]interface{} {
	return k.extraProperties
}

func (k *KnowledgeContextByEntityTypes) require(field *big.Int) {
	if k.explicitFields == nil {
		k.explicitFields = big.NewInt(0)
	}
	k.explicitFields.Or(k.explicitFields, field)
}

// SetEntityTypes sets the EntityTypes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (k *KnowledgeContextByEntityTypes) SetEntityTypes(entityTypes []EntityType) {
	k.EntityTypes = entityTypes
	k.require(knowledgeContextByEntityTypesFieldEntityTypes)
}

func (k *KnowledgeContextByEntityTypes) UnmarshalJSON(data []byte) error {
	type unmarshaler KnowledgeContextByEntityTypes
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*k = KnowledgeContextByEntityTypes(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *k)
	if err != nil {
		return err
	}
	k.extraProperties = extraProperties
	k.rawJSON = json.RawMessage(data)
	return nil
}

func (k *KnowledgeContextByEntityTypes) MarshalJSON() ([]byte, error) {
	type embed KnowledgeContextByEntityTypes
	var marshaler = struct {
		embed
	}{
		embed: embed(*k),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, k.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (k *KnowledgeContextByEntityTypes) String() string {
	if len(k.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(k.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(k); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", k)
}

type KnowledgeContextFilter struct {
	ScopeType     string
	ByEntities    *KnowledgeContextByEntities
	ByEntityTypes *KnowledgeContextByEntityTypes
}

func (k *KnowledgeContextFilter) GetScopeType() string {
	if k == nil {
		return ""
	}
	return k.ScopeType
}

func (k *KnowledgeContextFilter) GetByEntities() *KnowledgeContextByEntities {
	if k == nil {
		return nil
	}
	return k.ByEntities
}

func (k *KnowledgeContextFilter) GetByEntityTypes() *KnowledgeContextByEntityTypes {
	if k == nil {
		return nil
	}
	return k.ByEntityTypes
}

func (k *KnowledgeContextFilter) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ScopeType string `json:"scopeType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	k.ScopeType = unmarshaler.ScopeType
	if unmarshaler.ScopeType == "" {
		return fmt.Errorf("%T did not include discriminant scopeType", k)
	}
	switch unmarshaler.ScopeType {
	case "byEntities":
		value := new(KnowledgeContextByEntities)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		k.ByEntities = value
	case "byEntityTypes":
		value := new(KnowledgeContextByEntityTypes)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		k.ByEntityTypes = value
	}
	return nil
}

func (k KnowledgeContextFilter) MarshalJSON() ([]byte, error) {
	if err := k.validate(); err != nil {
		return nil, err
	}
	if k.ByEntities != nil {
		return internal.MarshalJSONWithExtraProperty(k.ByEntities, "scopeType", "byEntities")
	}
	if k.ByEntityTypes != nil {
		return internal.MarshalJSONWithExtraProperty(k.ByEntityTypes, "scopeType", "byEntityTypes")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", k)
}

type KnowledgeContextFilterVisitor interface {
	VisitByEntities(*KnowledgeContextByEntities) error
	VisitByEntityTypes(*KnowledgeContextByEntityTypes) error
}

func (k *KnowledgeContextFilter) Accept(visitor KnowledgeContextFilterVisitor) error {
	if k.ByEntities != nil {
		return visitor.VisitByEntities(k.ByEntities)
	}
	if k.ByEntityTypes != nil {
		return visitor.VisitByEntityTypes(k.ByEntityTypes)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", k)
}

func (k *KnowledgeContextFilter) validate() error {
	if k == nil {
		return fmt.Errorf("type %T is nil", k)
	}
	var fields []string
	if k.ByEntities != nil {
		fields = append(fields, "byEntities")
	}
	if k.ByEntityTypes != nil {
		fields = append(fields, "byEntityTypes")
	}
	if len(fields) == 0 {
		if k.ScopeType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", k, k.ScopeType)
		}
		return fmt.Errorf("type %T is empty", k)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", k, fields)
	}
	if k.ScopeType != "" {
		field := fields[0]
		if k.ScopeType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				k,
				k.ScopeType,
				k,
			)
		}
	}
	return nil
}

var (
	languageInfoFieldCode = big.NewInt(1 << 0)
)

type LanguageInfo struct {
	Code *string `json:"code,omitempty" url:"code,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LanguageInfo) GetCode() *string {
	if l == nil {
		return nil
	}
	return l.Code
}

func (l *LanguageInfo) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LanguageInfo) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetCode sets the Code field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LanguageInfo) SetCode(code *string) {
	l.Code = code
	l.require(languageInfoFieldCode)
}

func (l *LanguageInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler LanguageInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LanguageInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LanguageInfo) MarshalJSON() ([]byte, error) {
	type embed LanguageInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LanguageInfo) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LlmInclusionStatus string

const (
	LlmInclusionStatusAlways       LlmInclusionStatus = "ALWAYS"
	LlmInclusionStatusWhenRelevant LlmInclusionStatus = "WHEN_RELEVANT"
	LlmInclusionStatusNever        LlmInclusionStatus = "NEVER"
)

func NewLlmInclusionStatusFromString(s string) (LlmInclusionStatus, error) {
	switch s {
	case "ALWAYS":
		return LlmInclusionStatusAlways, nil
	case "WHEN_RELEVANT":
		return LlmInclusionStatusWhenRelevant, nil
	case "NEVER":
		return LlmInclusionStatusNever, nil
	}
	var t LlmInclusionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LlmInclusionStatus) Ptr() *LlmInclusionStatus {
	return &l
}

type LlmPersona string

const (
	LlmPersonaCasualBuddy         LlmPersona = "CASUAL_BUDDY"
	LlmPersonaEmpatheticSupporter LlmPersona = "EMPATHETIC_SUPPORTER"
	LlmPersonaFormalProfessional  LlmPersona = "FORMAL_PROFESSIONAL"
	LlmPersonaConciseExpert       LlmPersona = "CONCISE_EXPERT"
	LlmPersonaEnthusiasticHelper  LlmPersona = "ENTHUSIASTIC_HELPER"
	LlmPersonaPatientEducator     LlmPersona = "PATIENT_EDUCATOR"
	LlmPersonaPirate              LlmPersona = "PIRATE"
)

func NewLlmPersonaFromString(s string) (LlmPersona, error) {
	switch s {
	case "CASUAL_BUDDY":
		return LlmPersonaCasualBuddy, nil
	case "EMPATHETIC_SUPPORTER":
		return LlmPersonaEmpatheticSupporter, nil
	case "FORMAL_PROFESSIONAL":
		return LlmPersonaFormalProfessional, nil
	case "CONCISE_EXPERT":
		return LlmPersonaConciseExpert, nil
	case "ENTHUSIASTIC_HELPER":
		return LlmPersonaEnthusiasticHelper, nil
	case "PATIENT_EDUCATOR":
		return LlmPersonaPatientEducator, nil
	case "PIRATE":
		return LlmPersonaPirate, nil
	}
	var t LlmPersona
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LlmPersona) Ptr() *LlmPersona {
	return &l
}

// The delivery status of the message.
//
// * `SENDING`: The message is being streamed to the user.
// * `SENT`: The message has been sent to the user.
// * `REJECTED`: The message was rejected by the system.
// * `CANCELED`: The message was canceled by the user before streaming was complete.
// * `FAILED`: The message generating or sending encountered an error.
// * `UNKNOWN`: The message status is unknown.
type MessageStatus string

const (
	MessageStatusSending  MessageStatus = "SENDING"
	MessageStatusSent     MessageStatus = "SENT"
	MessageStatusRejected MessageStatus = "REJECTED"
	MessageStatusCanceled MessageStatus = "CANCELED"
	MessageStatusFailed   MessageStatus = "FAILED"
	MessageStatusUnknown  MessageStatus = "UNKNOWN"
)

func NewMessageStatusFromString(s string) (MessageStatus, error) {
	switch s {
	case "SENDING":
		return MessageStatusSending, nil
	case "SENT":
		return MessageStatusSent, nil
	case "REJECTED":
		return MessageStatusRejected, nil
	case "CANCELED":
		return MessageStatusCanceled, nil
	case "FAILED":
		return MessageStatusFailed, nil
	case "UNKNOWN":
		return MessageStatusUnknown, nil
	}
	var t MessageStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MessageStatus) Ptr() *MessageStatus {
	return &m
}

var (
	metadataPreconditionFieldOperator = big.NewInt(1 << 0)
	metadataPreconditionFieldKey      = big.NewInt(1 << 1)
	metadataPreconditionFieldValue    = big.NewInt(1 << 2)
	metadataPreconditionFieldValues   = big.NewInt(1 << 3)
)

type MetadataPrecondition struct {
	// Operator to apply to this precondition
	Operator *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`
	// The key that must be present in the metadata for a precondition to be met
	Key string `json:"key" url:"key"`
	// Single value for CONTAINS operator or exact match
	Value *string `json:"value,omitempty" url:"value,omitempty"`
	// Multiple values for CONTAINS_ANY and CONTAINS_ALL operators
	Values []string `json:"values,omitempty" url:"values,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetadataPrecondition) GetOperator() *PreconditionOperator {
	if m == nil {
		return nil
	}
	return m.Operator
}

func (m *MetadataPrecondition) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MetadataPrecondition) GetValue() *string {
	if m == nil {
		return nil
	}
	return m.Value
}

func (m *MetadataPrecondition) GetValues() []string {
	if m == nil {
		return nil
	}
	return m.Values
}

func (m *MetadataPrecondition) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataPrecondition) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MetadataPrecondition) SetOperator(operator *PreconditionOperator) {
	m.Operator = operator
	m.require(metadataPreconditionFieldOperator)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MetadataPrecondition) SetKey(key string) {
	m.Key = key
	m.require(metadataPreconditionFieldKey)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MetadataPrecondition) SetValue(value *string) {
	m.Value = value
	m.require(metadataPreconditionFieldValue)
}

// SetValues sets the Values field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MetadataPrecondition) SetValues(values []string) {
	m.Values = values
	m.require(metadataPreconditionFieldValues)
}

func (m *MetadataPrecondition) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataPrecondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataPrecondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataPrecondition) MarshalJSON() ([]byte, error) {
	type embed MetadataPrecondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MetadataPrecondition) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	multilineSettingsSchemaEntryFieldKey          = big.NewInt(1 << 0)
	multilineSettingsSchemaEntryFieldDisplayName  = big.NewInt(1 << 1)
	multilineSettingsSchemaEntryFieldDescription  = big.NewInt(1 << 2)
	multilineSettingsSchemaEntryFieldVisibility   = big.NewInt(1 << 3)
	multilineSettingsSchemaEntryFieldRequired     = big.NewInt(1 << 4)
	multilineSettingsSchemaEntryFieldDefaultValue = big.NewInt(1 << 5)
	multilineSettingsSchemaEntryFieldValidation   = big.NewInt(1 << 6)
)

type MultilineSettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required     *bool                     `json:"required,omitempty" url:"required,omitempty"`
	DefaultValue *string                   `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	Validation   *SettingsSchemaValidation `json:"validation,omitempty" url:"validation,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MultilineSettingsSchemaEntry) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MultilineSettingsSchemaEntry) GetDisplayName() string {
	if m == nil {
		return ""
	}
	return m.DisplayName
}

func (m *MultilineSettingsSchemaEntry) GetDescription() *string {
	if m == nil {
		return nil
	}
	return m.Description
}

func (m *MultilineSettingsSchemaEntry) GetVisibility() *VisibilityType {
	if m == nil {
		return nil
	}
	return m.Visibility
}

func (m *MultilineSettingsSchemaEntry) GetRequired() *bool {
	if m == nil {
		return nil
	}
	return m.Required
}

func (m *MultilineSettingsSchemaEntry) GetDefaultValue() *string {
	if m == nil {
		return nil
	}
	return m.DefaultValue
}

func (m *MultilineSettingsSchemaEntry) GetValidation() *SettingsSchemaValidation {
	if m == nil {
		return nil
	}
	return m.Validation
}

func (m *MultilineSettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MultilineSettingsSchemaEntry) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultilineSettingsSchemaEntry) SetKey(key string) {
	m.Key = key
	m.require(multilineSettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultilineSettingsSchemaEntry) SetDisplayName(displayName string) {
	m.DisplayName = displayName
	m.require(multilineSettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultilineSettingsSchemaEntry) SetDescription(description *string) {
	m.Description = description
	m.require(multilineSettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultilineSettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	m.Visibility = visibility
	m.require(multilineSettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultilineSettingsSchemaEntry) SetRequired(required *bool) {
	m.Required = required
	m.require(multilineSettingsSchemaEntryFieldRequired)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultilineSettingsSchemaEntry) SetDefaultValue(defaultValue *string) {
	m.DefaultValue = defaultValue
	m.require(multilineSettingsSchemaEntryFieldDefaultValue)
}

// SetValidation sets the Validation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MultilineSettingsSchemaEntry) SetValidation(validation *SettingsSchemaValidation) {
	m.Validation = validation
	m.require(multilineSettingsSchemaEntryFieldValidation)
}

func (m *MultilineSettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler MultilineSettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MultilineSettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MultilineSettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed MultilineSettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MultilineSettingsSchemaEntry) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	novelSystemEventFieldTimestamp   = big.NewInt(1 << 0)
	novelSystemEventFieldReferences  = big.NewInt(1 << 1)
	novelSystemEventFieldSourceInfo  = big.NewInt(1 << 2)
	novelSystemEventFieldSessionInfo = big.NewInt(1 << 3)
	novelSystemEventFieldContextInfo = big.NewInt(1 << 4)
	novelSystemEventFieldEventName   = big.NewInt(1 << 5)
	novelSystemEventFieldID          = big.NewInt(1 << 6)
)

type NovelSystemEvent struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`
	// The name of the event
	EventName SystemEventName `json:"eventName" url:"eventName"`
	// The unique ID of the event
	ID *EntityIDBase `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NovelSystemEvent) GetTimestamp() *time.Time {
	if n == nil {
		return nil
	}
	return n.Timestamp
}

func (n *NovelSystemEvent) GetReferences() []*ScopedEntity {
	if n == nil {
		return nil
	}
	return n.References
}

func (n *NovelSystemEvent) GetSourceInfo() *SourceInfo {
	if n == nil {
		return nil
	}
	return n.SourceInfo
}

func (n *NovelSystemEvent) GetSessionInfo() *SessionInfo {
	if n == nil {
		return nil
	}
	return n.SessionInfo
}

func (n *NovelSystemEvent) GetContextInfo() *ContextInfo {
	if n == nil {
		return nil
	}
	return n.ContextInfo
}

func (n *NovelSystemEvent) GetEventName() SystemEventName {
	if n == nil {
		return ""
	}
	return n.EventName
}

func (n *NovelSystemEvent) GetID() *EntityIDBase {
	if n == nil {
		return nil
	}
	return n.ID
}

func (n *NovelSystemEvent) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NovelSystemEvent) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetTimestamp(timestamp *time.Time) {
	n.Timestamp = timestamp
	n.require(novelSystemEventFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetReferences(references []*ScopedEntity) {
	n.References = references
	n.require(novelSystemEventFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetSourceInfo(sourceInfo *SourceInfo) {
	n.SourceInfo = sourceInfo
	n.require(novelSystemEventFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetSessionInfo(sessionInfo *SessionInfo) {
	n.SessionInfo = sessionInfo
	n.require(novelSystemEventFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetContextInfo(contextInfo *ContextInfo) {
	n.ContextInfo = contextInfo
	n.require(novelSystemEventFieldContextInfo)
}

// SetEventName sets the EventName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetEventName(eventName SystemEventName) {
	n.EventName = eventName
	n.require(novelSystemEventFieldEventName)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetID(id *EntityIDBase) {
	n.ID = id
	n.require(novelSystemEventFieldID)
}

func (n *NovelSystemEvent) UnmarshalJSON(data []byte) error {
	type embed NovelSystemEvent
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NovelSystemEvent(unmarshaler.embed)
	n.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NovelSystemEvent) MarshalJSON() ([]byte, error) {
	type embed NovelSystemEvent
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*n),
		Timestamp: internal.NewOptionalDateTime(n.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NovelSystemEvent) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	novelSystemEventNoIDFieldTimestamp   = big.NewInt(1 << 0)
	novelSystemEventNoIDFieldReferences  = big.NewInt(1 << 1)
	novelSystemEventNoIDFieldSourceInfo  = big.NewInt(1 << 2)
	novelSystemEventNoIDFieldSessionInfo = big.NewInt(1 << 3)
	novelSystemEventNoIDFieldContextInfo = big.NewInt(1 << 4)
	novelSystemEventNoIDFieldEventName   = big.NewInt(1 << 5)
)

type NovelSystemEventNoID struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`
	// The name of the event
	EventName SystemEventName `json:"eventName" url:"eventName"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NovelSystemEventNoID) GetTimestamp() *time.Time {
	if n == nil {
		return nil
	}
	return n.Timestamp
}

func (n *NovelSystemEventNoID) GetReferences() []*ScopedEntity {
	if n == nil {
		return nil
	}
	return n.References
}

func (n *NovelSystemEventNoID) GetSourceInfo() *SourceInfo {
	if n == nil {
		return nil
	}
	return n.SourceInfo
}

func (n *NovelSystemEventNoID) GetSessionInfo() *SessionInfo {
	if n == nil {
		return nil
	}
	return n.SessionInfo
}

func (n *NovelSystemEventNoID) GetContextInfo() *ContextInfo {
	if n == nil {
		return nil
	}
	return n.ContextInfo
}

func (n *NovelSystemEventNoID) GetEventName() SystemEventName {
	if n == nil {
		return ""
	}
	return n.EventName
}

func (n *NovelSystemEventNoID) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NovelSystemEventNoID) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoID) SetTimestamp(timestamp *time.Time) {
	n.Timestamp = timestamp
	n.require(novelSystemEventNoIDFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoID) SetReferences(references []*ScopedEntity) {
	n.References = references
	n.require(novelSystemEventNoIDFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoID) SetSourceInfo(sourceInfo *SourceInfo) {
	n.SourceInfo = sourceInfo
	n.require(novelSystemEventNoIDFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoID) SetSessionInfo(sessionInfo *SessionInfo) {
	n.SessionInfo = sessionInfo
	n.require(novelSystemEventNoIDFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoID) SetContextInfo(contextInfo *ContextInfo) {
	n.ContextInfo = contextInfo
	n.require(novelSystemEventNoIDFieldContextInfo)
}

// SetEventName sets the EventName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoID) SetEventName(eventName SystemEventName) {
	n.EventName = eventName
	n.require(novelSystemEventNoIDFieldEventName)
}

func (n *NovelSystemEventNoID) UnmarshalJSON(data []byte) error {
	type embed NovelSystemEventNoID
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NovelSystemEventNoID(unmarshaler.embed)
	n.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NovelSystemEventNoID) MarshalJSON() ([]byte, error) {
	type embed NovelSystemEventNoID
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*n),
		Timestamp: internal.NewOptionalDateTime(n.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NovelSystemEventNoID) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	novelUserEventFieldTimestamp    = big.NewInt(1 << 0)
	novelUserEventFieldReferences   = big.NewInt(1 << 1)
	novelUserEventFieldSourceInfo   = big.NewInt(1 << 2)
	novelUserEventFieldSessionInfo  = big.NewInt(1 << 3)
	novelUserEventFieldContextInfo  = big.NewInt(1 << 4)
	novelUserEventFieldID           = big.NewInt(1 << 5)
	novelUserEventFieldEventName    = big.NewInt(1 << 6)
	novelUserEventFieldUserInfo     = big.NewInt(1 << 7)
	novelUserEventFieldCsatInfo     = big.NewInt(1 << 8)
	novelUserEventFieldFeedbackInfo = big.NewInt(1 << 9)
	novelUserEventFieldPageInfo     = big.NewInt(1 << 10)
)

type NovelUserEvent struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`
	// The unique ID of the event
	ID *EntityIDBase `json:"id" url:"id"`
	// The name of the event
	EventName UserEventName `json:"eventName" url:"eventName"`
	// Information about the user who triggered the event
	UserInfo *EventUserInfoBase `json:"userInfo" url:"userInfo"`
	// Information about any CSAT associated with the event
	CsatInfo *CsatInfo `json:"csatInfo,omitempty" url:"csatInfo,omitempty"`
	// Information about any feedback associated with the event
	FeedbackInfo []*FeedbackInfo `json:"feedbackInfo,omitempty" url:"feedbackInfo,omitempty"`
	// Information about the page on which the event occurred
	PageInfo *PageInfo `json:"pageInfo,omitempty" url:"pageInfo,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NovelUserEvent) GetTimestamp() *time.Time {
	if n == nil {
		return nil
	}
	return n.Timestamp
}

func (n *NovelUserEvent) GetReferences() []*ScopedEntity {
	if n == nil {
		return nil
	}
	return n.References
}

func (n *NovelUserEvent) GetSourceInfo() *SourceInfo {
	if n == nil {
		return nil
	}
	return n.SourceInfo
}

func (n *NovelUserEvent) GetSessionInfo() *SessionInfo {
	if n == nil {
		return nil
	}
	return n.SessionInfo
}

func (n *NovelUserEvent) GetContextInfo() *ContextInfo {
	if n == nil {
		return nil
	}
	return n.ContextInfo
}

func (n *NovelUserEvent) GetID() *EntityIDBase {
	if n == nil {
		return nil
	}
	return n.ID
}

func (n *NovelUserEvent) GetEventName() UserEventName {
	if n == nil {
		return ""
	}
	return n.EventName
}

func (n *NovelUserEvent) GetUserInfo() *EventUserInfoBase {
	if n == nil {
		return nil
	}
	return n.UserInfo
}

func (n *NovelUserEvent) GetCsatInfo() *CsatInfo {
	if n == nil {
		return nil
	}
	return n.CsatInfo
}

func (n *NovelUserEvent) GetFeedbackInfo() []*FeedbackInfo {
	if n == nil {
		return nil
	}
	return n.FeedbackInfo
}

func (n *NovelUserEvent) GetPageInfo() *PageInfo {
	if n == nil {
		return nil
	}
	return n.PageInfo
}

func (n *NovelUserEvent) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NovelUserEvent) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetTimestamp(timestamp *time.Time) {
	n.Timestamp = timestamp
	n.require(novelUserEventFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetReferences(references []*ScopedEntity) {
	n.References = references
	n.require(novelUserEventFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetSourceInfo(sourceInfo *SourceInfo) {
	n.SourceInfo = sourceInfo
	n.require(novelUserEventFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetSessionInfo(sessionInfo *SessionInfo) {
	n.SessionInfo = sessionInfo
	n.require(novelUserEventFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetContextInfo(contextInfo *ContextInfo) {
	n.ContextInfo = contextInfo
	n.require(novelUserEventFieldContextInfo)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetID(id *EntityIDBase) {
	n.ID = id
	n.require(novelUserEventFieldID)
}

// SetEventName sets the EventName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetEventName(eventName UserEventName) {
	n.EventName = eventName
	n.require(novelUserEventFieldEventName)
}

// SetUserInfo sets the UserInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetUserInfo(userInfo *EventUserInfoBase) {
	n.UserInfo = userInfo
	n.require(novelUserEventFieldUserInfo)
}

// SetCsatInfo sets the CsatInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetCsatInfo(csatInfo *CsatInfo) {
	n.CsatInfo = csatInfo
	n.require(novelUserEventFieldCsatInfo)
}

// SetFeedbackInfo sets the FeedbackInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetFeedbackInfo(feedbackInfo []*FeedbackInfo) {
	n.FeedbackInfo = feedbackInfo
	n.require(novelUserEventFieldFeedbackInfo)
}

// SetPageInfo sets the PageInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetPageInfo(pageInfo *PageInfo) {
	n.PageInfo = pageInfo
	n.require(novelUserEventFieldPageInfo)
}

func (n *NovelUserEvent) UnmarshalJSON(data []byte) error {
	type embed NovelUserEvent
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NovelUserEvent(unmarshaler.embed)
	n.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NovelUserEvent) MarshalJSON() ([]byte, error) {
	type embed NovelUserEvent
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*n),
		Timestamp: internal.NewOptionalDateTime(n.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NovelUserEvent) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// A range of numbers that can be used to filter search results by numeric fields.
// - `greaterThanOrEqual`: The minimum value (inclusive).
// - `lessThan`: The maximum value (exclusive).
var (
	numberRangeFieldGreaterThanOrEqual = big.NewInt(1 << 0)
	numberRangeFieldLessThan           = big.NewInt(1 << 1)
)

type NumberRange struct {
	GreaterThanOrEqual *int `json:"greaterThanOrEqual,omitempty" url:"greaterThanOrEqual,omitempty"`
	LessThan           *int `json:"lessThan,omitempty" url:"lessThan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NumberRange) GetGreaterThanOrEqual() *int {
	if n == nil {
		return nil
	}
	return n.GreaterThanOrEqual
}

func (n *NumberRange) GetLessThan() *int {
	if n == nil {
		return nil
	}
	return n.LessThan
}

func (n *NumberRange) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumberRange) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetGreaterThanOrEqual sets the GreaterThanOrEqual field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumberRange) SetGreaterThanOrEqual(greaterThanOrEqual *int) {
	n.GreaterThanOrEqual = greaterThanOrEqual
	n.require(numberRangeFieldGreaterThanOrEqual)
}

// SetLessThan sets the LessThan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumberRange) SetLessThan(lessThan *int) {
	n.LessThan = lessThan
	n.require(numberRangeFieldLessThan)
}

func (n *NumberRange) UnmarshalJSON(data []byte) error {
	type unmarshaler NumberRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumberRange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumberRange) MarshalJSON() ([]byte, error) {
	type embed NumberRange
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NumberRange) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	numberSettingsSchemaEntryFieldKey          = big.NewInt(1 << 0)
	numberSettingsSchemaEntryFieldDisplayName  = big.NewInt(1 << 1)
	numberSettingsSchemaEntryFieldDescription  = big.NewInt(1 << 2)
	numberSettingsSchemaEntryFieldVisibility   = big.NewInt(1 << 3)
	numberSettingsSchemaEntryFieldRequired     = big.NewInt(1 << 4)
	numberSettingsSchemaEntryFieldDefaultValue = big.NewInt(1 << 5)
	numberSettingsSchemaEntryFieldValidation   = big.NewInt(1 << 6)
)

type NumberSettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required     *bool                     `json:"required,omitempty" url:"required,omitempty"`
	DefaultValue *float64                  `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	Validation   *SettingsSchemaValidation `json:"validation,omitempty" url:"validation,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NumberSettingsSchemaEntry) GetKey() string {
	if n == nil {
		return ""
	}
	return n.Key
}

func (n *NumberSettingsSchemaEntry) GetDisplayName() string {
	if n == nil {
		return ""
	}
	return n.DisplayName
}

func (n *NumberSettingsSchemaEntry) GetDescription() *string {
	if n == nil {
		return nil
	}
	return n.Description
}

func (n *NumberSettingsSchemaEntry) GetVisibility() *VisibilityType {
	if n == nil {
		return nil
	}
	return n.Visibility
}

func (n *NumberSettingsSchemaEntry) GetRequired() *bool {
	if n == nil {
		return nil
	}
	return n.Required
}

func (n *NumberSettingsSchemaEntry) GetDefaultValue() *float64 {
	if n == nil {
		return nil
	}
	return n.DefaultValue
}

func (n *NumberSettingsSchemaEntry) GetValidation() *SettingsSchemaValidation {
	if n == nil {
		return nil
	}
	return n.Validation
}

func (n *NumberSettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumberSettingsSchemaEntry) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumberSettingsSchemaEntry) SetKey(key string) {
	n.Key = key
	n.require(numberSettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumberSettingsSchemaEntry) SetDisplayName(displayName string) {
	n.DisplayName = displayName
	n.require(numberSettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumberSettingsSchemaEntry) SetDescription(description *string) {
	n.Description = description
	n.require(numberSettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumberSettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	n.Visibility = visibility
	n.require(numberSettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumberSettingsSchemaEntry) SetRequired(required *bool) {
	n.Required = required
	n.require(numberSettingsSchemaEntryFieldRequired)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumberSettingsSchemaEntry) SetDefaultValue(defaultValue *float64) {
	n.DefaultValue = defaultValue
	n.require(numberSettingsSchemaEntryFieldDefaultValue)
}

// SetValidation sets the Validation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumberSettingsSchemaEntry) SetValidation(validation *SettingsSchemaValidation) {
	n.Validation = validation
	n.require(numberSettingsSchemaEntryFieldValidation)
}

func (n *NumberSettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler NumberSettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumberSettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumberSettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed NumberSettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NumberSettingsSchemaEntry) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Condition comparing against a single numeric value
var (
	numericComparisonConditionFieldOperator = big.NewInt(1 << 0)
	numericComparisonConditionFieldValue    = big.NewInt(1 << 1)
)

type NumericComparisonCondition struct {
	// The comparison operator to apply
	Operator NumericComparisonOperator `json:"operator" url:"operator"`
	// The numeric value to compare against
	Value float64 `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NumericComparisonCondition) GetOperator() NumericComparisonOperator {
	if n == nil {
		return ""
	}
	return n.Operator
}

func (n *NumericComparisonCondition) GetValue() float64 {
	if n == nil {
		return 0
	}
	return n.Value
}

func (n *NumericComparisonCondition) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumericComparisonCondition) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericComparisonCondition) SetOperator(operator NumericComparisonOperator) {
	n.Operator = operator
	n.require(numericComparisonConditionFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericComparisonCondition) SetValue(value float64) {
	n.Value = value
	n.require(numericComparisonConditionFieldValue)
}

func (n *NumericComparisonCondition) UnmarshalJSON(data []byte) error {
	type unmarshaler NumericComparisonCondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumericComparisonCondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumericComparisonCondition) MarshalJSON() ([]byte, error) {
	type embed NumericComparisonCondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NumericComparisonCondition) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Operators for single numeric value comparisons
type NumericComparisonOperator string

const (
	// Equals (=)
	NumericComparisonOperatorEq NumericComparisonOperator = "EQ"
	// Not equals (!=)
	NumericComparisonOperatorNeq NumericComparisonOperator = "NEQ"
	// Less than (<)
	NumericComparisonOperatorLt NumericComparisonOperator = "LT"
	// Less than or equals (<=)
	NumericComparisonOperatorLe NumericComparisonOperator = "LE"
	// Greater than (>)
	NumericComparisonOperatorGt NumericComparisonOperator = "GT"
	// Greater than or equals (>=)
	NumericComparisonOperatorGe NumericComparisonOperator = "GE"
)

func NewNumericComparisonOperatorFromString(s string) (NumericComparisonOperator, error) {
	switch s {
	case "EQ":
		return NumericComparisonOperatorEq, nil
	case "NEQ":
		return NumericComparisonOperatorNeq, nil
	case "LT":
		return NumericComparisonOperatorLt, nil
	case "LE":
		return NumericComparisonOperatorLe, nil
	case "GT":
		return NumericComparisonOperatorGt, nil
	case "GE":
		return NumericComparisonOperatorGe, nil
	}
	var t NumericComparisonOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NumericComparisonOperator) Ptr() *NumericComparisonOperator {
	return &n
}

// Condition for numeric values
type NumericCondition struct {
	OpType     string
	Comparison *NumericComparisonCondition
	Membership *NumericMembershipCondition
}

func (n *NumericCondition) GetOpType() string {
	if n == nil {
		return ""
	}
	return n.OpType
}

func (n *NumericCondition) GetComparison() *NumericComparisonCondition {
	if n == nil {
		return nil
	}
	return n.Comparison
}

func (n *NumericCondition) GetMembership() *NumericMembershipCondition {
	if n == nil {
		return nil
	}
	return n.Membership
}

func (n *NumericCondition) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		OpType string `json:"opType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	n.OpType = unmarshaler.OpType
	if unmarshaler.OpType == "" {
		return fmt.Errorf("%T did not include discriminant opType", n)
	}
	switch unmarshaler.OpType {
	case "comparison":
		value := new(NumericComparisonCondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Comparison = value
	case "membership":
		value := new(NumericMembershipCondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		n.Membership = value
	}
	return nil
}

func (n NumericCondition) MarshalJSON() ([]byte, error) {
	if err := n.validate(); err != nil {
		return nil, err
	}
	if n.Comparison != nil {
		return internal.MarshalJSONWithExtraProperty(n.Comparison, "opType", "comparison")
	}
	if n.Membership != nil {
		return internal.MarshalJSONWithExtraProperty(n.Membership, "opType", "membership")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", n)
}

type NumericConditionVisitor interface {
	VisitComparison(*NumericComparisonCondition) error
	VisitMembership(*NumericMembershipCondition) error
}

func (n *NumericCondition) Accept(visitor NumericConditionVisitor) error {
	if n.Comparison != nil {
		return visitor.VisitComparison(n.Comparison)
	}
	if n.Membership != nil {
		return visitor.VisitMembership(n.Membership)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", n)
}

func (n *NumericCondition) validate() error {
	if n == nil {
		return fmt.Errorf("type %T is nil", n)
	}
	var fields []string
	if n.Comparison != nil {
		fields = append(fields, "comparison")
	}
	if n.Membership != nil {
		fields = append(fields, "membership")
	}
	if len(fields) == 0 {
		if n.OpType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", n, n.OpType)
		}
		return fmt.Errorf("type %T is empty", n)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", n, fields)
	}
	if n.OpType != "" {
		field := fields[0]
		if n.OpType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				n,
				n.OpType,
				n,
			)
		}
	}
	return nil
}

// Condition checking membership in a set of numbers
var (
	numericMembershipConditionFieldOperator = big.NewInt(1 << 0)
	numericMembershipConditionFieldValues   = big.NewInt(1 << 1)
)

type NumericMembershipCondition struct {
	// The comparison operator to apply
	Operator NumericMembershipOperator `json:"operator" url:"operator"`
	// The set of numeric values to compare against
	Values []float64 `json:"values" url:"values"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NumericMembershipCondition) GetOperator() NumericMembershipOperator {
	if n == nil {
		return ""
	}
	return n.Operator
}

func (n *NumericMembershipCondition) GetValues() []float64 {
	if n == nil {
		return nil
	}
	return n.Values
}

func (n *NumericMembershipCondition) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumericMembershipCondition) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericMembershipCondition) SetOperator(operator NumericMembershipOperator) {
	n.Operator = operator
	n.require(numericMembershipConditionFieldOperator)
}

// SetValues sets the Values field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumericMembershipCondition) SetValues(values []float64) {
	n.Values = values
	n.require(numericMembershipConditionFieldValues)
}

func (n *NumericMembershipCondition) UnmarshalJSON(data []byte) error {
	type unmarshaler NumericMembershipCondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumericMembershipCondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumericMembershipCondition) MarshalJSON() ([]byte, error) {
	type embed NumericMembershipCondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NumericMembershipCondition) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// Operators for numeric set membership
type NumericMembershipOperator string

const (
	// Value is in the set ()
	NumericMembershipOperatorIn NumericMembershipOperator = "IN"
	// Value is not in the set ()
	NumericMembershipOperatorNotIn NumericMembershipOperator = "NOT_IN"
)

func NewNumericMembershipOperatorFromString(s string) (NumericMembershipOperator, error) {
	switch s {
	case "IN":
		return NumericMembershipOperatorIn, nil
	case "NOT_IN":
		return NumericMembershipOperatorNotIn, nil
	}
	var t NumericMembershipOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (n NumericMembershipOperator) Ptr() *NumericMembershipOperator {
	return &n
}

// The authentication method to use for OAuth token requests
type OAuthAuthenticationMethod string

const (
	// Basic Auth with credentials in Authorization header
	OAuthAuthenticationMethodBasic OAuthAuthenticationMethod = "basic"
	// Credentials in request body (default)
	OAuthAuthenticationMethodPost OAuthAuthenticationMethod = "post"
)

func NewOAuthAuthenticationMethodFromString(s string) (OAuthAuthenticationMethod, error) {
	switch s {
	case "basic":
		return OAuthAuthenticationMethodBasic, nil
	case "post":
		return OAuthAuthenticationMethodPost, nil
	}
	var t OAuthAuthenticationMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OAuthAuthenticationMethod) Ptr() *OAuthAuthenticationMethod {
	return &o
}

var (
	oAuthSettingsSchemaEntryFieldKey                       = big.NewInt(1 << 0)
	oAuthSettingsSchemaEntryFieldDisplayName               = big.NewInt(1 << 1)
	oAuthSettingsSchemaEntryFieldDescription               = big.NewInt(1 << 2)
	oAuthSettingsSchemaEntryFieldVisibility                = big.NewInt(1 << 3)
	oAuthSettingsSchemaEntryFieldRequired                  = big.NewInt(1 << 4)
	oAuthSettingsSchemaEntryFieldOauthScopes               = big.NewInt(1 << 5)
	oAuthSettingsSchemaEntryFieldScopeLabels               = big.NewInt(1 << 6)
	oAuthSettingsSchemaEntryFieldOauthRedirectURI          = big.NewInt(1 << 7)
	oAuthSettingsSchemaEntryFieldOauthClientID             = big.NewInt(1 << 8)
	oAuthSettingsSchemaEntryFieldOauthAuthorizationURL     = big.NewInt(1 << 9)
	oAuthSettingsSchemaEntryFieldOauthClientSecret         = big.NewInt(1 << 10)
	oAuthSettingsSchemaEntryFieldOauthTokenURL             = big.NewInt(1 << 11)
	oAuthSettingsSchemaEntryFieldOauthAuthenticationMethod = big.NewInt(1 << 12)
)

type OAuthSettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required *bool `json:"required,omitempty" url:"required,omitempty"`
	// The scopes to request from the OAuth provider.
	OauthScopes []string `json:"oauthScopes" url:"oauthScopes"`
	// Optional labels for customizing scope display names.
	ScopeLabels           []interface{} `json:"scopeLabels,omitempty" url:"scopeLabels,omitempty"`
	OauthRedirectURI      *string       `json:"oauthRedirectUri,omitempty" url:"oauthRedirectUri,omitempty"`
	OauthClientID         *string       `json:"oauthClientId,omitempty" url:"oauthClientId,omitempty"`
	OauthAuthorizationURL *string       `json:"oauthAuthorizationUrl,omitempty" url:"oauthAuthorizationUrl,omitempty"`
	OauthClientSecret     *string       `json:"oauthClientSecret,omitempty" url:"oauthClientSecret,omitempty"`
	OauthTokenURL         *string       `json:"oauthTokenUrl,omitempty" url:"oauthTokenUrl,omitempty"`
	// The authentication method for OAuth token requests.
	OauthAuthenticationMethod *OAuthAuthenticationMethod `json:"oauthAuthenticationMethod,omitempty" url:"oauthAuthenticationMethod,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OAuthSettingsSchemaEntry) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *OAuthSettingsSchemaEntry) GetDisplayName() string {
	if o == nil {
		return ""
	}
	return o.DisplayName
}

func (o *OAuthSettingsSchemaEntry) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OAuthSettingsSchemaEntry) GetVisibility() *VisibilityType {
	if o == nil {
		return nil
	}
	return o.Visibility
}

func (o *OAuthSettingsSchemaEntry) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *OAuthSettingsSchemaEntry) GetOauthScopes() []string {
	if o == nil {
		return nil
	}
	return o.OauthScopes
}

func (o *OAuthSettingsSchemaEntry) GetScopeLabels() []interface{} {
	if o == nil {
		return nil
	}
	return o.ScopeLabels
}

func (o *OAuthSettingsSchemaEntry) GetOauthRedirectURI() *string {
	if o == nil {
		return nil
	}
	return o.OauthRedirectURI
}

func (o *OAuthSettingsSchemaEntry) GetOauthClientID() *string {
	if o == nil {
		return nil
	}
	return o.OauthClientID
}

func (o *OAuthSettingsSchemaEntry) GetOauthAuthorizationURL() *string {
	if o == nil {
		return nil
	}
	return o.OauthAuthorizationURL
}

func (o *OAuthSettingsSchemaEntry) GetOauthClientSecret() *string {
	if o == nil {
		return nil
	}
	return o.OauthClientSecret
}

func (o *OAuthSettingsSchemaEntry) GetOauthTokenURL() *string {
	if o == nil {
		return nil
	}
	return o.OauthTokenURL
}

func (o *OAuthSettingsSchemaEntry) GetOauthAuthenticationMethod() *OAuthAuthenticationMethod {
	if o == nil {
		return nil
	}
	return o.OauthAuthenticationMethod
}

func (o *OAuthSettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OAuthSettingsSchemaEntry) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetKey(key string) {
	o.Key = key
	o.require(oAuthSettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetDisplayName(displayName string) {
	o.DisplayName = displayName
	o.require(oAuthSettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetDescription(description *string) {
	o.Description = description
	o.require(oAuthSettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	o.Visibility = visibility
	o.require(oAuthSettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetRequired(required *bool) {
	o.Required = required
	o.require(oAuthSettingsSchemaEntryFieldRequired)
}

// SetOauthScopes sets the OauthScopes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetOauthScopes(oauthScopes []string) {
	o.OauthScopes = oauthScopes
	o.require(oAuthSettingsSchemaEntryFieldOauthScopes)
}

// SetScopeLabels sets the ScopeLabels field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetScopeLabels(scopeLabels []interface{}) {
	o.ScopeLabels = scopeLabels
	o.require(oAuthSettingsSchemaEntryFieldScopeLabels)
}

// SetOauthRedirectURI sets the OauthRedirectURI field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetOauthRedirectURI(oauthRedirectURI *string) {
	o.OauthRedirectURI = oauthRedirectURI
	o.require(oAuthSettingsSchemaEntryFieldOauthRedirectURI)
}

// SetOauthClientID sets the OauthClientID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetOauthClientID(oauthClientID *string) {
	o.OauthClientID = oauthClientID
	o.require(oAuthSettingsSchemaEntryFieldOauthClientID)
}

// SetOauthAuthorizationURL sets the OauthAuthorizationURL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetOauthAuthorizationURL(oauthAuthorizationURL *string) {
	o.OauthAuthorizationURL = oauthAuthorizationURL
	o.require(oAuthSettingsSchemaEntryFieldOauthAuthorizationURL)
}

// SetOauthClientSecret sets the OauthClientSecret field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetOauthClientSecret(oauthClientSecret *string) {
	o.OauthClientSecret = oauthClientSecret
	o.require(oAuthSettingsSchemaEntryFieldOauthClientSecret)
}

// SetOauthTokenURL sets the OauthTokenURL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetOauthTokenURL(oauthTokenURL *string) {
	o.OauthTokenURL = oauthTokenURL
	o.require(oAuthSettingsSchemaEntryFieldOauthTokenURL)
}

// SetOauthAuthenticationMethod sets the OauthAuthenticationMethod field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OAuthSettingsSchemaEntry) SetOauthAuthenticationMethod(oauthAuthenticationMethod *OAuthAuthenticationMethod) {
	o.OauthAuthenticationMethod = oauthAuthenticationMethod
	o.require(oAuthSettingsSchemaEntryFieldOauthAuthenticationMethod)
}

func (o *OAuthSettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthSettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthSettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OAuthSettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed OAuthSettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OAuthSettingsSchemaEntry) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

var (
	oneOfSettingsSchemaEntryFieldKey          = big.NewInt(1 << 0)
	oneOfSettingsSchemaEntryFieldDisplayName  = big.NewInt(1 << 1)
	oneOfSettingsSchemaEntryFieldDescription  = big.NewInt(1 << 2)
	oneOfSettingsSchemaEntryFieldVisibility   = big.NewInt(1 << 3)
	oneOfSettingsSchemaEntryFieldRequired     = big.NewInt(1 << 4)
	oneOfSettingsSchemaEntryFieldUnionOptions = big.NewInt(1 << 5)
	oneOfSettingsSchemaEntryFieldDefaultValue = big.NewInt(1 << 6)
)

type OneOfSettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required     *bool                                   `json:"required,omitempty" url:"required,omitempty"`
	UnionOptions SettingsSchemaDiscriminatedUnionOptions `json:"unionOptions" url:"unionOptions"`
	DefaultValue interface{}                             `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OneOfSettingsSchemaEntry) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *OneOfSettingsSchemaEntry) GetDisplayName() string {
	if o == nil {
		return ""
	}
	return o.DisplayName
}

func (o *OneOfSettingsSchemaEntry) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *OneOfSettingsSchemaEntry) GetVisibility() *VisibilityType {
	if o == nil {
		return nil
	}
	return o.Visibility
}

func (o *OneOfSettingsSchemaEntry) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *OneOfSettingsSchemaEntry) GetUnionOptions() SettingsSchemaDiscriminatedUnionOptions {
	if o == nil {
		return nil
	}
	return o.UnionOptions
}

func (o *OneOfSettingsSchemaEntry) GetDefaultValue() interface{} {
	if o == nil {
		return nil
	}
	return o.DefaultValue
}

func (o *OneOfSettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OneOfSettingsSchemaEntry) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OneOfSettingsSchemaEntry) SetKey(key string) {
	o.Key = key
	o.require(oneOfSettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OneOfSettingsSchemaEntry) SetDisplayName(displayName string) {
	o.DisplayName = displayName
	o.require(oneOfSettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OneOfSettingsSchemaEntry) SetDescription(description *string) {
	o.Description = description
	o.require(oneOfSettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OneOfSettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	o.Visibility = visibility
	o.require(oneOfSettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OneOfSettingsSchemaEntry) SetRequired(required *bool) {
	o.Required = required
	o.require(oneOfSettingsSchemaEntryFieldRequired)
}

// SetUnionOptions sets the UnionOptions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OneOfSettingsSchemaEntry) SetUnionOptions(unionOptions SettingsSchemaDiscriminatedUnionOptions) {
	o.UnionOptions = unionOptions
	o.require(oneOfSettingsSchemaEntryFieldUnionOptions)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OneOfSettingsSchemaEntry) SetDefaultValue(defaultValue interface{}) {
	o.DefaultValue = defaultValue
	o.require(oneOfSettingsSchemaEntryFieldDefaultValue)
}

func (o *OneOfSettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler OneOfSettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OneOfSettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OneOfSettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed OneOfSettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OneOfSettingsSchemaEntry) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

var (
	osInfoFieldType    = big.NewInt(1 << 0)
	osInfoFieldName    = big.NewInt(1 << 1)
	osInfoFieldVersion = big.NewInt(1 << 2)
)

type OsInfo struct {
	Type    *OsType `json:"type,omitempty" url:"type,omitempty"`
	Name    *string `json:"name,omitempty" url:"name,omitempty"`
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OsInfo) GetType() *OsType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OsInfo) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OsInfo) GetVersion() *string {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *OsInfo) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OsInfo) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OsInfo) SetType(type_ *OsType) {
	o.Type = type_
	o.require(osInfoFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OsInfo) SetName(name *string) {
	o.Name = name
	o.require(osInfoFieldName)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OsInfo) SetVersion(version *string) {
	o.Version = version
	o.require(osInfoFieldVersion)
}

func (o *OsInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler OsInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OsInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OsInfo) MarshalJSON() ([]byte, error) {
	type embed OsInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OsInfo) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OsType string

const (
	OsTypeWindows OsType = "WINDOWS"
	OsTypeMacos   OsType = "MACOS"
	OsTypeLinux   OsType = "LINUX"
	OsTypeAndroid OsType = "ANDROID"
	OsTypeIos     OsType = "IOS"
	OsTypeOther   OsType = "OTHER"
)

func NewOsTypeFromString(s string) (OsType, error) {
	switch s {
	case "WINDOWS":
		return OsTypeWindows, nil
	case "MACOS":
		return OsTypeMacos, nil
	case "LINUX":
		return OsTypeLinux, nil
	case "ANDROID":
		return OsTypeAndroid, nil
	case "IOS":
		return OsTypeIos, nil
	case "OTHER":
		return OsTypeOther, nil
	}
	var t OsType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OsType) Ptr() *OsType {
	return &o
}

var (
	pageFieldNumber        = big.NewInt(1 << 0)
	pageFieldSize          = big.NewInt(1 << 1)
	pageFieldTotalElements = big.NewInt(1 << 2)
	pageFieldTotalPages    = big.NewInt(1 << 3)
)

type Page struct {
	// The page being returned, starts at 0
	Number int `json:"number" url:"number"`
	// The number of elements in this page
	Size int `json:"size" url:"size"`
	// The total number of elements in the collection
	TotalElements int64 `json:"totalElements" url:"totalElements"`
	// The total number of pages in the collection
	TotalPages int `json:"totalPages" url:"totalPages"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Page) GetNumber() int {
	if p == nil {
		return 0
	}
	return p.Number
}

func (p *Page) GetSize() int {
	if p == nil {
		return 0
	}
	return p.Size
}

func (p *Page) GetTotalElements() int64 {
	if p == nil {
		return 0
	}
	return p.TotalElements
}

func (p *Page) GetTotalPages() int {
	if p == nil {
		return 0
	}
	return p.TotalPages
}

func (p *Page) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Page) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNumber sets the Number field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetNumber(number int) {
	p.Number = number
	p.require(pageFieldNumber)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetSize(size int) {
	p.Size = size
	p.require(pageFieldSize)
}

// SetTotalElements sets the TotalElements field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetTotalElements(totalElements int64) {
	p.TotalElements = totalElements
	p.require(pageFieldTotalElements)
}

// SetTotalPages sets the TotalPages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetTotalPages(totalPages int) {
	p.TotalPages = totalPages
	p.require(pageFieldTotalPages)
}

func (p *Page) UnmarshalJSON(data []byte) error {
	type unmarshaler Page
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Page(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Page) MarshalJSON() ([]byte, error) {
	type embed Page
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *Page) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	pageInfoFieldPageName  = big.NewInt(1 << 0)
	pageInfoFieldPageURL   = big.NewInt(1 << 1)
	pageInfoFieldPageTitle = big.NewInt(1 << 2)
	pageInfoFieldLinkURL   = big.NewInt(1 << 3)
	pageInfoFieldElementID = big.NewInt(1 << 4)
)

type PageInfo struct {
	PageName  *string `json:"pageName,omitempty" url:"pageName,omitempty"`
	PageURL   *string `json:"pageUrl,omitempty" url:"pageUrl,omitempty"`
	PageTitle *string `json:"pageTitle,omitempty" url:"pageTitle,omitempty"`
	LinkURL   *string `json:"linkUrl,omitempty" url:"linkUrl,omitempty"`
	ElementID *string `json:"elementId,omitempty" url:"elementId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PageInfo) GetPageName() *string {
	if p == nil {
		return nil
	}
	return p.PageName
}

func (p *PageInfo) GetPageURL() *string {
	if p == nil {
		return nil
	}
	return p.PageURL
}

func (p *PageInfo) GetPageTitle() *string {
	if p == nil {
		return nil
	}
	return p.PageTitle
}

func (p *PageInfo) GetLinkURL() *string {
	if p == nil {
		return nil
	}
	return p.LinkURL
}

func (p *PageInfo) GetElementID() *string {
	if p == nil {
		return nil
	}
	return p.ElementID
}

func (p *PageInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PageInfo) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPageName sets the PageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PageInfo) SetPageName(pageName *string) {
	p.PageName = pageName
	p.require(pageInfoFieldPageName)
}

// SetPageURL sets the PageURL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PageInfo) SetPageURL(pageURL *string) {
	p.PageURL = pageURL
	p.require(pageInfoFieldPageURL)
}

// SetPageTitle sets the PageTitle field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PageInfo) SetPageTitle(pageTitle *string) {
	p.PageTitle = pageTitle
	p.require(pageInfoFieldPageTitle)
}

// SetLinkURL sets the LinkURL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PageInfo) SetLinkURL(linkURL *string) {
	p.LinkURL = linkURL
	p.require(pageInfoFieldLinkURL)
}

// SetElementID sets the ElementID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PageInfo) SetElementID(elementID *string) {
	p.ElementID = elementID
	p.require(pageInfoFieldElementID)
}

func (p *PageInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PageInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PageInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PageInfo) MarshalJSON() ([]byte, error) {
	type embed PageInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PageInfo) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PiiCategory string

const (
	PiiCategoryName                               PiiCategory = "Name"
	PiiCategoryEmail                              PiiCategory = "Email"
	PiiCategoryPhoneNumber                        PiiCategory = "PhoneNumber"
	PiiCategoryStreetAddress                      PiiCategory = "StreetAddress"
	PiiCategoryCreditCardNumber                   PiiCategory = "CreditCardNumber"
	PiiCategoryUsBankAccountNumber                PiiCategory = "UsBankAccountNumber"
	PiiCategoryUsSocialSecurityNumber             PiiCategory = "UsSocialSecurityNumber"
	PiiCategoryUsUkPassportNumber                 PiiCategory = "UsUkPassportNumber"
	PiiCategoryUsDriversLicenseNumber             PiiCategory = "UsDriversLicenseNumber"
	PiiCategoryUsIndividualTaxpayerIdentification PiiCategory = "UsIndividualTaxpayerIdentification"
	PiiCategoryDate                               PiiCategory = "Date"
	PiiCategoryIPAddress                          PiiCategory = "IpAddress"
	PiiCategoryURL                                PiiCategory = "Url"
	PiiCategoryAbaRoutingNumber                   PiiCategory = "AbaRoutingNumber"
	PiiCategoryAge                                PiiCategory = "Age"
	PiiCategorySwiftCode                          PiiCategory = "SwiftCode"
	PiiCategoryAuBankAccountNumber                PiiCategory = "AuBankAccountNumber"
	PiiCategoryAuBusinessNumber                   PiiCategory = "AuBusinessNumber"
	PiiCategoryAuCompanyNumber                    PiiCategory = "AuCompanyNumber"
	PiiCategoryAuDriversLicenseNumber             PiiCategory = "AuDriversLicenseNumber"
	PiiCategoryAuMedicalAccountNumber             PiiCategory = "AuMedicalAccountNumber"
	PiiCategoryAuPassportNumber                   PiiCategory = "AuPassportNumber"
	PiiCategoryAuTaxFileNumber                    PiiCategory = "AuTaxFileNumber"
	PiiCategoryCaBankAccountNumber                PiiCategory = "CaBankAccountNumber"
	PiiCategoryCaDriversLicenseNumber             PiiCategory = "CaDriversLicenseNumber"
	PiiCategoryCaHealthServiceNumber              PiiCategory = "CaHealthServiceNumber"
	PiiCategoryCaPassportNumber                   PiiCategory = "CaPassportNumber"
	PiiCategoryCaPersonalHealthIdentification     PiiCategory = "CaPersonalHealthIdentification"
	PiiCategoryCaSocialInsuranceNumber            PiiCategory = "CaSocialInsuranceNumber"
	PiiCategoryEsDni                              PiiCategory = "EsDni"
	PiiCategoryEsSocialSecurityNumber             PiiCategory = "EsSocialSecurityNumber"
	PiiCategoryEsTaxIdentificationNumber          PiiCategory = "EsTaxIdentificationNumber"
	PiiCategoryEuDebitCardNumber                  PiiCategory = "EuDebitCardNumber"
	PiiCategoryEuDriversLicenseNumber             PiiCategory = "EuDriversLicenseNumber"
	PiiCategoryEuGpsCoordinates                   PiiCategory = "EuGpsCoordinates"
	PiiCategoryEuNationalIdentificationNumber     PiiCategory = "EuNationalIdentificationNumber"
	PiiCategoryEuPassportNumber                   PiiCategory = "EuPassportNumber"
	PiiCategoryEuSocialSecurityNumber             PiiCategory = "EuSocialSecurityNumber"
	PiiCategoryEuTaxIdentificationNumber          PiiCategory = "EuTaxIdentificationNumber"
	PiiCategoryFrDriversLicenseNumber             PiiCategory = "FrDriversLicenseNumber"
	PiiCategoryFrHealthInsuranceNumber            PiiCategory = "FrHealthInsuranceNumber"
	PiiCategoryFrNationalID                       PiiCategory = "FrNationalId"
	PiiCategoryFrPassportNumber                   PiiCategory = "FrPassportNumber"
	PiiCategoryFrSocialSecurityNumber             PiiCategory = "FrSocialSecurityNumber"
	PiiCategoryFrTaxIdentificationNumber          PiiCategory = "FrTaxIdentificationNumber"
	PiiCategoryFrValueAddedTaxNumber              PiiCategory = "FrValueAddedTaxNumber"
	PiiCategoryInternationalBankingAccountNumber  PiiCategory = "InternationalBankingAccountNumber"
	PiiCategoryNzBankAccountNumber                PiiCategory = "NzBankAccountNumber"
	PiiCategoryNzDriversLicenseNumber             PiiCategory = "NzDriversLicenseNumber"
	PiiCategoryNzInlandRevenueNumber              PiiCategory = "NzInlandRevenueNumber"
	PiiCategoryNzMinistryOfHealthNumber           PiiCategory = "NzMinistryOfHealthNumber"
	PiiCategoryNzSocialWelfareNumber              PiiCategory = "NzSocialWelfareNumber"
	PiiCategoryUkDriversLicenseNumber             PiiCategory = "UkDriversLicenseNumber"
	PiiCategoryUkElectoralRollNumber              PiiCategory = "UkElectoralRollNumber"
	PiiCategoryUkNationalHealthNumber             PiiCategory = "UkNationalHealthNumber"
	PiiCategoryUkNationalInsuranceNumber          PiiCategory = "UkNationalInsuranceNumber"
	PiiCategoryUkUniqueTaxpayerNumber             PiiCategory = "UkUniqueTaxpayerNumber"
)

func NewPiiCategoryFromString(s string) (PiiCategory, error) {
	switch s {
	case "Name":
		return PiiCategoryName, nil
	case "Email":
		return PiiCategoryEmail, nil
	case "PhoneNumber":
		return PiiCategoryPhoneNumber, nil
	case "StreetAddress":
		return PiiCategoryStreetAddress, nil
	case "CreditCardNumber":
		return PiiCategoryCreditCardNumber, nil
	case "UsBankAccountNumber":
		return PiiCategoryUsBankAccountNumber, nil
	case "UsSocialSecurityNumber":
		return PiiCategoryUsSocialSecurityNumber, nil
	case "UsUkPassportNumber":
		return PiiCategoryUsUkPassportNumber, nil
	case "UsDriversLicenseNumber":
		return PiiCategoryUsDriversLicenseNumber, nil
	case "UsIndividualTaxpayerIdentification":
		return PiiCategoryUsIndividualTaxpayerIdentification, nil
	case "Date":
		return PiiCategoryDate, nil
	case "IpAddress":
		return PiiCategoryIPAddress, nil
	case "Url":
		return PiiCategoryURL, nil
	case "AbaRoutingNumber":
		return PiiCategoryAbaRoutingNumber, nil
	case "Age":
		return PiiCategoryAge, nil
	case "SwiftCode":
		return PiiCategorySwiftCode, nil
	case "AuBankAccountNumber":
		return PiiCategoryAuBankAccountNumber, nil
	case "AuBusinessNumber":
		return PiiCategoryAuBusinessNumber, nil
	case "AuCompanyNumber":
		return PiiCategoryAuCompanyNumber, nil
	case "AuDriversLicenseNumber":
		return PiiCategoryAuDriversLicenseNumber, nil
	case "AuMedicalAccountNumber":
		return PiiCategoryAuMedicalAccountNumber, nil
	case "AuPassportNumber":
		return PiiCategoryAuPassportNumber, nil
	case "AuTaxFileNumber":
		return PiiCategoryAuTaxFileNumber, nil
	case "CaBankAccountNumber":
		return PiiCategoryCaBankAccountNumber, nil
	case "CaDriversLicenseNumber":
		return PiiCategoryCaDriversLicenseNumber, nil
	case "CaHealthServiceNumber":
		return PiiCategoryCaHealthServiceNumber, nil
	case "CaPassportNumber":
		return PiiCategoryCaPassportNumber, nil
	case "CaPersonalHealthIdentification":
		return PiiCategoryCaPersonalHealthIdentification, nil
	case "CaSocialInsuranceNumber":
		return PiiCategoryCaSocialInsuranceNumber, nil
	case "EsDni":
		return PiiCategoryEsDni, nil
	case "EsSocialSecurityNumber":
		return PiiCategoryEsSocialSecurityNumber, nil
	case "EsTaxIdentificationNumber":
		return PiiCategoryEsTaxIdentificationNumber, nil
	case "EuDebitCardNumber":
		return PiiCategoryEuDebitCardNumber, nil
	case "EuDriversLicenseNumber":
		return PiiCategoryEuDriversLicenseNumber, nil
	case "EuGpsCoordinates":
		return PiiCategoryEuGpsCoordinates, nil
	case "EuNationalIdentificationNumber":
		return PiiCategoryEuNationalIdentificationNumber, nil
	case "EuPassportNumber":
		return PiiCategoryEuPassportNumber, nil
	case "EuSocialSecurityNumber":
		return PiiCategoryEuSocialSecurityNumber, nil
	case "EuTaxIdentificationNumber":
		return PiiCategoryEuTaxIdentificationNumber, nil
	case "FrDriversLicenseNumber":
		return PiiCategoryFrDriversLicenseNumber, nil
	case "FrHealthInsuranceNumber":
		return PiiCategoryFrHealthInsuranceNumber, nil
	case "FrNationalId":
		return PiiCategoryFrNationalID, nil
	case "FrPassportNumber":
		return PiiCategoryFrPassportNumber, nil
	case "FrSocialSecurityNumber":
		return PiiCategoryFrSocialSecurityNumber, nil
	case "FrTaxIdentificationNumber":
		return PiiCategoryFrTaxIdentificationNumber, nil
	case "FrValueAddedTaxNumber":
		return PiiCategoryFrValueAddedTaxNumber, nil
	case "InternationalBankingAccountNumber":
		return PiiCategoryInternationalBankingAccountNumber, nil
	case "NzBankAccountNumber":
		return PiiCategoryNzBankAccountNumber, nil
	case "NzDriversLicenseNumber":
		return PiiCategoryNzDriversLicenseNumber, nil
	case "NzInlandRevenueNumber":
		return PiiCategoryNzInlandRevenueNumber, nil
	case "NzMinistryOfHealthNumber":
		return PiiCategoryNzMinistryOfHealthNumber, nil
	case "NzSocialWelfareNumber":
		return PiiCategoryNzSocialWelfareNumber, nil
	case "UkDriversLicenseNumber":
		return PiiCategoryUkDriversLicenseNumber, nil
	case "UkElectoralRollNumber":
		return PiiCategoryUkElectoralRollNumber, nil
	case "UkNationalHealthNumber":
		return PiiCategoryUkNationalHealthNumber, nil
	case "UkNationalInsuranceNumber":
		return PiiCategoryUkNationalInsuranceNumber, nil
	case "UkUniqueTaxpayerNumber":
		return PiiCategoryUkUniqueTaxpayerNumber, nil
	}
	var t PiiCategory
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PiiCategory) Ptr() *PiiCategory {
	return &p
}

type Precondition struct {
	PreconditionType string
	User             *MetadataPrecondition
	Conversation     *ConversationPrecondition
	Group            *PreconditionGroup
}

func (p *Precondition) GetPreconditionType() string {
	if p == nil {
		return ""
	}
	return p.PreconditionType
}

func (p *Precondition) GetUser() *MetadataPrecondition {
	if p == nil {
		return nil
	}
	return p.User
}

func (p *Precondition) GetConversation() *ConversationPrecondition {
	if p == nil {
		return nil
	}
	return p.Conversation
}

func (p *Precondition) GetGroup() *PreconditionGroup {
	if p == nil {
		return nil
	}
	return p.Group
}

func (p *Precondition) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		PreconditionType string `json:"preconditionType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.PreconditionType = unmarshaler.PreconditionType
	if unmarshaler.PreconditionType == "" {
		return fmt.Errorf("%T did not include discriminant preconditionType", p)
	}
	switch unmarshaler.PreconditionType {
	case "user":
		value := new(MetadataPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.User = value
	case "conversation":
		var valueUnmarshaler struct {
			Conversation *ConversationPrecondition `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		p.Conversation = valueUnmarshaler.Conversation
	case "group":
		value := new(PreconditionGroup)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Group = value
	}
	return nil
}

func (p Precondition) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.User != nil {
		return internal.MarshalJSONWithExtraProperty(p.User, "preconditionType", "user")
	}
	if p.Conversation != nil {
		var marshaler = struct {
			PreconditionType string                    `json:"preconditionType"`
			Conversation     *ConversationPrecondition `json:"value"`
		}{
			PreconditionType: "conversation",
			Conversation:     p.Conversation,
		}
		return json.Marshal(marshaler)
	}
	if p.Group != nil {
		return internal.MarshalJSONWithExtraProperty(p.Group, "preconditionType", "group")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PreconditionVisitor interface {
	VisitUser(*MetadataPrecondition) error
	VisitConversation(*ConversationPrecondition) error
	VisitGroup(*PreconditionGroup) error
}

func (p *Precondition) Accept(visitor PreconditionVisitor) error {
	if p.User != nil {
		return visitor.VisitUser(p.User)
	}
	if p.Conversation != nil {
		return visitor.VisitConversation(p.Conversation)
	}
	if p.Group != nil {
		return visitor.VisitGroup(p.Group)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *Precondition) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.User != nil {
		fields = append(fields, "user")
	}
	if p.Conversation != nil {
		fields = append(fields, "conversation")
	}
	if p.Group != nil {
		fields = append(fields, "group")
	}
	if len(fields) == 0 {
		if p.PreconditionType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.PreconditionType)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.PreconditionType != "" {
		field := fields[0]
		if p.PreconditionType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.PreconditionType,
				p,
			)
		}
	}
	return nil
}

var (
	preconditionBaseFieldOperator = big.NewInt(1 << 0)
)

type PreconditionBase struct {
	// Operator to apply to this precondition
	Operator *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PreconditionBase) GetOperator() *PreconditionOperator {
	if p == nil {
		return nil
	}
	return p.Operator
}

func (p *PreconditionBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PreconditionBase) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PreconditionBase) SetOperator(operator *PreconditionOperator) {
	p.Operator = operator
	p.require(preconditionBaseFieldOperator)
}

func (p *PreconditionBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PreconditionBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PreconditionBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PreconditionBase) MarshalJSON() ([]byte, error) {
	type embed PreconditionBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PreconditionBase) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	preconditionGroupFieldOperator      = big.NewInt(1 << 0)
	preconditionGroupFieldPreconditions = big.NewInt(1 << 1)
)

type PreconditionGroup struct {
	Operator      PreconditionGroupOperator `json:"operator" url:"operator"`
	Preconditions []*Precondition           `json:"preconditions" url:"preconditions"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PreconditionGroup) GetOperator() PreconditionGroupOperator {
	if p == nil {
		return ""
	}
	return p.Operator
}

func (p *PreconditionGroup) GetPreconditions() []*Precondition {
	if p == nil {
		return nil
	}
	return p.Preconditions
}

func (p *PreconditionGroup) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PreconditionGroup) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PreconditionGroup) SetOperator(operator PreconditionGroupOperator) {
	p.Operator = operator
	p.require(preconditionGroupFieldOperator)
}

// SetPreconditions sets the Preconditions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PreconditionGroup) SetPreconditions(preconditions []*Precondition) {
	p.Preconditions = preconditions
	p.require(preconditionGroupFieldPreconditions)
}

func (p *PreconditionGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler PreconditionGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PreconditionGroup(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PreconditionGroup) MarshalJSON() ([]byte, error) {
	type embed PreconditionGroup
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PreconditionGroup) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PreconditionGroupOperator string

const (
	PreconditionGroupOperatorAnd PreconditionGroupOperator = "AND"
	PreconditionGroupOperatorOr  PreconditionGroupOperator = "OR"
)

func NewPreconditionGroupOperatorFromString(s string) (PreconditionGroupOperator, error) {
	switch s {
	case "AND":
		return PreconditionGroupOperatorAnd, nil
	case "OR":
		return PreconditionGroupOperatorOr, nil
	}
	var t PreconditionGroupOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PreconditionGroupOperator) Ptr() *PreconditionGroupOperator {
	return &p
}

type PreconditionOperator string

const (
	// Negation operator (can compose with any comparison operator)
	PreconditionOperatorNot PreconditionOperator = "NOT"
	// Single value - check if value is in JSON array (x  array)
	PreconditionOperatorContains PreconditionOperator = "CONTAINS"
	// Single value - check if value is NOT in JSON array (x  array)
	PreconditionOperatorNotContains PreconditionOperator = "NOT_CONTAINS"
	// Multiple values - check if ANY value is in JSON array ({x,y}  array  )
	PreconditionOperatorContainsAny PreconditionOperator = "CONTAINS_ANY"
	// Multiple values - check if NO values are in JSON array ({x,y}  array = )
	PreconditionOperatorNotContainsAny PreconditionOperator = "NOT_CONTAINS_ANY"
	// Multiple values - check if ALL values are in JSON array ({x,y}  array)
	PreconditionOperatorContainsAll PreconditionOperator = "CONTAINS_ALL"
	// Multiple values - check if NOT ALL values are in JSON array ({x,y}  array)
	PreconditionOperatorNotContainsAll PreconditionOperator = "NOT_CONTAINS_ALL"
)

func NewPreconditionOperatorFromString(s string) (PreconditionOperator, error) {
	switch s {
	case "NOT":
		return PreconditionOperatorNot, nil
	case "CONTAINS":
		return PreconditionOperatorContains, nil
	case "NOT_CONTAINS":
		return PreconditionOperatorNotContains, nil
	case "CONTAINS_ANY":
		return PreconditionOperatorContainsAny, nil
	case "NOT_CONTAINS_ANY":
		return PreconditionOperatorNotContainsAny, nil
	case "CONTAINS_ALL":
		return PreconditionOperatorContainsAll, nil
	case "NOT_CONTAINS_ALL":
		return PreconditionOperatorNotContainsAll, nil
	}
	var t PreconditionOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PreconditionOperator) Ptr() *PreconditionOperator {
	return &p
}

type Quality string

const (
	QualityGood             Quality = "GOOD"
	QualityNeedsImprovement Quality = "NEEDS_IMPROVEMENT"
	QualityUnknown          Quality = "UNKNOWN"
)

func NewQualityFromString(s string) (Quality, error) {
	switch s {
	case "GOOD":
		return QualityGood, nil
	case "NEEDS_IMPROVEMENT":
		return QualityNeedsImprovement, nil
	case "UNKNOWN":
		return QualityUnknown, nil
	}
	var t Quality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q Quality) Ptr() *Quality {
	return &q
}

type QualityReason string

const (
	QualityReasonMissingKnowledge        QualityReason = "MISSING_KNOWLEDGE"
	QualityReasonMissingUserInformation  QualityReason = "MISSING_USER_INFORMATION"
	QualityReasonMissingAction           QualityReason = "MISSING_ACTION"
	QualityReasonNeedsUserClarification  QualityReason = "NEEDS_USER_CLARIFICATION"
	QualityReasonUnsupportedFormat       QualityReason = "UNSUPPORTED_FORMAT"
	QualityReasonInterrupted             QualityReason = "INTERRUPTED"
	QualityReasonUnsupportedUserBehavior QualityReason = "UNSUPPORTED_USER_BEHAVIOR"
	QualityReasonUnknown                 QualityReason = "UNKNOWN"
	QualityReasonNoBotReplies            QualityReason = "NO_BOT_REPLIES"
)

func NewQualityReasonFromString(s string) (QualityReason, error) {
	switch s {
	case "MISSING_KNOWLEDGE":
		return QualityReasonMissingKnowledge, nil
	case "MISSING_USER_INFORMATION":
		return QualityReasonMissingUserInformation, nil
	case "MISSING_ACTION":
		return QualityReasonMissingAction, nil
	case "NEEDS_USER_CLARIFICATION":
		return QualityReasonNeedsUserClarification, nil
	case "UNSUPPORTED_FORMAT":
		return QualityReasonUnsupportedFormat, nil
	case "INTERRUPTED":
		return QualityReasonInterrupted, nil
	case "UNSUPPORTED_USER_BEHAVIOR":
		return QualityReasonUnsupportedUserBehavior, nil
	case "UNKNOWN":
		return QualityReasonUnknown, nil
	case "NO_BOT_REPLIES":
		return QualityReasonNoBotReplies, nil
	}
	var t QualityReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QualityReason) Ptr() *QualityReason {
	return &q
}

var (
	responseConfigFieldCapabilities   = big.NewInt(1 << 0)
	responseConfigFieldIsCopilot      = big.NewInt(1 << 1)
	responseConfigFieldResponseLength = big.NewInt(1 << 2)
	responseConfigFieldContextFilter  = big.NewInt(1 << 3)
)

type ResponseConfig struct {
	// List of capabilities supported by the caller. Defaults to `[MARKDOWN, FORMS, IMAGES]`.
	//
	// - `MARKDOWN`: Whether the response should include markdown formatting. If not provided, the response will be plain text. Not respected while streaming.
	// - `FORMS`: Whether the response should include forms. If provided, the caller needs to render action forms when returned from the ask API and allow submission of the forms with the submitActionForm API. If not provided, then actions which require user interaction will not be considered by the LLM. Removing this capability is recommended for surfaces which can not display UI (e.g. SMS, voice).
	// - `IMAGES`: Whether the response should include images. Not yet supported.
	// - `CHARTS_HIGHCHARTS_TS`: Whether the response should include a Highcharts typescript chart if applicable.
	// - `ASYNC`: Whether the app that created this conversation supports asynchronous message delivery. If provided, messages may be sent to the app via the `handleMessage` function.
	// - `OAUTH_BUTTONS`: Whether the response should include OAuth buttons. If provided, the caller needs to render OAuth buttons when returned from the ask API and allow the user to click the buttons to initiate the OAuth flow. If not provided, then actions which require OAuth authorization will not be considered by the LLM. This capability is not recommended for surfaces which can not display links (e.g. voice).
	Capabilities []Capability `json:"capabilities" url:"capabilities"`
	// Whether the response is for an human agent (true) or an end user (false). Defaults to false.
	IsCopilot bool `json:"isCopilot" url:"isCopilot"`
	// The desired response length. Defaults to ResponseLength.MEDIUM.
	ResponseLength ResponseLength `json:"responseLength" url:"responseLength"`
	// Filters that restrict the knowledge retrieval candidate pool.
	// - entities: specific entities to scope by
	// - entityTypes: entity types to scope by (e.g., AGENT, CUSTOMER)
	ContextFilter *KnowledgeContextFilter `json:"contextFilter,omitempty" url:"contextFilter,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseConfig) GetCapabilities() []Capability {
	if r == nil {
		return nil
	}
	return r.Capabilities
}

func (r *ResponseConfig) GetIsCopilot() bool {
	if r == nil {
		return false
	}
	return r.IsCopilot
}

func (r *ResponseConfig) GetResponseLength() ResponseLength {
	if r == nil {
		return ""
	}
	return r.ResponseLength
}

func (r *ResponseConfig) GetContextFilter() *KnowledgeContextFilter {
	if r == nil {
		return nil
	}
	return r.ContextFilter
}

func (r *ResponseConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseConfig) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetCapabilities sets the Capabilities field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfig) SetCapabilities(capabilities []Capability) {
	r.Capabilities = capabilities
	r.require(responseConfigFieldCapabilities)
}

// SetIsCopilot sets the IsCopilot field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfig) SetIsCopilot(isCopilot bool) {
	r.IsCopilot = isCopilot
	r.require(responseConfigFieldIsCopilot)
}

// SetResponseLength sets the ResponseLength field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfig) SetResponseLength(responseLength ResponseLength) {
	r.ResponseLength = responseLength
	r.require(responseConfigFieldResponseLength)
}

// SetContextFilter sets the ContextFilter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfig) SetContextFilter(contextFilter *KnowledgeContextFilter) {
	r.ContextFilter = contextFilter
	r.require(responseConfigFieldContextFilter)
}

func (r *ResponseConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseConfig) MarshalJSON() ([]byte, error) {
	type embed ResponseConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseConfig) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseConfigPreconditionFieldOperator       = big.NewInt(1 << 0)
	responseConfigPreconditionFieldUseMarkdown    = big.NewInt(1 << 1)
	responseConfigPreconditionFieldUseForms       = big.NewInt(1 << 2)
	responseConfigPreconditionFieldUseImages      = big.NewInt(1 << 3)
	responseConfigPreconditionFieldIsCopilot      = big.NewInt(1 << 4)
	responseConfigPreconditionFieldResponseLength = big.NewInt(1 << 5)
)

type ResponseConfigPrecondition struct {
	// Operator to apply to this precondition
	Operator       *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`
	UseMarkdown    *bool                 `json:"useMarkdown,omitempty" url:"useMarkdown,omitempty"`
	UseForms       *bool                 `json:"useForms,omitempty" url:"useForms,omitempty"`
	UseImages      *bool                 `json:"useImages,omitempty" url:"useImages,omitempty"`
	IsCopilot      *bool                 `json:"isCopilot,omitempty" url:"isCopilot,omitempty"`
	ResponseLength *ResponseLength       `json:"responseLength,omitempty" url:"responseLength,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseConfigPrecondition) GetOperator() *PreconditionOperator {
	if r == nil {
		return nil
	}
	return r.Operator
}

func (r *ResponseConfigPrecondition) GetUseMarkdown() *bool {
	if r == nil {
		return nil
	}
	return r.UseMarkdown
}

func (r *ResponseConfigPrecondition) GetUseForms() *bool {
	if r == nil {
		return nil
	}
	return r.UseForms
}

func (r *ResponseConfigPrecondition) GetUseImages() *bool {
	if r == nil {
		return nil
	}
	return r.UseImages
}

func (r *ResponseConfigPrecondition) GetIsCopilot() *bool {
	if r == nil {
		return nil
	}
	return r.IsCopilot
}

func (r *ResponseConfigPrecondition) GetResponseLength() *ResponseLength {
	if r == nil {
		return nil
	}
	return r.ResponseLength
}

func (r *ResponseConfigPrecondition) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseConfigPrecondition) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetOperator(operator *PreconditionOperator) {
	r.Operator = operator
	r.require(responseConfigPreconditionFieldOperator)
}

// SetUseMarkdown sets the UseMarkdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetUseMarkdown(useMarkdown *bool) {
	r.UseMarkdown = useMarkdown
	r.require(responseConfigPreconditionFieldUseMarkdown)
}

// SetUseForms sets the UseForms field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetUseForms(useForms *bool) {
	r.UseForms = useForms
	r.require(responseConfigPreconditionFieldUseForms)
}

// SetUseImages sets the UseImages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetUseImages(useImages *bool) {
	r.UseImages = useImages
	r.require(responseConfigPreconditionFieldUseImages)
}

// SetIsCopilot sets the IsCopilot field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetIsCopilot(isCopilot *bool) {
	r.IsCopilot = isCopilot
	r.require(responseConfigPreconditionFieldIsCopilot)
}

// SetResponseLength sets the ResponseLength field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetResponseLength(responseLength *ResponseLength) {
	r.ResponseLength = responseLength
	r.require(responseConfigPreconditionFieldResponseLength)
}

func (r *ResponseConfigPrecondition) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseConfigPrecondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseConfigPrecondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseConfigPrecondition) MarshalJSON() ([]byte, error) {
	type embed ResponseConfigPrecondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseConfigPrecondition) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseLength string

const (
	ResponseLengthShort  ResponseLength = "SHORT"
	ResponseLengthMedium ResponseLength = "MEDIUM"
	ResponseLengthLong   ResponseLength = "LONG"
)

func NewResponseLengthFromString(s string) (ResponseLength, error) {
	switch s {
	case "SHORT":
		return ResponseLengthShort, nil
	case "MEDIUM":
		return ResponseLengthMedium, nil
	case "LONG":
		return ResponseLengthLong, nil
	}
	var t ResponseLength
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseLength) Ptr() *ResponseLength {
	return &r
}

var (
	safetyCheckReportFieldAttackDetected         = big.NewInt(1 << 0)
	safetyCheckReportFieldHarmfulContentDetected = big.NewInt(1 << 1)
	safetyCheckReportFieldHarmfulContentAnalysis = big.NewInt(1 << 2)
)

type SafetyCheckReport struct {
	// Whether the check detected a malicious attack.
	AttackDetected bool `json:"attackDetected" url:"attackDetected"`
	// Whether the check detected harmful content such as hate speech, references to self-harm, violence or sexual references.
	HarmfulContentDetected bool `json:"harmfulContentDetected" url:"harmfulContentDetected"`
	// Includes details on each category of harmful content.
	HarmfulContentAnalysis []*HarmfulContentAnalysis `json:"harmfulContentAnalysis" url:"harmfulContentAnalysis"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SafetyCheckReport) GetAttackDetected() bool {
	if s == nil {
		return false
	}
	return s.AttackDetected
}

func (s *SafetyCheckReport) GetHarmfulContentDetected() bool {
	if s == nil {
		return false
	}
	return s.HarmfulContentDetected
}

func (s *SafetyCheckReport) GetHarmfulContentAnalysis() []*HarmfulContentAnalysis {
	if s == nil {
		return nil
	}
	return s.HarmfulContentAnalysis
}

func (s *SafetyCheckReport) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SafetyCheckReport) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetAttackDetected sets the AttackDetected field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SafetyCheckReport) SetAttackDetected(attackDetected bool) {
	s.AttackDetected = attackDetected
	s.require(safetyCheckReportFieldAttackDetected)
}

// SetHarmfulContentDetected sets the HarmfulContentDetected field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SafetyCheckReport) SetHarmfulContentDetected(harmfulContentDetected bool) {
	s.HarmfulContentDetected = harmfulContentDetected
	s.require(safetyCheckReportFieldHarmfulContentDetected)
}

// SetHarmfulContentAnalysis sets the HarmfulContentAnalysis field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SafetyCheckReport) SetHarmfulContentAnalysis(harmfulContentAnalysis []*HarmfulContentAnalysis) {
	s.HarmfulContentAnalysis = harmfulContentAnalysis
	s.require(safetyCheckReportFieldHarmfulContentAnalysis)
}

func (s *SafetyCheckReport) UnmarshalJSON(data []byte) error {
	type unmarshaler SafetyCheckReport
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SafetyCheckReport(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SafetyCheckReport) MarshalJSON() ([]byte, error) {
	type embed SafetyCheckReport
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SafetyCheckReport) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	scopedEntityFieldEntityID      = big.NewInt(1 << 0)
	scopedEntityFieldScopeEntityID = big.NewInt(1 << 1)
)

type ScopedEntity struct {
	EntityID      *EntityID `json:"entityId" url:"entityId"`
	ScopeEntityID *EntityID `json:"scopeEntityId,omitempty" url:"scopeEntityId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScopedEntity) GetEntityID() *EntityID {
	if s == nil {
		return nil
	}
	return s.EntityID
}

func (s *ScopedEntity) GetScopeEntityID() *EntityID {
	if s == nil {
		return nil
	}
	return s.ScopeEntityID
}

func (s *ScopedEntity) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScopedEntity) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetEntityID sets the EntityID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScopedEntity) SetEntityID(entityID *EntityID) {
	s.EntityID = entityID
	s.require(scopedEntityFieldEntityID)
}

// SetScopeEntityID sets the ScopeEntityID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScopedEntity) SetScopeEntityID(scopeEntityID *EntityID) {
	s.ScopeEntityID = scopeEntityID
	s.require(scopedEntityFieldScopeEntityID)
}

func (s *ScopedEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler ScopedEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScopedEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScopedEntity) MarshalJSON() ([]byte, error) {
	type embed ScopedEntity
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *ScopedEntity) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	sectionSettingsSchemaEntryFieldKey         = big.NewInt(1 << 0)
	sectionSettingsSchemaEntryFieldDisplayName = big.NewInt(1 << 1)
	sectionSettingsSchemaEntryFieldDescription = big.NewInt(1 << 2)
	sectionSettingsSchemaEntryFieldVisibility  = big.NewInt(1 << 3)
	sectionSettingsSchemaEntryFieldRequired    = big.NewInt(1 << 4)
	sectionSettingsSchemaEntryFieldFields      = big.NewInt(1 << 5)
)

type SectionSettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required *bool           `json:"required,omitempty" url:"required,omitempty"`
	Fields   *SettingsSchema `json:"fields,omitempty" url:"fields,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SectionSettingsSchemaEntry) GetKey() string {
	if s == nil {
		return ""
	}
	return s.Key
}

func (s *SectionSettingsSchemaEntry) GetDisplayName() string {
	if s == nil {
		return ""
	}
	return s.DisplayName
}

func (s *SectionSettingsSchemaEntry) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SectionSettingsSchemaEntry) GetVisibility() *VisibilityType {
	if s == nil {
		return nil
	}
	return s.Visibility
}

func (s *SectionSettingsSchemaEntry) GetRequired() *bool {
	if s == nil {
		return nil
	}
	return s.Required
}

func (s *SectionSettingsSchemaEntry) GetFields() *SettingsSchema {
	if s == nil {
		return nil
	}
	return s.Fields
}

func (s *SectionSettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SectionSettingsSchemaEntry) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SectionSettingsSchemaEntry) SetKey(key string) {
	s.Key = key
	s.require(sectionSettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SectionSettingsSchemaEntry) SetDisplayName(displayName string) {
	s.DisplayName = displayName
	s.require(sectionSettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SectionSettingsSchemaEntry) SetDescription(description *string) {
	s.Description = description
	s.require(sectionSettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SectionSettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	s.Visibility = visibility
	s.require(sectionSettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SectionSettingsSchemaEntry) SetRequired(required *bool) {
	s.Required = required
	s.require(sectionSettingsSchemaEntryFieldRequired)
}

// SetFields sets the Fields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SectionSettingsSchemaEntry) SetFields(fields *SettingsSchema) {
	s.Fields = fields
	s.require(sectionSettingsSchemaEntryFieldFields)
}

func (s *SectionSettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler SectionSettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SectionSettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SectionSettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed SectionSettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SectionSettingsSchemaEntry) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The sentiment of the conversation
type Sentiment string

const (
	SentimentPositive Sentiment = "POSITIVE"
	SentimentNegative Sentiment = "NEGATIVE"
	SentimentNeutral  Sentiment = "NEUTRAL"
	SentimentMixed    Sentiment = "MIXED"
	SentimentUnknown  Sentiment = "UNKNOWN"
)

func NewSentimentFromString(s string) (Sentiment, error) {
	switch s {
	case "POSITIVE":
		return SentimentPositive, nil
	case "NEGATIVE":
		return SentimentNegative, nil
	case "NEUTRAL":
		return SentimentNeutral, nil
	case "MIXED":
		return SentimentMixed, nil
	case "UNKNOWN":
		return SentimentUnknown, nil
	}
	var t Sentiment
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Sentiment) Ptr() *Sentiment {
	return &s
}

var (
	sessionInfoFieldID       = big.NewInt(1 << 0)
	sessionInfoFieldStart    = big.NewInt(1 << 1)
	sessionInfoFieldEnd      = big.NewInt(1 << 2)
	sessionInfoFieldDuration = big.NewInt(1 << 3)
)

type SessionInfo struct {
	ID       string     `json:"id" url:"id"`
	Start    *time.Time `json:"start,omitempty" url:"start,omitempty"`
	End      *time.Time `json:"end,omitempty" url:"end,omitempty"`
	Duration *int64     `json:"duration,omitempty" url:"duration,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SessionInfo) GetID() string {
	if s == nil {
		return ""
	}
	return s.ID
}

func (s *SessionInfo) GetStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.Start
}

func (s *SessionInfo) GetEnd() *time.Time {
	if s == nil {
		return nil
	}
	return s.End
}

func (s *SessionInfo) GetDuration() *int64 {
	if s == nil {
		return nil
	}
	return s.Duration
}

func (s *SessionInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SessionInfo) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SessionInfo) SetID(id string) {
	s.ID = id
	s.require(sessionInfoFieldID)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SessionInfo) SetStart(start *time.Time) {
	s.Start = start
	s.require(sessionInfoFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SessionInfo) SetEnd(end *time.Time) {
	s.End = end
	s.require(sessionInfoFieldEnd)
}

// SetDuration sets the Duration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SessionInfo) SetDuration(duration *int64) {
	s.Duration = duration
	s.require(sessionInfoFieldDuration)
}

func (s *SessionInfo) UnmarshalJSON(data []byte) error {
	type embed SessionInfo
	var unmarshaler = struct {
		embed
		Start *internal.DateTime `json:"start,omitempty"`
		End   *internal.DateTime `json:"end,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SessionInfo(unmarshaler.embed)
	s.Start = unmarshaler.Start.TimePtr()
	s.End = unmarshaler.End.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SessionInfo) MarshalJSON() ([]byte, error) {
	type embed SessionInfo
	var marshaler = struct {
		embed
		Start *internal.DateTime `json:"start,omitempty"`
		End   *internal.DateTime `json:"end,omitempty"`
	}{
		embed: embed(*s),
		Start: internal.NewOptionalDateTime(s.Start),
		End:   internal.NewOptionalDateTime(s.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SessionInfo) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Condition for set values (e.g., MULTI_SELECT fields)
type SetCondition struct {
	OpType   string
	Element  *SetElementCondition
	Relation *SetRelationCondition
}

func (s *SetCondition) GetOpType() string {
	if s == nil {
		return ""
	}
	return s.OpType
}

func (s *SetCondition) GetElement() *SetElementCondition {
	if s == nil {
		return nil
	}
	return s.Element
}

func (s *SetCondition) GetRelation() *SetRelationCondition {
	if s == nil {
		return nil
	}
	return s.Relation
}

func (s *SetCondition) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		OpType string `json:"opType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.OpType = unmarshaler.OpType
	if unmarshaler.OpType == "" {
		return fmt.Errorf("%T did not include discriminant opType", s)
	}
	switch unmarshaler.OpType {
	case "element":
		value := new(SetElementCondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Element = value
	case "relation":
		value := new(SetRelationCondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Relation = value
	}
	return nil
}

func (s SetCondition) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Element != nil {
		return internal.MarshalJSONWithExtraProperty(s.Element, "opType", "element")
	}
	if s.Relation != nil {
		return internal.MarshalJSONWithExtraProperty(s.Relation, "opType", "relation")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SetConditionVisitor interface {
	VisitElement(*SetElementCondition) error
	VisitRelation(*SetRelationCondition) error
}

func (s *SetCondition) Accept(visitor SetConditionVisitor) error {
	if s.Element != nil {
		return visitor.VisitElement(s.Element)
	}
	if s.Relation != nil {
		return visitor.VisitRelation(s.Relation)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SetCondition) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Element != nil {
		fields = append(fields, "element")
	}
	if s.Relation != nil {
		fields = append(fields, "relation")
	}
	if len(fields) == 0 {
		if s.OpType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.OpType)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.OpType != "" {
		field := fields[0]
		if s.OpType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.OpType,
				s,
			)
		}
	}
	return nil
}

// Condition checking if set contains a single element
var (
	setElementConditionFieldOperator = big.NewInt(1 << 0)
	setElementConditionFieldValue    = big.NewInt(1 << 1)
)

type SetElementCondition struct {
	// The comparison operator to apply
	Operator SetElementOperator `json:"operator" url:"operator"`
	// The value to check for
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SetElementCondition) GetOperator() SetElementOperator {
	if s == nil {
		return ""
	}
	return s.Operator
}

func (s *SetElementCondition) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

func (s *SetElementCondition) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SetElementCondition) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SetElementCondition) SetOperator(operator SetElementOperator) {
	s.Operator = operator
	s.require(setElementConditionFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SetElementCondition) SetValue(value string) {
	s.Value = value
	s.require(setElementConditionFieldValue)
}

func (s *SetElementCondition) UnmarshalJSON(data []byte) error {
	type unmarshaler SetElementCondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SetElementCondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SetElementCondition) MarshalJSON() ([]byte, error) {
	type embed SetElementCondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SetElementCondition) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Operators for checking single element in a set
type SetElementOperator string

const (
	// Set contains the value ()
	SetElementOperatorContains SetElementOperator = "CONTAINS"
	// Set does not contain the value ()
	SetElementOperatorNotContains SetElementOperator = "NOT_CONTAINS"
)

func NewSetElementOperatorFromString(s string) (SetElementOperator, error) {
	switch s {
	case "CONTAINS":
		return SetElementOperatorContains, nil
	case "NOT_CONTAINS":
		return SetElementOperatorNotContains, nil
	}
	var t SetElementOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SetElementOperator) Ptr() *SetElementOperator {
	return &s
}

// Condition comparing set against another set of values
var (
	setRelationConditionFieldOperator = big.NewInt(1 << 0)
	setRelationConditionFieldValues   = big.NewInt(1 << 1)
)

type SetRelationCondition struct {
	// The comparison operator to apply
	Operator SetRelationOperator `json:"operator" url:"operator"`
	// The (unordered) set of values to compare against
	Values []string `json:"values" url:"values"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SetRelationCondition) GetOperator() SetRelationOperator {
	if s == nil {
		return ""
	}
	return s.Operator
}

func (s *SetRelationCondition) GetValues() []string {
	if s == nil {
		return nil
	}
	return s.Values
}

func (s *SetRelationCondition) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SetRelationCondition) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SetRelationCondition) SetOperator(operator SetRelationOperator) {
	s.Operator = operator
	s.require(setRelationConditionFieldOperator)
}

// SetValues sets the Values field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SetRelationCondition) SetValues(values []string) {
	s.Values = values
	s.require(setRelationConditionFieldValues)
}

func (s *SetRelationCondition) UnmarshalJSON(data []byte) error {
	type unmarshaler SetRelationCondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SetRelationCondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SetRelationCondition) MarshalJSON() ([]byte, error) {
	type embed SetRelationCondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SetRelationCondition) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Operators for set relation operations
type SetRelationOperator string

const (
	// Set equals the specified set (=)
	SetRelationOperatorEq SetRelationOperator = "EQ"
	// Set does not equal the specified set ()
	SetRelationOperatorNeq SetRelationOperator = "NEQ"
	// Set contains any of the values (A  B  )
	SetRelationOperatorContainsAny SetRelationOperator = "CONTAINS_ANY"
	// Set contains none of the values (A  B = ), i.e., negation of CONTAINS_ANY
	SetRelationOperatorContainsNone SetRelationOperator = "CONTAINS_NONE"
	// Set contains all of the values (A  B)
	SetRelationOperatorContainsAll SetRelationOperator = "CONTAINS_ALL"
	// Set does not contain all of the values (A  B)
	SetRelationOperatorNotContainsAll SetRelationOperator = "NOT_CONTAINS_ALL"
	// Set is a subset of the values (A  B)
	SetRelationOperatorSubsetOf SetRelationOperator = "SUBSET_OF"
	// Set is not a subset of the values (A  B)
	SetRelationOperatorNotSubsetOf SetRelationOperator = "NOT_SUBSET_OF"
)

func NewSetRelationOperatorFromString(s string) (SetRelationOperator, error) {
	switch s {
	case "EQ":
		return SetRelationOperatorEq, nil
	case "NEQ":
		return SetRelationOperatorNeq, nil
	case "CONTAINS_ANY":
		return SetRelationOperatorContainsAny, nil
	case "CONTAINS_NONE":
		return SetRelationOperatorContainsNone, nil
	case "CONTAINS_ALL":
		return SetRelationOperatorContainsAll, nil
	case "NOT_CONTAINS_ALL":
		return SetRelationOperatorNotContainsAll, nil
	case "SUBSET_OF":
		return SetRelationOperatorSubsetOf, nil
	case "NOT_SUBSET_OF":
		return SetRelationOperatorNotSubsetOf, nil
	}
	var t SetRelationOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SetRelationOperator) Ptr() *SetRelationOperator {
	return &s
}

type SettingsSchema = []*SettingsSchemaEntry

var (
	settingsSchemaDiscriminatedUnionOptionFieldValue       = big.NewInt(1 << 0)
	settingsSchemaDiscriminatedUnionOptionFieldDisplayName = big.NewInt(1 << 1)
	settingsSchemaDiscriminatedUnionOptionFieldDescription = big.NewInt(1 << 2)
	settingsSchemaDiscriminatedUnionOptionFieldFields      = big.NewInt(1 << 3)
)

type SettingsSchemaDiscriminatedUnionOption struct {
	// The value for this option (used as discriminator value)
	Value string `json:"value" url:"value"`
	// The display name shown in the dropdown
	DisplayName string `json:"displayName" url:"displayName"`
	// Optional description for this option
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The schema fields to display when this option is selected. Required fields within these fields are only validated when this option is active.
	Fields SettingsSchema `json:"fields" url:"fields"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SettingsSchemaDiscriminatedUnionOption) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

func (s *SettingsSchemaDiscriminatedUnionOption) GetDisplayName() string {
	if s == nil {
		return ""
	}
	return s.DisplayName
}

func (s *SettingsSchemaDiscriminatedUnionOption) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SettingsSchemaDiscriminatedUnionOption) GetFields() SettingsSchema {
	if s == nil {
		return nil
	}
	return s.Fields
}

func (s *SettingsSchemaDiscriminatedUnionOption) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SettingsSchemaDiscriminatedUnionOption) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettingsSchemaDiscriminatedUnionOption) SetValue(value string) {
	s.Value = value
	s.require(settingsSchemaDiscriminatedUnionOptionFieldValue)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettingsSchemaDiscriminatedUnionOption) SetDisplayName(displayName string) {
	s.DisplayName = displayName
	s.require(settingsSchemaDiscriminatedUnionOptionFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettingsSchemaDiscriminatedUnionOption) SetDescription(description *string) {
	s.Description = description
	s.require(settingsSchemaDiscriminatedUnionOptionFieldDescription)
}

// SetFields sets the Fields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettingsSchemaDiscriminatedUnionOption) SetFields(fields SettingsSchema) {
	s.Fields = fields
	s.require(settingsSchemaDiscriminatedUnionOptionFieldFields)
}

func (s *SettingsSchemaDiscriminatedUnionOption) UnmarshalJSON(data []byte) error {
	type unmarshaler SettingsSchemaDiscriminatedUnionOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SettingsSchemaDiscriminatedUnionOption(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SettingsSchemaDiscriminatedUnionOption) MarshalJSON() ([]byte, error) {
	type embed SettingsSchemaDiscriminatedUnionOption
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SettingsSchemaDiscriminatedUnionOption) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Array of options for a discriminated union field
type SettingsSchemaDiscriminatedUnionOptions = []*SettingsSchemaDiscriminatedUnionOption

type SettingsSchemaEntry struct {
	Type         string
	Text         *TextSettingsSchemaEntry
	Multiline    *MultilineSettingsSchemaEntry
	Array        *ArraySettingsSchemaEntry
	Complexarray *ComplexArraySettingsSchemaEntry
	Color        *ColorSettingsSchemaEntry
	Image        *ImageSettingsSchemaEntry
	Checkbox     *CheckboxSettingsSchemaEntry
	Dropdown     *DropdownSettingsSchemaEntry
	Section      *SectionSettingsSchemaEntry
	Oauth        *OAuthSettingsSchemaEntry
	Number       *NumberSettingsSchemaEntry
	OneOf        *OneOfSettingsSchemaEntry
}

func (s *SettingsSchemaEntry) GetType() string {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SettingsSchemaEntry) GetText() *TextSettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.Text
}

func (s *SettingsSchemaEntry) GetMultiline() *MultilineSettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.Multiline
}

func (s *SettingsSchemaEntry) GetArray() *ArraySettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.Array
}

func (s *SettingsSchemaEntry) GetComplexarray() *ComplexArraySettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.Complexarray
}

func (s *SettingsSchemaEntry) GetColor() *ColorSettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.Color
}

func (s *SettingsSchemaEntry) GetImage() *ImageSettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.Image
}

func (s *SettingsSchemaEntry) GetCheckbox() *CheckboxSettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.Checkbox
}

func (s *SettingsSchemaEntry) GetDropdown() *DropdownSettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.Dropdown
}

func (s *SettingsSchemaEntry) GetSection() *SectionSettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.Section
}

func (s *SettingsSchemaEntry) GetOauth() *OAuthSettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.Oauth
}

func (s *SettingsSchemaEntry) GetNumber() *NumberSettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.Number
}

func (s *SettingsSchemaEntry) GetOneOf() *OneOfSettingsSchemaEntry {
	if s == nil {
		return nil
	}
	return s.OneOf
}

func (s *SettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", s)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(TextSettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Text = value
	case "multiline":
		value := new(MultilineSettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Multiline = value
	case "array":
		value := new(ArraySettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Array = value
	case "complexarray":
		value := new(ComplexArraySettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Complexarray = value
	case "color":
		value := new(ColorSettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Color = value
	case "image":
		value := new(ImageSettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Image = value
	case "checkbox":
		value := new(CheckboxSettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Checkbox = value
	case "dropdown":
		value := new(DropdownSettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Dropdown = value
	case "section":
		value := new(SectionSettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Section = value
	case "oauth":
		value := new(OAuthSettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Oauth = value
	case "number":
		value := new(NumberSettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Number = value
	case "oneOf":
		value := new(OneOfSettingsSchemaEntry)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.OneOf = value
	}
	return nil
}

func (s SettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Text != nil {
		return internal.MarshalJSONWithExtraProperty(s.Text, "type", "text")
	}
	if s.Multiline != nil {
		return internal.MarshalJSONWithExtraProperty(s.Multiline, "type", "multiline")
	}
	if s.Array != nil {
		return internal.MarshalJSONWithExtraProperty(s.Array, "type", "array")
	}
	if s.Complexarray != nil {
		return internal.MarshalJSONWithExtraProperty(s.Complexarray, "type", "complexarray")
	}
	if s.Color != nil {
		return internal.MarshalJSONWithExtraProperty(s.Color, "type", "color")
	}
	if s.Image != nil {
		return internal.MarshalJSONWithExtraProperty(s.Image, "type", "image")
	}
	if s.Checkbox != nil {
		return internal.MarshalJSONWithExtraProperty(s.Checkbox, "type", "checkbox")
	}
	if s.Dropdown != nil {
		return internal.MarshalJSONWithExtraProperty(s.Dropdown, "type", "dropdown")
	}
	if s.Section != nil {
		return internal.MarshalJSONWithExtraProperty(s.Section, "type", "section")
	}
	if s.Oauth != nil {
		return internal.MarshalJSONWithExtraProperty(s.Oauth, "type", "oauth")
	}
	if s.Number != nil {
		return internal.MarshalJSONWithExtraProperty(s.Number, "type", "number")
	}
	if s.OneOf != nil {
		return internal.MarshalJSONWithExtraProperty(s.OneOf, "type", "oneOf")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type SettingsSchemaEntryVisitor interface {
	VisitText(*TextSettingsSchemaEntry) error
	VisitMultiline(*MultilineSettingsSchemaEntry) error
	VisitArray(*ArraySettingsSchemaEntry) error
	VisitComplexarray(*ComplexArraySettingsSchemaEntry) error
	VisitColor(*ColorSettingsSchemaEntry) error
	VisitImage(*ImageSettingsSchemaEntry) error
	VisitCheckbox(*CheckboxSettingsSchemaEntry) error
	VisitDropdown(*DropdownSettingsSchemaEntry) error
	VisitSection(*SectionSettingsSchemaEntry) error
	VisitOauth(*OAuthSettingsSchemaEntry) error
	VisitNumber(*NumberSettingsSchemaEntry) error
	VisitOneOf(*OneOfSettingsSchemaEntry) error
}

func (s *SettingsSchemaEntry) Accept(visitor SettingsSchemaEntryVisitor) error {
	if s.Text != nil {
		return visitor.VisitText(s.Text)
	}
	if s.Multiline != nil {
		return visitor.VisitMultiline(s.Multiline)
	}
	if s.Array != nil {
		return visitor.VisitArray(s.Array)
	}
	if s.Complexarray != nil {
		return visitor.VisitComplexarray(s.Complexarray)
	}
	if s.Color != nil {
		return visitor.VisitColor(s.Color)
	}
	if s.Image != nil {
		return visitor.VisitImage(s.Image)
	}
	if s.Checkbox != nil {
		return visitor.VisitCheckbox(s.Checkbox)
	}
	if s.Dropdown != nil {
		return visitor.VisitDropdown(s.Dropdown)
	}
	if s.Section != nil {
		return visitor.VisitSection(s.Section)
	}
	if s.Oauth != nil {
		return visitor.VisitOauth(s.Oauth)
	}
	if s.Number != nil {
		return visitor.VisitNumber(s.Number)
	}
	if s.OneOf != nil {
		return visitor.VisitOneOf(s.OneOf)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *SettingsSchemaEntry) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Text != nil {
		fields = append(fields, "text")
	}
	if s.Multiline != nil {
		fields = append(fields, "multiline")
	}
	if s.Array != nil {
		fields = append(fields, "array")
	}
	if s.Complexarray != nil {
		fields = append(fields, "complexarray")
	}
	if s.Color != nil {
		fields = append(fields, "color")
	}
	if s.Image != nil {
		fields = append(fields, "image")
	}
	if s.Checkbox != nil {
		fields = append(fields, "checkbox")
	}
	if s.Dropdown != nil {
		fields = append(fields, "dropdown")
	}
	if s.Section != nil {
		fields = append(fields, "section")
	}
	if s.Oauth != nil {
		fields = append(fields, "oauth")
	}
	if s.Number != nil {
		fields = append(fields, "number")
	}
	if s.OneOf != nil {
		fields = append(fields, "oneOf")
	}
	if len(fields) == 0 {
		if s.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.Type)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.Type != "" {
		field := fields[0]
		if s.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.Type,
				s,
			)
		}
	}
	return nil
}

var (
	settingsSchemaEntryBaseFieldKey         = big.NewInt(1 << 0)
	settingsSchemaEntryBaseFieldDisplayName = big.NewInt(1 << 1)
	settingsSchemaEntryBaseFieldDescription = big.NewInt(1 << 2)
	settingsSchemaEntryBaseFieldVisibility  = big.NewInt(1 << 3)
	settingsSchemaEntryBaseFieldRequired    = big.NewInt(1 << 4)
)

type SettingsSchemaEntryBase struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required *bool `json:"required,omitempty" url:"required,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SettingsSchemaEntryBase) GetKey() string {
	if s == nil {
		return ""
	}
	return s.Key
}

func (s *SettingsSchemaEntryBase) GetDisplayName() string {
	if s == nil {
		return ""
	}
	return s.DisplayName
}

func (s *SettingsSchemaEntryBase) GetDescription() *string {
	if s == nil {
		return nil
	}
	return s.Description
}

func (s *SettingsSchemaEntryBase) GetVisibility() *VisibilityType {
	if s == nil {
		return nil
	}
	return s.Visibility
}

func (s *SettingsSchemaEntryBase) GetRequired() *bool {
	if s == nil {
		return nil
	}
	return s.Required
}

func (s *SettingsSchemaEntryBase) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SettingsSchemaEntryBase) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettingsSchemaEntryBase) SetKey(key string) {
	s.Key = key
	s.require(settingsSchemaEntryBaseFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettingsSchemaEntryBase) SetDisplayName(displayName string) {
	s.DisplayName = displayName
	s.require(settingsSchemaEntryBaseFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettingsSchemaEntryBase) SetDescription(description *string) {
	s.Description = description
	s.require(settingsSchemaEntryBaseFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettingsSchemaEntryBase) SetVisibility(visibility *VisibilityType) {
	s.Visibility = visibility
	s.require(settingsSchemaEntryBaseFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettingsSchemaEntryBase) SetRequired(required *bool) {
	s.Required = required
	s.require(settingsSchemaEntryBaseFieldRequired)
}

func (s *SettingsSchemaEntryBase) UnmarshalJSON(data []byte) error {
	type unmarshaler SettingsSchemaEntryBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SettingsSchemaEntryBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SettingsSchemaEntryBase) MarshalJSON() ([]byte, error) {
	type embed SettingsSchemaEntryBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SettingsSchemaEntryBase) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	settingsSchemaValidationFieldPattern      = big.NewInt(1 << 0)
	settingsSchemaValidationFieldErrorMessage = big.NewInt(1 << 1)
)

type SettingsSchemaValidation struct {
	// Regular expression pattern for validation
	Pattern string `json:"pattern" url:"pattern"`
	// Custom error message shown when validation fails
	ErrorMessage string `json:"errorMessage" url:"errorMessage"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SettingsSchemaValidation) GetPattern() string {
	if s == nil {
		return ""
	}
	return s.Pattern
}

func (s *SettingsSchemaValidation) GetErrorMessage() string {
	if s == nil {
		return ""
	}
	return s.ErrorMessage
}

func (s *SettingsSchemaValidation) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SettingsSchemaValidation) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetPattern sets the Pattern field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettingsSchemaValidation) SetPattern(pattern string) {
	s.Pattern = pattern
	s.require(settingsSchemaValidationFieldPattern)
}

// SetErrorMessage sets the ErrorMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SettingsSchemaValidation) SetErrorMessage(errorMessage string) {
	s.ErrorMessage = errorMessage
	s.require(settingsSchemaValidationFieldErrorMessage)
}

func (s *SettingsSchemaValidation) UnmarshalJSON(data []byte) error {
	type unmarshaler SettingsSchemaValidation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SettingsSchemaValidation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SettingsSchemaValidation) MarshalJSON() ([]byte, error) {
	type embed SettingsSchemaValidation
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SettingsSchemaValidation) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	simulationContextFieldAdditionalPromptText    = big.NewInt(1 << 0)
	simulationContextFieldPersona                 = big.NewInt(1 << 1)
	simulationContextFieldAvailableKnowledgeBases = big.NewInt(1 << 2)
)

type SimulationContext struct {
	// If provided, overrides the agent's default additional prompt text during the simulation.
	// Note that this field is provided for backwards compatibility and will be removed in a future release.
	// Instead please use the `availableKnowledgeBases` field to include a knowledge base with a document `llmInclusionStatus` set to `ALWAYS`.
	AdditionalPromptText *string `json:"additionalPromptText,omitempty" url:"additionalPromptText,omitempty"`
	// The persona to use during the simulation. If not provided, the agent's default persona will be used.
	Persona *LlmPersona `json:"persona,omitempty" url:"persona,omitempty"`
	// If provided, knowledge search will be restricted to the provided list of knowledge bases. Otherwise, all active knowledge bases will be used. An empty list means no knowledge bases will be used.
	AvailableKnowledgeBases []*EntityID `json:"availableKnowledgeBases,omitempty" url:"availableKnowledgeBases,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SimulationContext) GetAdditionalPromptText() *string {
	if s == nil {
		return nil
	}
	return s.AdditionalPromptText
}

func (s *SimulationContext) GetPersona() *LlmPersona {
	if s == nil {
		return nil
	}
	return s.Persona
}

func (s *SimulationContext) GetAvailableKnowledgeBases() []*EntityID {
	if s == nil {
		return nil
	}
	return s.AvailableKnowledgeBases
}

func (s *SimulationContext) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SimulationContext) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetAdditionalPromptText sets the AdditionalPromptText field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SimulationContext) SetAdditionalPromptText(additionalPromptText *string) {
	s.AdditionalPromptText = additionalPromptText
	s.require(simulationContextFieldAdditionalPromptText)
}

// SetPersona sets the Persona field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SimulationContext) SetPersona(persona *LlmPersona) {
	s.Persona = persona
	s.require(simulationContextFieldPersona)
}

// SetAvailableKnowledgeBases sets the AvailableKnowledgeBases field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SimulationContext) SetAvailableKnowledgeBases(availableKnowledgeBases []*EntityID) {
	s.AvailableKnowledgeBases = availableKnowledgeBases
	s.require(simulationContextFieldAvailableKnowledgeBases)
}

func (s *SimulationContext) UnmarshalJSON(data []byte) error {
	type unmarshaler SimulationContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SimulationContext(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SimulationContext) MarshalJSON() ([]byte, error) {
	type embed SimulationContext
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SimulationContext) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	sourceFieldTitle = big.NewInt(1 << 0)
	sourceFieldURL   = big.NewInt(1 << 1)
)

type Source struct {
	Title string `json:"title" url:"title"`
	URL   string `json:"url" url:"url"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Source) GetTitle() string {
	if s == nil {
		return ""
	}
	return s.Title
}

func (s *Source) GetURL() string {
	if s == nil {
		return ""
	}
	return s.URL
}

func (s *Source) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Source) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Source) SetTitle(title string) {
	s.Title = title
	s.require(sourceFieldTitle)
}

// SetURL sets the URL field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Source) SetURL(url string) {
	s.URL = url
	s.require(sourceFieldURL)
}

func (s *Source) UnmarshalJSON(data []byte) error {
	type unmarshaler Source
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Source(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Source) MarshalJSON() ([]byte, error) {
	type embed Source
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *Source) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	sourceInfoFieldType         = big.NewInt(1 << 0)
	sourceInfoFieldDeviceInfo   = big.NewInt(1 << 1)
	sourceInfoFieldBrowserInfo  = big.NewInt(1 << 2)
	sourceInfoFieldGeoInfo      = big.NewInt(1 << 3)
	sourceInfoFieldIPInfo       = big.NewInt(1 << 4)
	sourceInfoFieldLanguageInfo = big.NewInt(1 << 5)
)

type SourceInfo struct {
	Type         SourceType    `json:"type" url:"type"`
	DeviceInfo   *DeviceInfo   `json:"deviceInfo,omitempty" url:"deviceInfo,omitempty"`
	BrowserInfo  *BrowserInfo  `json:"browserInfo,omitempty" url:"browserInfo,omitempty"`
	GeoInfo      *GeoInfo      `json:"geoInfo,omitempty" url:"geoInfo,omitempty"`
	IPInfo       *IPInfo       `json:"ipInfo,omitempty" url:"ipInfo,omitempty"`
	LanguageInfo *LanguageInfo `json:"languageInfo,omitempty" url:"languageInfo,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SourceInfo) GetType() SourceType {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SourceInfo) GetDeviceInfo() *DeviceInfo {
	if s == nil {
		return nil
	}
	return s.DeviceInfo
}

func (s *SourceInfo) GetBrowserInfo() *BrowserInfo {
	if s == nil {
		return nil
	}
	return s.BrowserInfo
}

func (s *SourceInfo) GetGeoInfo() *GeoInfo {
	if s == nil {
		return nil
	}
	return s.GeoInfo
}

func (s *SourceInfo) GetIPInfo() *IPInfo {
	if s == nil {
		return nil
	}
	return s.IPInfo
}

func (s *SourceInfo) GetLanguageInfo() *LanguageInfo {
	if s == nil {
		return nil
	}
	return s.LanguageInfo
}

func (s *SourceInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceInfo) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetType(type_ SourceType) {
	s.Type = type_
	s.require(sourceInfoFieldType)
}

// SetDeviceInfo sets the DeviceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetDeviceInfo(deviceInfo *DeviceInfo) {
	s.DeviceInfo = deviceInfo
	s.require(sourceInfoFieldDeviceInfo)
}

// SetBrowserInfo sets the BrowserInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetBrowserInfo(browserInfo *BrowserInfo) {
	s.BrowserInfo = browserInfo
	s.require(sourceInfoFieldBrowserInfo)
}

// SetGeoInfo sets the GeoInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetGeoInfo(geoInfo *GeoInfo) {
	s.GeoInfo = geoInfo
	s.require(sourceInfoFieldGeoInfo)
}

// SetIPInfo sets the IPInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetIPInfo(ipInfo *IPInfo) {
	s.IPInfo = ipInfo
	s.require(sourceInfoFieldIPInfo)
}

// SetLanguageInfo sets the LanguageInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetLanguageInfo(languageInfo *LanguageInfo) {
	s.LanguageInfo = languageInfo
	s.require(sourceInfoFieldLanguageInfo)
}

func (s *SourceInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceInfo) MarshalJSON() ([]byte, error) {
	type embed SourceInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SourceInfo) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceType string

const (
	SourceTypeWeb    SourceType = "WEB"
	SourceTypeAPI    SourceType = "API"
	SourceTypeSystem SourceType = "SYSTEM"
)

func NewSourceTypeFromString(s string) (SourceType, error) {
	switch s {
	case "WEB":
		return SourceTypeWeb, nil
	case "API":
		return SourceTypeAPI, nil
	case "SYSTEM":
		return SourceTypeSystem, nil
	}
	var t SourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceType) Ptr() *SourceType {
	return &s
}

// Condition comparing against a single string value
var (
	stringComparisonConditionFieldOperator = big.NewInt(1 << 0)
	stringComparisonConditionFieldValue    = big.NewInt(1 << 1)
)

type StringComparisonCondition struct {
	// The comparison operator to apply
	Operator StringComparisonOperator `json:"operator" url:"operator"`
	// The string value to compare against
	Value string `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StringComparisonCondition) GetOperator() StringComparisonOperator {
	if s == nil {
		return ""
	}
	return s.Operator
}

func (s *StringComparisonCondition) GetValue() string {
	if s == nil {
		return ""
	}
	return s.Value
}

func (s *StringComparisonCondition) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringComparisonCondition) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StringComparisonCondition) SetOperator(operator StringComparisonOperator) {
	s.Operator = operator
	s.require(stringComparisonConditionFieldOperator)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StringComparisonCondition) SetValue(value string) {
	s.Value = value
	s.require(stringComparisonConditionFieldValue)
}

func (s *StringComparisonCondition) UnmarshalJSON(data []byte) error {
	type unmarshaler StringComparisonCondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringComparisonCondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringComparisonCondition) MarshalJSON() ([]byte, error) {
	type embed StringComparisonCondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *StringComparisonCondition) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Operators for single string value comparisons
type StringComparisonOperator string

const (
	// Equals (=)
	StringComparisonOperatorEq StringComparisonOperator = "EQ"
	// Not equals (!=)
	StringComparisonOperatorNeq StringComparisonOperator = "NEQ"
	// String contains as substring
	StringComparisonOperatorContainsSubstring StringComparisonOperator = "CONTAINS_SUBSTRING"
	// String does not contain as substring, i.e., negation of CONTAINS_SUBSTRING
	StringComparisonOperatorNotContainsSubstring StringComparisonOperator = "NOT_CONTAINS_SUBSTRING"
	// String starts with the specified prefix
	StringComparisonOperatorStartsWith StringComparisonOperator = "STARTS_WITH"
	// String does not start with the specified prefix
	StringComparisonOperatorNotStartsWith StringComparisonOperator = "NOT_STARTS_WITH"
	// String ends with the specified suffix
	StringComparisonOperatorEndsWith StringComparisonOperator = "ENDS_WITH"
	// String does not end with the specified suffix
	StringComparisonOperatorNotEndsWith StringComparisonOperator = "NOT_ENDS_WITH"
)

func NewStringComparisonOperatorFromString(s string) (StringComparisonOperator, error) {
	switch s {
	case "EQ":
		return StringComparisonOperatorEq, nil
	case "NEQ":
		return StringComparisonOperatorNeq, nil
	case "CONTAINS_SUBSTRING":
		return StringComparisonOperatorContainsSubstring, nil
	case "NOT_CONTAINS_SUBSTRING":
		return StringComparisonOperatorNotContainsSubstring, nil
	case "STARTS_WITH":
		return StringComparisonOperatorStartsWith, nil
	case "NOT_STARTS_WITH":
		return StringComparisonOperatorNotStartsWith, nil
	case "ENDS_WITH":
		return StringComparisonOperatorEndsWith, nil
	case "NOT_ENDS_WITH":
		return StringComparisonOperatorNotEndsWith, nil
	}
	var t StringComparisonOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StringComparisonOperator) Ptr() *StringComparisonOperator {
	return &s
}

// Condition for string values
type StringCondition struct {
	OpType     string
	Comparison *StringComparisonCondition
	Membership *StringMembershipCondition
}

func (s *StringCondition) GetOpType() string {
	if s == nil {
		return ""
	}
	return s.OpType
}

func (s *StringCondition) GetComparison() *StringComparisonCondition {
	if s == nil {
		return nil
	}
	return s.Comparison
}

func (s *StringCondition) GetMembership() *StringMembershipCondition {
	if s == nil {
		return nil
	}
	return s.Membership
}

func (s *StringCondition) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		OpType string `json:"opType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.OpType = unmarshaler.OpType
	if unmarshaler.OpType == "" {
		return fmt.Errorf("%T did not include discriminant opType", s)
	}
	switch unmarshaler.OpType {
	case "comparison":
		value := new(StringComparisonCondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Comparison = value
	case "membership":
		value := new(StringMembershipCondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.Membership = value
	}
	return nil
}

func (s StringCondition) MarshalJSON() ([]byte, error) {
	if err := s.validate(); err != nil {
		return nil, err
	}
	if s.Comparison != nil {
		return internal.MarshalJSONWithExtraProperty(s.Comparison, "opType", "comparison")
	}
	if s.Membership != nil {
		return internal.MarshalJSONWithExtraProperty(s.Membership, "opType", "membership")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type StringConditionVisitor interface {
	VisitComparison(*StringComparisonCondition) error
	VisitMembership(*StringMembershipCondition) error
}

func (s *StringCondition) Accept(visitor StringConditionVisitor) error {
	if s.Comparison != nil {
		return visitor.VisitComparison(s.Comparison)
	}
	if s.Membership != nil {
		return visitor.VisitMembership(s.Membership)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

func (s *StringCondition) validate() error {
	if s == nil {
		return fmt.Errorf("type %T is nil", s)
	}
	var fields []string
	if s.Comparison != nil {
		fields = append(fields, "comparison")
	}
	if s.Membership != nil {
		fields = append(fields, "membership")
	}
	if len(fields) == 0 {
		if s.OpType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", s, s.OpType)
		}
		return fmt.Errorf("type %T is empty", s)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", s, fields)
	}
	if s.OpType != "" {
		field := fields[0]
		if s.OpType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				s,
				s.OpType,
				s,
			)
		}
	}
	return nil
}

// Condition checking membership in a set of strings
var (
	stringMembershipConditionFieldOperator = big.NewInt(1 << 0)
	stringMembershipConditionFieldValues   = big.NewInt(1 << 1)
)

type StringMembershipCondition struct {
	// The comparison operator to apply
	Operator StringMembershipOperator `json:"operator" url:"operator"`
	// The set of string values to compare against
	Values []string `json:"values" url:"values"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *StringMembershipCondition) GetOperator() StringMembershipOperator {
	if s == nil {
		return ""
	}
	return s.Operator
}

func (s *StringMembershipCondition) GetValues() []string {
	if s == nil {
		return nil
	}
	return s.Values
}

func (s *StringMembershipCondition) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *StringMembershipCondition) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StringMembershipCondition) SetOperator(operator StringMembershipOperator) {
	s.Operator = operator
	s.require(stringMembershipConditionFieldOperator)
}

// SetValues sets the Values field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *StringMembershipCondition) SetValues(values []string) {
	s.Values = values
	s.require(stringMembershipConditionFieldValues)
}

func (s *StringMembershipCondition) UnmarshalJSON(data []byte) error {
	type unmarshaler StringMembershipCondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = StringMembershipCondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *StringMembershipCondition) MarshalJSON() ([]byte, error) {
	type embed StringMembershipCondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *StringMembershipCondition) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// Operators for string set membership
type StringMembershipOperator string

const (
	// Value is in the set ()
	StringMembershipOperatorIn StringMembershipOperator = "IN"
	// Value is not in the set ()
	StringMembershipOperatorNotIn StringMembershipOperator = "NOT_IN"
)

func NewStringMembershipOperatorFromString(s string) (StringMembershipOperator, error) {
	switch s {
	case "IN":
		return StringMembershipOperatorIn, nil
	case "NOT_IN":
		return StringMembershipOperatorNotIn, nil
	}
	var t StringMembershipOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s StringMembershipOperator) Ptr() *StringMembershipOperator {
	return &s
}

var (
	surveyInfoFieldSurveyQuestion = big.NewInt(1 << 0)
	surveyInfoFieldSurveyAnswer   = big.NewInt(1 << 1)
)

type SurveyInfo struct {
	SurveyQuestion *string `json:"surveyQuestion,omitempty" url:"surveyQuestion,omitempty"`
	SurveyAnswer   *string `json:"surveyAnswer,omitempty" url:"surveyAnswer,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SurveyInfo) GetSurveyQuestion() *string {
	if s == nil {
		return nil
	}
	return s.SurveyQuestion
}

func (s *SurveyInfo) GetSurveyAnswer() *string {
	if s == nil {
		return nil
	}
	return s.SurveyAnswer
}

func (s *SurveyInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SurveyInfo) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSurveyQuestion sets the SurveyQuestion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SurveyInfo) SetSurveyQuestion(surveyQuestion *string) {
	s.SurveyQuestion = surveyQuestion
	s.require(surveyInfoFieldSurveyQuestion)
}

// SetSurveyAnswer sets the SurveyAnswer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SurveyInfo) SetSurveyAnswer(surveyAnswer *string) {
	s.SurveyAnswer = surveyAnswer
	s.require(surveyInfoFieldSurveyAnswer)
}

func (s *SurveyInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SurveyInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SurveyInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SurveyInfo) MarshalJSON() ([]byte, error) {
	type embed SurveyInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SurveyInfo) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	systemEventFieldTimestamp   = big.NewInt(1 << 0)
	systemEventFieldReferences  = big.NewInt(1 << 1)
	systemEventFieldSourceInfo  = big.NewInt(1 << 2)
	systemEventFieldSessionInfo = big.NewInt(1 << 3)
	systemEventFieldContextInfo = big.NewInt(1 << 4)
	systemEventFieldEventName   = big.NewInt(1 << 5)
	systemEventFieldID          = big.NewInt(1 << 6)
)

type SystemEvent struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`
	// The name of the event
	EventName SystemEventName `json:"eventName" url:"eventName"`
	// The unique ID of the event
	ID *EntityID `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SystemEvent) GetTimestamp() *time.Time {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *SystemEvent) GetReferences() []*ScopedEntity {
	if s == nil {
		return nil
	}
	return s.References
}

func (s *SystemEvent) GetSourceInfo() *SourceInfo {
	if s == nil {
		return nil
	}
	return s.SourceInfo
}

func (s *SystemEvent) GetSessionInfo() *SessionInfo {
	if s == nil {
		return nil
	}
	return s.SessionInfo
}

func (s *SystemEvent) GetContextInfo() *ContextInfo {
	if s == nil {
		return nil
	}
	return s.ContextInfo
}

func (s *SystemEvent) GetEventName() SystemEventName {
	if s == nil {
		return ""
	}
	return s.EventName
}

func (s *SystemEvent) GetID() *EntityID {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *SystemEvent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SystemEvent) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetTimestamp(timestamp *time.Time) {
	s.Timestamp = timestamp
	s.require(systemEventFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetReferences(references []*ScopedEntity) {
	s.References = references
	s.require(systemEventFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetSourceInfo(sourceInfo *SourceInfo) {
	s.SourceInfo = sourceInfo
	s.require(systemEventFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetSessionInfo(sessionInfo *SessionInfo) {
	s.SessionInfo = sessionInfo
	s.require(systemEventFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetContextInfo(contextInfo *ContextInfo) {
	s.ContextInfo = contextInfo
	s.require(systemEventFieldContextInfo)
}

// SetEventName sets the EventName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetEventName(eventName SystemEventName) {
	s.EventName = eventName
	s.require(systemEventFieldEventName)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetID(id *EntityID) {
	s.ID = id
	s.require(systemEventFieldID)
}

func (s *SystemEvent) UnmarshalJSON(data []byte) error {
	type embed SystemEvent
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SystemEvent(unmarshaler.embed)
	s.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemEvent) MarshalJSON() ([]byte, error) {
	type embed SystemEvent
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*s),
		Timestamp: internal.NewOptionalDateTime(s.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SystemEvent) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SystemEventName string

const (
	// An app was installed
	SystemEventNameAppInstalled SystemEventName = "APP_INSTALLED"
	// An app was uninstalled
	SystemEventNameAppUninstalled SystemEventName = "APP_UNINSTALLED"
	// An app was updated
	SystemEventNameAppUpdated SystemEventName = "APP_UPDATED"
)

func NewSystemEventNameFromString(s string) (SystemEventName, error) {
	switch s {
	case "APP_INSTALLED":
		return SystemEventNameAppInstalled, nil
	case "APP_UNINSTALLED":
		return SystemEventNameAppUninstalled, nil
	case "APP_UPDATED":
		return SystemEventNameAppUpdated, nil
	}
	var t SystemEventName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SystemEventName) Ptr() *SystemEventName {
	return &s
}

var (
	tagsPreconditionFieldOperator = big.NewInt(1 << 0)
	tagsPreconditionFieldTags     = big.NewInt(1 << 1)
)

type TagsPrecondition struct {
	// Operator to apply to this precondition
	Operator *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`
	// The tags that must be present in the conversation context for the precondition to be met
	Tags []string `json:"tags" url:"tags"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TagsPrecondition) GetOperator() *PreconditionOperator {
	if t == nil {
		return nil
	}
	return t.Operator
}

func (t *TagsPrecondition) GetTags() []string {
	if t == nil {
		return nil
	}
	return t.Tags
}

func (t *TagsPrecondition) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TagsPrecondition) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TagsPrecondition) SetOperator(operator *PreconditionOperator) {
	t.Operator = operator
	t.require(tagsPreconditionFieldOperator)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TagsPrecondition) SetTags(tags []string) {
	t.Tags = tags
	t.require(tagsPreconditionFieldTags)
}

func (t *TagsPrecondition) UnmarshalJSON(data []byte) error {
	type unmarshaler TagsPrecondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TagsPrecondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TagsPrecondition) MarshalJSON() ([]byte, error) {
	type embed TagsPrecondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TagsPrecondition) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

var (
	textSettingsSchemaEntryFieldKey          = big.NewInt(1 << 0)
	textSettingsSchemaEntryFieldDisplayName  = big.NewInt(1 << 1)
	textSettingsSchemaEntryFieldDescription  = big.NewInt(1 << 2)
	textSettingsSchemaEntryFieldVisibility   = big.NewInt(1 << 3)
	textSettingsSchemaEntryFieldRequired     = big.NewInt(1 << 4)
	textSettingsSchemaEntryFieldDefaultValue = big.NewInt(1 << 5)
	textSettingsSchemaEntryFieldValidation   = big.NewInt(1 << 6)
)

type TextSettingsSchemaEntry struct {
	Key         string          `json:"key" url:"key"`
	DisplayName string          `json:"displayName" url:"displayName"`
	Description *string         `json:"description,omitempty" url:"description,omitempty"`
	Visibility  *VisibilityType `json:"visibility,omitempty" url:"visibility,omitempty"`
	// Whether the setting must have a value upon install. Defaults to false.
	Required     *bool                     `json:"required,omitempty" url:"required,omitempty"`
	DefaultValue *string                   `json:"defaultValue,omitempty" url:"defaultValue,omitempty"`
	Validation   *SettingsSchemaValidation `json:"validation,omitempty" url:"validation,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TextSettingsSchemaEntry) GetKey() string {
	if t == nil {
		return ""
	}
	return t.Key
}

func (t *TextSettingsSchemaEntry) GetDisplayName() string {
	if t == nil {
		return ""
	}
	return t.DisplayName
}

func (t *TextSettingsSchemaEntry) GetDescription() *string {
	if t == nil {
		return nil
	}
	return t.Description
}

func (t *TextSettingsSchemaEntry) GetVisibility() *VisibilityType {
	if t == nil {
		return nil
	}
	return t.Visibility
}

func (t *TextSettingsSchemaEntry) GetRequired() *bool {
	if t == nil {
		return nil
	}
	return t.Required
}

func (t *TextSettingsSchemaEntry) GetDefaultValue() *string {
	if t == nil {
		return nil
	}
	return t.DefaultValue
}

func (t *TextSettingsSchemaEntry) GetValidation() *SettingsSchemaValidation {
	if t == nil {
		return nil
	}
	return t.Validation
}

func (t *TextSettingsSchemaEntry) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TextSettingsSchemaEntry) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextSettingsSchemaEntry) SetKey(key string) {
	t.Key = key
	t.require(textSettingsSchemaEntryFieldKey)
}

// SetDisplayName sets the DisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextSettingsSchemaEntry) SetDisplayName(displayName string) {
	t.DisplayName = displayName
	t.require(textSettingsSchemaEntryFieldDisplayName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextSettingsSchemaEntry) SetDescription(description *string) {
	t.Description = description
	t.require(textSettingsSchemaEntryFieldDescription)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextSettingsSchemaEntry) SetVisibility(visibility *VisibilityType) {
	t.Visibility = visibility
	t.require(textSettingsSchemaEntryFieldVisibility)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextSettingsSchemaEntry) SetRequired(required *bool) {
	t.Required = required
	t.require(textSettingsSchemaEntryFieldRequired)
}

// SetDefaultValue sets the DefaultValue field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextSettingsSchemaEntry) SetDefaultValue(defaultValue *string) {
	t.DefaultValue = defaultValue
	t.require(textSettingsSchemaEntryFieldDefaultValue)
}

// SetValidation sets the Validation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TextSettingsSchemaEntry) SetValidation(validation *SettingsSchemaValidation) {
	t.Validation = validation
	t.require(textSettingsSchemaEntryFieldValidation)
}

func (t *TextSettingsSchemaEntry) UnmarshalJSON(data []byte) error {
	type unmarshaler TextSettingsSchemaEntry
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TextSettingsSchemaEntry(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TextSettingsSchemaEntry) MarshalJSON() ([]byte, error) {
	type embed TextSettingsSchemaEntry
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TextSettingsSchemaEntry) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The type of user message
type UserConversationMessageType string

const (
	UserConversationMessageTypeUser           UserConversationMessageType = "USER"
	UserConversationMessageTypeHumanAgent     UserConversationMessageType = "HUMAN_AGENT"
	UserConversationMessageTypeExternalSystem UserConversationMessageType = "EXTERNAL_SYSTEM"
)

func NewUserConversationMessageTypeFromString(s string) (UserConversationMessageType, error) {
	switch s {
	case "USER":
		return UserConversationMessageTypeUser, nil
	case "HUMAN_AGENT":
		return UserConversationMessageTypeHumanAgent, nil
	case "EXTERNAL_SYSTEM":
		return UserConversationMessageTypeExternalSystem, nil
	}
	var t UserConversationMessageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UserConversationMessageType) Ptr() *UserConversationMessageType {
	return &u
}

var (
	userDataFieldValue      = big.NewInt(1 << 0)
	userDataFieldVisibility = big.NewInt(1 << 1)
)

type UserData struct {
	// The value of the user metadata
	Value string `json:"value" url:"value"`
	// The visibility of the user metadata
	Visibility VisibilityType `json:"visibility" url:"visibility"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserData) GetValue() string {
	if u == nil {
		return ""
	}
	return u.Value
}

func (u *UserData) GetVisibility() VisibilityType {
	if u == nil {
		return ""
	}
	return u.Visibility
}

func (u *UserData) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserData) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserData) SetValue(value string) {
	u.Value = value
	u.require(userDataFieldValue)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserData) SetVisibility(visibility VisibilityType) {
	u.Visibility = visibility
	u.require(userDataFieldVisibility)
}

func (u *UserData) UnmarshalJSON(data []byte) error {
	type unmarshaler UserData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserData) MarshalJSON() ([]byte, error) {
	type embed UserData
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserData) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	userDataWithReferenceFieldValue      = big.NewInt(1 << 0)
	userDataWithReferenceFieldVisibility = big.NewInt(1 << 1)
	userDataWithReferenceFieldUserID     = big.NewInt(1 << 2)
)

type UserDataWithReference struct {
	// The value of the user metadata
	Value string `json:"value" url:"value"`
	// The visibility of the user metadata
	Visibility VisibilityType `json:"visibility" url:"visibility"`
	// Reverse index containing appId and referenceId data that identifies this app user
	UserID *EntityIDFilter `json:"userId" url:"userId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserDataWithReference) GetValue() string {
	if u == nil {
		return ""
	}
	return u.Value
}

func (u *UserDataWithReference) GetVisibility() VisibilityType {
	if u == nil {
		return ""
	}
	return u.Visibility
}

func (u *UserDataWithReference) GetUserID() *EntityIDFilter {
	if u == nil {
		return nil
	}
	return u.UserID
}

func (u *UserDataWithReference) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserDataWithReference) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserDataWithReference) SetValue(value string) {
	u.Value = value
	u.require(userDataWithReferenceFieldValue)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserDataWithReference) SetVisibility(visibility VisibilityType) {
	u.Visibility = visibility
	u.require(userDataWithReferenceFieldVisibility)
}

// SetUserID sets the UserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserDataWithReference) SetUserID(userID *EntityIDFilter) {
	u.UserID = userID
	u.require(userDataWithReferenceFieldUserID)
}

func (u *UserDataWithReference) UnmarshalJSON(data []byte) error {
	type unmarshaler UserDataWithReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserDataWithReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserDataWithReference) MarshalJSON() ([]byte, error) {
	type embed UserDataWithReference
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserDataWithReference) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	userEventFieldTimestamp    = big.NewInt(1 << 0)
	userEventFieldReferences   = big.NewInt(1 << 1)
	userEventFieldSourceInfo   = big.NewInt(1 << 2)
	userEventFieldSessionInfo  = big.NewInt(1 << 3)
	userEventFieldContextInfo  = big.NewInt(1 << 4)
	userEventFieldID           = big.NewInt(1 << 5)
	userEventFieldCreatedAt    = big.NewInt(1 << 6)
	userEventFieldEventName    = big.NewInt(1 << 7)
	userEventFieldUserInfo     = big.NewInt(1 << 8)
	userEventFieldFeedbackInfo = big.NewInt(1 << 9)
	userEventFieldCsatInfo     = big.NewInt(1 << 10)
	userEventFieldPageInfo     = big.NewInt(1 << 11)
)

type UserEvent struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`
	// The unique ID of the event
	ID *EntityID `json:"id" url:"id"`
	// The date and time the event was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The name of the event
	EventName UserEventName `json:"eventName" url:"eventName"`
	// Information about the user who triggered the event
	UserInfo *EventUserInfo `json:"userInfo" url:"userInfo"`
	// Information about any feedback associated with the event
	FeedbackInfo []*FeedbackInfo `json:"feedbackInfo,omitempty" url:"feedbackInfo,omitempty"`
	// Information about any CSAT survey associated with the event
	CsatInfo *CsatInfo `json:"csatInfo,omitempty" url:"csatInfo,omitempty"`
	// Information about the page on which the event occurred
	PageInfo *PageInfo `json:"pageInfo,omitempty" url:"pageInfo,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserEvent) GetTimestamp() *time.Time {
	if u == nil {
		return nil
	}
	return u.Timestamp
}

func (u *UserEvent) GetReferences() []*ScopedEntity {
	if u == nil {
		return nil
	}
	return u.References
}

func (u *UserEvent) GetSourceInfo() *SourceInfo {
	if u == nil {
		return nil
	}
	return u.SourceInfo
}

func (u *UserEvent) GetSessionInfo() *SessionInfo {
	if u == nil {
		return nil
	}
	return u.SessionInfo
}

func (u *UserEvent) GetContextInfo() *ContextInfo {
	if u == nil {
		return nil
	}
	return u.ContextInfo
}

func (u *UserEvent) GetID() *EntityID {
	if u == nil {
		return nil
	}
	return u.ID
}

func (u *UserEvent) GetCreatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.CreatedAt
}

func (u *UserEvent) GetEventName() UserEventName {
	if u == nil {
		return ""
	}
	return u.EventName
}

func (u *UserEvent) GetUserInfo() *EventUserInfo {
	if u == nil {
		return nil
	}
	return u.UserInfo
}

func (u *UserEvent) GetFeedbackInfo() []*FeedbackInfo {
	if u == nil {
		return nil
	}
	return u.FeedbackInfo
}

func (u *UserEvent) GetCsatInfo() *CsatInfo {
	if u == nil {
		return nil
	}
	return u.CsatInfo
}

func (u *UserEvent) GetPageInfo() *PageInfo {
	if u == nil {
		return nil
	}
	return u.PageInfo
}

func (u *UserEvent) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserEvent) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetTimestamp(timestamp *time.Time) {
	u.Timestamp = timestamp
	u.require(userEventFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetReferences(references []*ScopedEntity) {
	u.References = references
	u.require(userEventFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetSourceInfo(sourceInfo *SourceInfo) {
	u.SourceInfo = sourceInfo
	u.require(userEventFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetSessionInfo(sessionInfo *SessionInfo) {
	u.SessionInfo = sessionInfo
	u.require(userEventFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetContextInfo(contextInfo *ContextInfo) {
	u.ContextInfo = contextInfo
	u.require(userEventFieldContextInfo)
}

// SetID sets the ID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetID(id *EntityID) {
	u.ID = id
	u.require(userEventFieldID)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetCreatedAt(createdAt *time.Time) {
	u.CreatedAt = createdAt
	u.require(userEventFieldCreatedAt)
}

// SetEventName sets the EventName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetEventName(eventName UserEventName) {
	u.EventName = eventName
	u.require(userEventFieldEventName)
}

// SetUserInfo sets the UserInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetUserInfo(userInfo *EventUserInfo) {
	u.UserInfo = userInfo
	u.require(userEventFieldUserInfo)
}

// SetFeedbackInfo sets the FeedbackInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetFeedbackInfo(feedbackInfo []*FeedbackInfo) {
	u.FeedbackInfo = feedbackInfo
	u.require(userEventFieldFeedbackInfo)
}

// SetCsatInfo sets the CsatInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetCsatInfo(csatInfo *CsatInfo) {
	u.CsatInfo = csatInfo
	u.require(userEventFieldCsatInfo)
}

// SetPageInfo sets the PageInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetPageInfo(pageInfo *PageInfo) {
	u.PageInfo = pageInfo
	u.require(userEventFieldPageInfo)
}

func (u *UserEvent) UnmarshalJSON(data []byte) error {
	type embed UserEvent
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserEvent(unmarshaler.embed)
	u.Timestamp = unmarshaler.Timestamp.TimePtr()
	u.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserEvent) MarshalJSON() ([]byte, error) {
	type embed UserEvent
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
	}{
		embed:     embed(*u),
		Timestamp: internal.NewOptionalDateTime(u.Timestamp),
		CreatedAt: internal.NewOptionalDateTime(u.CreatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserEvent) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserEventName string

const (
	// A button click occurred
	UserEventNameButtonClicked UserEventName = "BUTTON_CLICKED"
	// A link was clicked
	UserEventNameLinkClicked UserEventName = "LINK_CLICKED"
	// The chat window was opened
	UserEventNameChatOpened UserEventName = "CHAT_OPENED"
	// The chat window was closed
	UserEventNameChatClosed UserEventName = "CHAT_CLOSED"
	// A text was inserted into a field
	UserEventNameTextInserted UserEventName = "TEXT_INSERTED"
)

func NewUserEventNameFromString(s string) (UserEventName, error) {
	switch s {
	case "BUTTON_CLICKED":
		return UserEventNameButtonClicked, nil
	case "LINK_CLICKED":
		return UserEventNameLinkClicked, nil
	case "CHAT_OPENED":
		return UserEventNameChatOpened, nil
	case "CHAT_CLOSED":
		return UserEventNameChatClosed, nil
	case "TEXT_INSERTED":
		return UserEventNameTextInserted, nil
	}
	var t UserEventName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UserEventName) Ptr() *UserEventName {
	return &u
}

var (
	userMessageFieldCreatedAt             = big.NewInt(1 << 0)
	userMessageFieldUpdatedAt             = big.NewInt(1 << 1)
	userMessageFieldUserID                = big.NewInt(1 << 2)
	userMessageFieldText                  = big.NewInt(1 << 3)
	userMessageFieldUserMessageType       = big.NewInt(1 << 4)
	userMessageFieldConversationMessageID = big.NewInt(1 << 5)
	userMessageFieldLanguage              = big.NewInt(1 << 6)
	userMessageFieldAttachments           = big.NewInt(1 << 7)
	userMessageFieldAgentUserID           = big.NewInt(1 << 8)
	userMessageFieldUserDisplayName       = big.NewInt(1 << 9)
	userMessageFieldStatus                = big.NewInt(1 << 10)
	userMessageFieldResponseState         = big.NewInt(1 << 11)
)

type UserMessage struct {
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// ID that uniquely identifies the user that created this message
	UserID *EntityIDBase `json:"userId" url:"userId"`
	// The text of the message. Cannot be empty
	Text            string                      `json:"text" url:"text"`
	UserMessageType UserConversationMessageType `json:"userMessageType" url:"userMessageType"`
	// The ID that uniquely identifies this message within the conversation
	ConversationMessageID *EntityID `json:"conversationMessageId" url:"conversationMessageId"`
	// The language of the message in ISO 639-1 code format
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The attachments associated with the message
	Attachments []*AttachmentResponse `json:"attachments" url:"attachments"`
	// The ID of the agent user that created this message. More detail can be fetched via the agent user APIs. Will be empty only for legacy conversations.
	AgentUserID *string `json:"agentUserId,omitempty" url:"agentUserId,omitempty"`
	// The display name of the user who created this message. Only available for users who have saved name information.
	UserDisplayName *string `json:"userDisplayName,omitempty" url:"userDisplayName,omitempty"`
	// The delivery status of the message. Only applicable to messages sent via the deliverMessage API.
	// All other messages have an `UNKNOWN` status.
	//
	// * `SENT`: The message has been sent to the user.
	// * `FAILED`: The message sending encountered an error.
	// * `UNKNOWN`: The message status is unknown.
	Status MessageStatus `json:"status" url:"status"`
	// Only present on newer messaged where `userMessageType` is `USER`.
	// Indicates the state of the answer to the user message.
	//
	// - `NOT_ASKED`: An answer was not requested for this user message.
	// - `LLM_ENABLED`: An answer was requested for this user message and the LLM was enabled.
	// - `LLM_DISABLED`: An answer was requested for this user message and the LLM was disabled.
	ResponseState *UserMessageResponseState `json:"responseState,omitempty" url:"responseState,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserMessage) GetCreatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.CreatedAt
}

func (u *UserMessage) GetUpdatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.UpdatedAt
}

func (u *UserMessage) GetUserID() *EntityIDBase {
	if u == nil {
		return nil
	}
	return u.UserID
}

func (u *UserMessage) GetText() string {
	if u == nil {
		return ""
	}
	return u.Text
}

func (u *UserMessage) GetUserMessageType() UserConversationMessageType {
	if u == nil {
		return ""
	}
	return u.UserMessageType
}

func (u *UserMessage) GetConversationMessageID() *EntityID {
	if u == nil {
		return nil
	}
	return u.ConversationMessageID
}

func (u *UserMessage) GetLanguage() *string {
	if u == nil {
		return nil
	}
	return u.Language
}

func (u *UserMessage) GetAttachments() []*AttachmentResponse {
	if u == nil {
		return nil
	}
	return u.Attachments
}

func (u *UserMessage) GetAgentUserID() *string {
	if u == nil {
		return nil
	}
	return u.AgentUserID
}

func (u *UserMessage) GetUserDisplayName() *string {
	if u == nil {
		return nil
	}
	return u.UserDisplayName
}

func (u *UserMessage) GetStatus() MessageStatus {
	if u == nil {
		return ""
	}
	return u.Status
}

func (u *UserMessage) GetResponseState() *UserMessageResponseState {
	if u == nil {
		return nil
	}
	return u.ResponseState
}

func (u *UserMessage) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserMessage) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetCreatedAt(createdAt *time.Time) {
	u.CreatedAt = createdAt
	u.require(userMessageFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetUpdatedAt(updatedAt *time.Time) {
	u.UpdatedAt = updatedAt
	u.require(userMessageFieldUpdatedAt)
}

// SetUserID sets the UserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetUserID(userID *EntityIDBase) {
	u.UserID = userID
	u.require(userMessageFieldUserID)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetText(text string) {
	u.Text = text
	u.require(userMessageFieldText)
}

// SetUserMessageType sets the UserMessageType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetUserMessageType(userMessageType UserConversationMessageType) {
	u.UserMessageType = userMessageType
	u.require(userMessageFieldUserMessageType)
}

// SetConversationMessageID sets the ConversationMessageID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetConversationMessageID(conversationMessageID *EntityID) {
	u.ConversationMessageID = conversationMessageID
	u.require(userMessageFieldConversationMessageID)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetLanguage(language *string) {
	u.Language = language
	u.require(userMessageFieldLanguage)
}

// SetAttachments sets the Attachments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetAttachments(attachments []*AttachmentResponse) {
	u.Attachments = attachments
	u.require(userMessageFieldAttachments)
}

// SetAgentUserID sets the AgentUserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetAgentUserID(agentUserID *string) {
	u.AgentUserID = agentUserID
	u.require(userMessageFieldAgentUserID)
}

// SetUserDisplayName sets the UserDisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetUserDisplayName(userDisplayName *string) {
	u.UserDisplayName = userDisplayName
	u.require(userMessageFieldUserDisplayName)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetStatus(status MessageStatus) {
	u.Status = status
	u.require(userMessageFieldStatus)
}

// SetResponseState sets the ResponseState field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetResponseState(responseState *UserMessageResponseState) {
	u.ResponseState = responseState
	u.require(userMessageFieldResponseState)
}

func (u *UserMessage) UnmarshalJSON(data []byte) error {
	type embed UserMessage
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserMessage(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	u.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserMessage) MarshalJSON() ([]byte, error) {
	type embed UserMessage
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*u),
		CreatedAt: internal.NewOptionalDateTime(u.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(u.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserMessage) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	userMessageBaseFieldCreatedAt       = big.NewInt(1 << 0)
	userMessageBaseFieldUpdatedAt       = big.NewInt(1 << 1)
	userMessageBaseFieldUserID          = big.NewInt(1 << 2)
	userMessageBaseFieldText            = big.NewInt(1 << 3)
	userMessageBaseFieldUserMessageType = big.NewInt(1 << 4)
)

type UserMessageBase struct {
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// ID that uniquely identifies the user that created this message
	UserID *EntityIDBase `json:"userId" url:"userId"`
	// The text of the message. Cannot be empty
	Text            string                      `json:"text" url:"text"`
	UserMessageType UserConversationMessageType `json:"userMessageType" url:"userMessageType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserMessageBase) GetCreatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.CreatedAt
}

func (u *UserMessageBase) GetUpdatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.UpdatedAt
}

func (u *UserMessageBase) GetUserID() *EntityIDBase {
	if u == nil {
		return nil
	}
	return u.UserID
}

func (u *UserMessageBase) GetText() string {
	if u == nil {
		return ""
	}
	return u.Text
}

func (u *UserMessageBase) GetUserMessageType() UserConversationMessageType {
	if u == nil {
		return ""
	}
	return u.UserMessageType
}

func (u *UserMessageBase) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserMessageBase) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessageBase) SetCreatedAt(createdAt *time.Time) {
	u.CreatedAt = createdAt
	u.require(userMessageBaseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessageBase) SetUpdatedAt(updatedAt *time.Time) {
	u.UpdatedAt = updatedAt
	u.require(userMessageBaseFieldUpdatedAt)
}

// SetUserID sets the UserID field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessageBase) SetUserID(userID *EntityIDBase) {
	u.UserID = userID
	u.require(userMessageBaseFieldUserID)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessageBase) SetText(text string) {
	u.Text = text
	u.require(userMessageBaseFieldText)
}

// SetUserMessageType sets the UserMessageType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessageBase) SetUserMessageType(userMessageType UserConversationMessageType) {
	u.UserMessageType = userMessageType
	u.require(userMessageBaseFieldUserMessageType)
}

func (u *UserMessageBase) UnmarshalJSON(data []byte) error {
	type embed UserMessageBase
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserMessageBase(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	u.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserMessageBase) MarshalJSON() ([]byte, error) {
	type embed UserMessageBase
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*u),
		CreatedAt: internal.NewOptionalDateTime(u.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(u.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserMessageBase) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserMessageResponseState string

const (
	UserMessageResponseStateNotAsked    UserMessageResponseState = "NOT_ASKED"
	UserMessageResponseStateLlmEnabled  UserMessageResponseState = "LLM_ENABLED"
	UserMessageResponseStateLlmDisabled UserMessageResponseState = "LLM_DISABLED"
)

func NewUserMessageResponseStateFromString(s string) (UserMessageResponseState, error) {
	switch s {
	case "NOT_ASKED":
		return UserMessageResponseStateNotAsked, nil
	case "LLM_ENABLED":
		return UserMessageResponseStateLlmEnabled, nil
	case "LLM_DISABLED":
		return UserMessageResponseStateLlmDisabled, nil
	}
	var t UserMessageResponseState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UserMessageResponseState) Ptr() *UserMessageResponseState {
	return &u
}

type VisibilityType string

const (
	VisibilityTypeVisible          VisibilityType = "VISIBLE"
	VisibilityTypePartiallyVisible VisibilityType = "PARTIALLY_VISIBLE"
	VisibilityTypeHidden           VisibilityType = "HIDDEN"
)

func NewVisibilityTypeFromString(s string) (VisibilityType, error) {
	switch s {
	case "VISIBLE":
		return VisibilityTypeVisible, nil
	case "PARTIALLY_VISIBLE":
		return VisibilityTypePartiallyVisible, nil
	case "HIDDEN":
		return VisibilityTypeHidden, nil
	}
	var t VisibilityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VisibilityType) Ptr() *VisibilityType {
	return &v
}
