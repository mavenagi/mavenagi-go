// Code generated by Fern. DO NOT EDIT.

package api

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/mavenagi/mavenagi-go/internal"
	big "math/big"
	time "time"
)

var (
	actionBaseFieldName                    = big.NewInt(1 << 0)
	actionBaseFieldDescription             = big.NewInt(1 << 1)
	actionBaseFieldUserInteractionRequired = big.NewInt(1 << 2)
	actionBaseFieldButtonName              = big.NewInt(1 << 3)
	actionBaseFieldPrecondition            = big.NewInt(1 << 4)
	actionBaseFieldUserFormParameters      = big.NewInt(1 << 5)
	actionBaseFieldLanguage                = big.NewInt(1 << 6)
)

type ActionBase struct {
	// The name of the action. This is displayed to the end user as part of forms when user interaction is required. It is also used to help Maven decide if the action is relevant to a conversation.
	Name string `json:"name" url:"name"`
	// The description of the action. Must be less than 1024 characters. This helps Maven decide if the action is relevant to a conversation and is not displayed directly to the end user. Descriptions are used by the LLM.
	Description string `json:"description" url:"description"`
	// Whether the action requires user interaction to execute. If false, and all of the required action parameters are known, the LLM may call the action automatically. If true, an conversations ask call will return a BotActionFormResponse which must be submitted by an API caller. API callers must display a button with the buttonName label to confirm the user's intent.
	UserInteractionRequired bool `json:"userInteractionRequired" url:"userInteractionRequired"`
	// When user interaction is required, the name of the button that is shown to the end user to confirm execution of the action. Defaults to "Submit" if not supplied.
	ButtonName *string `json:"buttonName,omitempty" url:"buttonName,omitempty"`
	// The preconditions that must be met for an action to be relevant to a conversation. Can be used to restrict actions to certain types of users.
	Precondition *Precondition `json:"precondition,omitempty" url:"precondition,omitempty"`
	// The parameters that the action uses as input. An action will only be executed when all of the required parameters are provided. During execution, actions all have access to the full Conversation and User objects. Parameter values may be inferred from the user's conversation by the LLM.
	UserFormParameters []*ActionParameter `json:"userFormParameters" url:"userFormParameters"`
	// The ISO 639-1 code for the language used in all fields of this action. Will be derived using the description's text if not specified.
	Language *string `json:"language,omitempty" url:"language,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionBase) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *ActionBase) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ActionBase) GetUserInteractionRequired() bool {
	if a == nil {
		return false
	}
	return a.UserInteractionRequired
}

func (a *ActionBase) GetButtonName() *string {
	if a == nil {
		return nil
	}
	return a.ButtonName
}

func (a *ActionBase) GetPrecondition() *Precondition {
	if a == nil {
		return nil
	}
	return a.Precondition
}

func (a *ActionBase) GetUserFormParameters() []*ActionParameter {
	if a == nil {
		return nil
	}
	return a.UserFormParameters
}

func (a *ActionBase) GetLanguage() *string {
	if a == nil {
		return nil
	}
	return a.Language
}

func (a *ActionBase) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionBase) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetName(name string) {
	a.Name = name
	a.require(actionBaseFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetDescription(description string) {
	a.Description = description
	a.require(actionBaseFieldDescription)
}

// SetUserInteractionRequired sets the UserInteractionRequired field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetUserInteractionRequired(userInteractionRequired bool) {
	a.UserInteractionRequired = userInteractionRequired
	a.require(actionBaseFieldUserInteractionRequired)
}

// SetButtonName sets the ButtonName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetButtonName(buttonName *string) {
	a.ButtonName = buttonName
	a.require(actionBaseFieldButtonName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetPrecondition(precondition *Precondition) {
	a.Precondition = precondition
	a.require(actionBaseFieldPrecondition)
}

// SetUserFormParameters sets the UserFormParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetUserFormParameters(userFormParameters []*ActionParameter) {
	a.UserFormParameters = userFormParameters
	a.require(actionBaseFieldUserFormParameters)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionBase) SetLanguage(language *string) {
	a.Language = language
	a.require(actionBaseFieldLanguage)
}

func (a *ActionBase) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionBase) MarshalJSON() ([]byte, error) {
	type embed ActionBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionBase) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	actionEnumOptionFieldLabel = big.NewInt(1 << 0)
	actionEnumOptionFieldValue = big.NewInt(1 << 1)
)

type ActionEnumOption struct {
	// Will be shown during form display as the user facing string in a dropdown or radio.
	Label string `json:"label" url:"label"`
	// A valid value for the field.
	Value interface{} `json:"value" url:"value"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionEnumOption) GetLabel() string {
	if a == nil {
		return ""
	}
	return a.Label
}

func (a *ActionEnumOption) GetValue() interface{} {
	if a == nil {
		return nil
	}
	return a.Value
}

func (a *ActionEnumOption) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionEnumOption) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionEnumOption) SetLabel(label string) {
	a.Label = label
	a.require(actionEnumOptionFieldLabel)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionEnumOption) SetValue(value interface{}) {
	a.Value = value
	a.require(actionEnumOptionFieldValue)
}

func (a *ActionEnumOption) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionEnumOption
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionEnumOption(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionEnumOption) MarshalJSON() ([]byte, error) {
	type embed ActionEnumOption
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionEnumOption) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionExecutionParamValue struct {
	ValueType  string
	Primitive  interface{}
	Attachment *AttachmentResponse
}

func (a *ActionExecutionParamValue) GetValueType() string {
	if a == nil {
		return ""
	}
	return a.ValueType
}

func (a *ActionExecutionParamValue) GetPrimitive() interface{} {
	if a == nil {
		return nil
	}
	return a.Primitive
}

func (a *ActionExecutionParamValue) GetAttachment() *AttachmentResponse {
	if a == nil {
		return nil
	}
	return a.Attachment
}

func (a *ActionExecutionParamValue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ValueType string `json:"valueType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	a.ValueType = unmarshaler.ValueType
	if unmarshaler.ValueType == "" {
		return fmt.Errorf("%T did not include discriminant valueType", a)
	}
	switch unmarshaler.ValueType {
	case "primitive":
		var valueUnmarshaler struct {
			Primitive interface{} `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		a.Primitive = valueUnmarshaler.Primitive
	case "attachment":
		value := new(AttachmentResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		a.Attachment = value
	}
	return nil
}

func (a ActionExecutionParamValue) MarshalJSON() ([]byte, error) {
	if err := a.validate(); err != nil {
		return nil, err
	}
	if a.Primitive != nil {
		var marshaler = struct {
			ValueType string      `json:"valueType"`
			Primitive interface{} `json:"value"`
		}{
			ValueType: "primitive",
			Primitive: a.Primitive,
		}
		return json.Marshal(marshaler)
	}
	if a.Attachment != nil {
		return internal.MarshalJSONWithExtraProperty(a.Attachment, "valueType", "attachment")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", a)
}

type ActionExecutionParamValueVisitor interface {
	VisitPrimitive(interface{}) error
	VisitAttachment(*AttachmentResponse) error
}

func (a *ActionExecutionParamValue) Accept(visitor ActionExecutionParamValueVisitor) error {
	if a.Primitive != nil {
		return visitor.VisitPrimitive(a.Primitive)
	}
	if a.Attachment != nil {
		return visitor.VisitAttachment(a.Attachment)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", a)
}

func (a *ActionExecutionParamValue) validate() error {
	if a == nil {
		return fmt.Errorf("type %T is nil", a)
	}
	var fields []string
	if a.Primitive != nil {
		fields = append(fields, "primitive")
	}
	if a.Attachment != nil {
		fields = append(fields, "attachment")
	}
	if len(fields) == 0 {
		if a.ValueType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", a, a.ValueType)
		}
		return fmt.Errorf("type %T is empty", a)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", a, fields)
	}
	if a.ValueType != "" {
		field := fields[0]
		if a.ValueType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				a,
				a.ValueType,
				a,
			)
		}
	}
	return nil
}

var (
	actionFormFieldFieldId          = big.NewInt(1 << 0)
	actionFormFieldFieldLabel       = big.NewInt(1 << 1)
	actionFormFieldFieldDescription = big.NewInt(1 << 2)
	actionFormFieldFieldRequired    = big.NewInt(1 << 3)
	actionFormFieldFieldSuggestion  = big.NewInt(1 << 4)
	actionFormFieldFieldType        = big.NewInt(1 << 5)
	actionFormFieldFieldEnumOptions = big.NewInt(1 << 6)
)

type ActionFormField struct {
	// The ID field should be used as the key in the `submitActionForm` API.
	Id string `json:"id" url:"id"`
	// The title of the field to show on the form. Provided in the user's language.
	Label string `json:"label" url:"label"`
	// A longer description of the field which should be shown in smaller text near the label. Provided in the user's language.
	Description string `json:"description" url:"description"`
	// Whether the field is required for the action. Client side validation is recommended for an improved user experience.
	Required bool `json:"required" url:"required"`
	// A value for the field provided by the LLM. All form fields should default to this value if present.
	Suggestion interface{} `json:"suggestion,omitempty" url:"suggestion,omitempty"`
	// Describes how the action field should be validated. Client side validation is recommended but not required. | If `enumOptions` are provided, using a dropdown or radio field is preferred. Otherwise, if the `type` is `BOOLEAN` a checkbox is preferred. | Fallback to a text input.
	Type ActionParameterType `json:"type" url:"type"`
	// The options that should be shown to the user as a dropdown or radio.
	EnumOptions []*ActionEnumOption `json:"enumOptions,omitempty" url:"enumOptions,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionFormField) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *ActionFormField) GetLabel() string {
	if a == nil {
		return ""
	}
	return a.Label
}

func (a *ActionFormField) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ActionFormField) GetRequired() bool {
	if a == nil {
		return false
	}
	return a.Required
}

func (a *ActionFormField) GetSuggestion() interface{} {
	if a == nil {
		return nil
	}
	return a.Suggestion
}

func (a *ActionFormField) GetType() ActionParameterType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *ActionFormField) GetEnumOptions() []*ActionEnumOption {
	if a == nil {
		return nil
	}
	return a.EnumOptions
}

func (a *ActionFormField) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionFormField) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetId(id string) {
	a.Id = id
	a.require(actionFormFieldFieldId)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetLabel(label string) {
	a.Label = label
	a.require(actionFormFieldFieldLabel)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetDescription(description string) {
	a.Description = description
	a.require(actionFormFieldFieldDescription)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetRequired(required bool) {
	a.Required = required
	a.require(actionFormFieldFieldRequired)
}

// SetSuggestion sets the Suggestion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetSuggestion(suggestion interface{}) {
	a.Suggestion = suggestion
	a.require(actionFormFieldFieldSuggestion)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetType(type_ ActionParameterType) {
	a.Type = type_
	a.require(actionFormFieldFieldType)
}

// SetEnumOptions sets the EnumOptions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionFormField) SetEnumOptions(enumOptions []*ActionEnumOption) {
	a.EnumOptions = enumOptions
	a.require(actionFormFieldFieldEnumOptions)
}

func (a *ActionFormField) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionFormField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionFormField(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionFormField) MarshalJSON() ([]byte, error) {
	type embed ActionFormField
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionFormField) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	actionOAuthConfigurationFieldAuthorizationUrl = big.NewInt(1 << 0)
	actionOAuthConfigurationFieldTokenUrl         = big.NewInt(1 << 1)
	actionOAuthConfigurationFieldClientId         = big.NewInt(1 << 2)
	actionOAuthConfigurationFieldClientSecret     = big.NewInt(1 << 3)
	actionOAuthConfigurationFieldScopes           = big.NewInt(1 << 4)
	actionOAuthConfigurationFieldExtraAuthParams  = big.NewInt(1 << 5)
	actionOAuthConfigurationFieldExtraTokenParams = big.NewInt(1 << 6)
)

type ActionOAuthConfiguration struct {
	AuthorizationUrl string            `json:"authorizationUrl" url:"authorizationUrl"`
	TokenUrl         string            `json:"tokenUrl" url:"tokenUrl"`
	ClientId         string            `json:"clientId" url:"clientId"`
	ClientSecret     string            `json:"clientSecret" url:"clientSecret"`
	Scopes           []string          `json:"scopes" url:"scopes"`
	ExtraAuthParams  map[string]string `json:"extraAuthParams,omitempty" url:"extraAuthParams,omitempty"`
	ExtraTokenParams map[string]string `json:"extraTokenParams,omitempty" url:"extraTokenParams,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionOAuthConfiguration) GetAuthorizationUrl() string {
	if a == nil {
		return ""
	}
	return a.AuthorizationUrl
}

func (a *ActionOAuthConfiguration) GetTokenUrl() string {
	if a == nil {
		return ""
	}
	return a.TokenUrl
}

func (a *ActionOAuthConfiguration) GetClientId() string {
	if a == nil {
		return ""
	}
	return a.ClientId
}

func (a *ActionOAuthConfiguration) GetClientSecret() string {
	if a == nil {
		return ""
	}
	return a.ClientSecret
}

func (a *ActionOAuthConfiguration) GetScopes() []string {
	if a == nil {
		return nil
	}
	return a.Scopes
}

func (a *ActionOAuthConfiguration) GetExtraAuthParams() map[string]string {
	if a == nil {
		return nil
	}
	return a.ExtraAuthParams
}

func (a *ActionOAuthConfiguration) GetExtraTokenParams() map[string]string {
	if a == nil {
		return nil
	}
	return a.ExtraTokenParams
}

func (a *ActionOAuthConfiguration) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionOAuthConfiguration) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetAuthorizationUrl sets the AuthorizationUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetAuthorizationUrl(authorizationUrl string) {
	a.AuthorizationUrl = authorizationUrl
	a.require(actionOAuthConfigurationFieldAuthorizationUrl)
}

// SetTokenUrl sets the TokenUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetTokenUrl(tokenUrl string) {
	a.TokenUrl = tokenUrl
	a.require(actionOAuthConfigurationFieldTokenUrl)
}

// SetClientId sets the ClientId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetClientId(clientId string) {
	a.ClientId = clientId
	a.require(actionOAuthConfigurationFieldClientId)
}

// SetClientSecret sets the ClientSecret field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetClientSecret(clientSecret string) {
	a.ClientSecret = clientSecret
	a.require(actionOAuthConfigurationFieldClientSecret)
}

// SetScopes sets the Scopes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetScopes(scopes []string) {
	a.Scopes = scopes
	a.require(actionOAuthConfigurationFieldScopes)
}

// SetExtraAuthParams sets the ExtraAuthParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetExtraAuthParams(extraAuthParams map[string]string) {
	a.ExtraAuthParams = extraAuthParams
	a.require(actionOAuthConfigurationFieldExtraAuthParams)
}

// SetExtraTokenParams sets the ExtraTokenParams field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionOAuthConfiguration) SetExtraTokenParams(extraTokenParams map[string]string) {
	a.ExtraTokenParams = extraTokenParams
	a.require(actionOAuthConfigurationFieldExtraTokenParams)
}

func (a *ActionOAuthConfiguration) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionOAuthConfiguration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionOAuthConfiguration(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionOAuthConfiguration) MarshalJSON() ([]byte, error) {
	type embed ActionOAuthConfiguration
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionOAuthConfiguration) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	actionParameterFieldId                 = big.NewInt(1 << 0)
	actionParameterFieldLabel              = big.NewInt(1 << 1)
	actionParameterFieldDescription        = big.NewInt(1 << 2)
	actionParameterFieldRequired           = big.NewInt(1 << 3)
	actionParameterFieldHidden             = big.NewInt(1 << 4)
	actionParameterFieldType               = big.NewInt(1 << 5)
	actionParameterFieldEnumOptions        = big.NewInt(1 << 6)
	actionParameterFieldSchema             = big.NewInt(1 << 7)
	actionParameterFieldOauthConfiguration = big.NewInt(1 << 8)
)

type ActionParameter struct {
	// The ID field will be used when parameters are supplied to `executeAction`.
	Id string `json:"id" url:"id"`
	// The title of the field that will be shown on action forms.
	Label string `json:"label" url:"label"`
	// A longer description of the field which will be shown in smaller text near the label on action forms.
	Description string `json:"description" url:"description"`
	// Whether the field is required for action execution.
	Required bool `json:"required" url:"required"`
	// When user interaction is required, whether this parameter should be excluded from forms. Hidden parameters are not displayed to users but their values are still populated by the LLM and sent to actions. Defaults to false.
	Hidden *bool `json:"hidden,omitempty" url:"hidden,omitempty"`
	// The parameter type. Values provided to `executeAction` will conform to this type. Defaults to `STRING`.
	Type *ActionParameterType `json:"type,omitempty" url:"type,omitempty"`
	// Restricts the action parameter to only the options in this list. Valid for type `STRING`, `BOOLEAN`, and `NUMBER`. Should not be used when type is `SCHEMA`.
	EnumOptions []*ActionEnumOption `json:"enumOptions,omitempty" url:"enumOptions,omitempty"`
	// JSON schema for validating the parameter value. Only valid when type is `SCHEMA`.
	//
	// **Schema Requirements:**
	// - Root type must be "object" - The top-level schema must define an object type
	// - Supported types: string, number, boolean, integer, object, array, enum, anyOf
	// - Unsupported features: oneOf, allOf, const, not, if/then/else, pattern, maxLength, minLength
	// - Required fields: All fields must be required (no optional properties)
	// - Additional properties: Must be set to false
	//
	// **Limits:**
	// - Maximum nesting depth: 5 levels
	// - Maximum total properties: 100
	// - Maximum total string length: 15,000 characters
	// - Maximum total enum values: 500
	Schema *string `json:"schema,omitempty" url:"schema,omitempty"`
	// OAuth configuration required to start an OAuth authorization flow when this parameter's type is `OAUTH`.
	OauthConfiguration *ActionOAuthConfiguration `json:"oauthConfiguration,omitempty" url:"oauthConfiguration,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionParameter) GetId() string {
	if a == nil {
		return ""
	}
	return a.Id
}

func (a *ActionParameter) GetLabel() string {
	if a == nil {
		return ""
	}
	return a.Label
}

func (a *ActionParameter) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ActionParameter) GetRequired() bool {
	if a == nil {
		return false
	}
	return a.Required
}

func (a *ActionParameter) GetHidden() *bool {
	if a == nil {
		return nil
	}
	return a.Hidden
}

func (a *ActionParameter) GetType() *ActionParameterType {
	if a == nil {
		return nil
	}
	return a.Type
}

func (a *ActionParameter) GetEnumOptions() []*ActionEnumOption {
	if a == nil {
		return nil
	}
	return a.EnumOptions
}

func (a *ActionParameter) GetSchema() *string {
	if a == nil {
		return nil
	}
	return a.Schema
}

func (a *ActionParameter) GetOauthConfiguration() *ActionOAuthConfiguration {
	if a == nil {
		return nil
	}
	return a.OauthConfiguration
}

func (a *ActionParameter) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionParameter) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetId(id string) {
	a.Id = id
	a.require(actionParameterFieldId)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetLabel(label string) {
	a.Label = label
	a.require(actionParameterFieldLabel)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetDescription(description string) {
	a.Description = description
	a.require(actionParameterFieldDescription)
}

// SetRequired sets the Required field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetRequired(required bool) {
	a.Required = required
	a.require(actionParameterFieldRequired)
}

// SetHidden sets the Hidden field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetHidden(hidden *bool) {
	a.Hidden = hidden
	a.require(actionParameterFieldHidden)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetType(type_ *ActionParameterType) {
	a.Type = type_
	a.require(actionParameterFieldType)
}

// SetEnumOptions sets the EnumOptions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetEnumOptions(enumOptions []*ActionEnumOption) {
	a.EnumOptions = enumOptions
	a.require(actionParameterFieldEnumOptions)
}

// SetSchema sets the Schema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetSchema(schema *string) {
	a.Schema = schema
	a.require(actionParameterFieldSchema)
}

// SetOauthConfiguration sets the OauthConfiguration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionParameter) SetOauthConfiguration(oauthConfiguration *ActionOAuthConfiguration) {
	a.OauthConfiguration = oauthConfiguration
	a.require(actionParameterFieldOauthConfiguration)
}

func (a *ActionParameter) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionParameter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionParameter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionParameter) MarshalJSON() ([]byte, error) {
	type embed ActionParameter
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionParameter) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ActionParameterType string

const (
	// String parameter type for text input.
	ActionParameterTypeString ActionParameterType = "STRING"
	// A long string parameter type for text input. Will be rendered as a textarea when used in a form.
	ActionParameterTypeMultiline ActionParameterType = "MULTILINE"
	// Boolean parameter type for true/false values.
	ActionParameterTypeBoolean ActionParameterType = "BOOLEAN"
	// Number parameter type for numeric values.
	ActionParameterTypeNumber ActionParameterType = "NUMBER"
	// Date-time parameter type (ISO-8601, e.g. 2018-11-13T20:20:39Z)
	ActionParameterTypeDatetime ActionParameterType = "DATETIME"
	// Date parameter type (ISO-8601, e.g. 2018-11-13)
	ActionParameterTypeDate ActionParameterType = "DATE"
	// Time parameter type (ISO-8601, e.g. 20:20:39)
	ActionParameterTypeTime ActionParameterType = "TIME"
	// Email parameter type; must be a valid email address
	ActionParameterTypeEmail ActionParameterType = "EMAIL"
	// Schema parameter type for complex structured data that adheres to a JSON schema definition. When this type is used this should be the only action parameter (all other parameters should be omitted), the `schema` field must be set and `enumOptions` should not be used.
	ActionParameterTypeSchema ActionParameterType = "SCHEMA"
	// File parameter type for file uploads.
	ActionParameterTypeFile ActionParameterType = "FILE"
	// OAuth authorization parameter type used to pass an access token at execution time. When this type is used it should be the only action parameter. This parameter is not sent to the LLM or shown on forms.
	ActionParameterTypeOauth ActionParameterType = "OAUTH"
)

func NewActionParameterTypeFromString(s string) (ActionParameterType, error) {
	switch s {
	case "STRING":
		return ActionParameterTypeString, nil
	case "MULTILINE":
		return ActionParameterTypeMultiline, nil
	case "BOOLEAN":
		return ActionParameterTypeBoolean, nil
	case "NUMBER":
		return ActionParameterTypeNumber, nil
	case "DATETIME":
		return ActionParameterTypeDatetime, nil
	case "DATE":
		return ActionParameterTypeDate, nil
	case "TIME":
		return ActionParameterTypeTime, nil
	case "EMAIL":
		return ActionParameterTypeEmail, nil
	case "SCHEMA":
		return ActionParameterTypeSchema, nil
	case "FILE":
		return ActionParameterTypeFile, nil
	case "OAUTH":
		return ActionParameterTypeOauth, nil
	}
	var t ActionParameterType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a ActionParameterType) Ptr() *ActionParameterType {
	return &a
}

var (
	actionResponseFieldName                    = big.NewInt(1 << 0)
	actionResponseFieldDescription             = big.NewInt(1 << 1)
	actionResponseFieldUserInteractionRequired = big.NewInt(1 << 2)
	actionResponseFieldButtonName              = big.NewInt(1 << 3)
	actionResponseFieldPrecondition            = big.NewInt(1 << 4)
	actionResponseFieldUserFormParameters      = big.NewInt(1 << 5)
	actionResponseFieldLanguage                = big.NewInt(1 << 6)
	actionResponseFieldActionId                = big.NewInt(1 << 7)
	actionResponseFieldInstructions            = big.NewInt(1 << 8)
	actionResponseFieldLlmInclusionStatus      = big.NewInt(1 << 9)
	actionResponseFieldSegmentId               = big.NewInt(1 << 10)
	actionResponseFieldPreconditionExplanation = big.NewInt(1 << 11)
	actionResponseFieldDeleted                 = big.NewInt(1 << 12)
)

type ActionResponse struct {
	// The name of the action. This is displayed to the end user as part of forms when user interaction is required. It is also used to help Maven decide if the action is relevant to a conversation.
	Name string `json:"name" url:"name"`
	// The description of the action. Must be less than 1024 characters. This helps Maven decide if the action is relevant to a conversation and is not displayed directly to the end user. Descriptions are used by the LLM.
	Description string `json:"description" url:"description"`
	// Whether the action requires user interaction to execute. If false, and all of the required action parameters are known, the LLM may call the action automatically. If true, an conversations ask call will return a BotActionFormResponse which must be submitted by an API caller. API callers must display a button with the buttonName label to confirm the user's intent.
	UserInteractionRequired bool `json:"userInteractionRequired" url:"userInteractionRequired"`
	// When user interaction is required, the name of the button that is shown to the end user to confirm execution of the action. Defaults to "Submit" if not supplied.
	ButtonName *string `json:"buttonName,omitempty" url:"buttonName,omitempty"`
	// The preconditions that must be met for an action to be relevant to a conversation. Can be used to restrict actions to certain types of users.
	Precondition *Precondition `json:"precondition,omitempty" url:"precondition,omitempty"`
	// The parameters that the action uses as input. An action will only be executed when all of the required parameters are provided. During execution, actions all have access to the full Conversation and User objects. Parameter values may be inferred from the user's conversation by the LLM.
	UserFormParameters []*ActionParameter `json:"userFormParameters" url:"userFormParameters"`
	// The ISO 639-1 code for the language used in all fields of this action. Will be derived using the description's text if not specified.
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// ID that uniquely identifies this action
	ActionId *EntityId `json:"actionId" url:"actionId"`
	// The instructions given to the LLM when determining whether to execute the action.
	// This field defaults to the `description` field if not provided. Use the `patch` API to update.
	Instructions *string `json:"instructions,omitempty" url:"instructions,omitempty"`
	// Determines whether the action is sent to the LLM as part of a conversation.
	//
	// - `ALWAYS`: The action is always available for use in conversations, textual relevance is not considered.
	// - `WHEN_RELEVANT`: The action is available only in conversations where the action is determined to be relevant to the user's question.
	// - `NEVER`: The action is not available for use in conversations.
	LlmInclusionStatus LlmInclusionStatus `json:"llmInclusionStatus" url:"llmInclusionStatus"`
	// The IDs of the segment that must be matched for the action to be relevant to a conversation.
	// Segments are replacing inline preconditions - an Action may not have both an inline precondition and a segment.
	// Inline precondition support will be removed in a future release.
	SegmentId *EntityId `json:"segmentId,omitempty" url:"segmentId,omitempty"`
	// A human-readable explanation of the precondition associated with this action, if present.
	PreconditionExplanation *string `json:"preconditionExplanation,omitempty" url:"preconditionExplanation,omitempty"`
	// Whether the action has been deleted. Deleted actions will not sent to the LLM nor returned in search results.
	Deleted bool `json:"deleted" url:"deleted"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *ActionResponse) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *ActionResponse) GetDescription() string {
	if a == nil {
		return ""
	}
	return a.Description
}

func (a *ActionResponse) GetUserInteractionRequired() bool {
	if a == nil {
		return false
	}
	return a.UserInteractionRequired
}

func (a *ActionResponse) GetButtonName() *string {
	if a == nil {
		return nil
	}
	return a.ButtonName
}

func (a *ActionResponse) GetPrecondition() *Precondition {
	if a == nil {
		return nil
	}
	return a.Precondition
}

func (a *ActionResponse) GetUserFormParameters() []*ActionParameter {
	if a == nil {
		return nil
	}
	return a.UserFormParameters
}

func (a *ActionResponse) GetLanguage() *string {
	if a == nil {
		return nil
	}
	return a.Language
}

func (a *ActionResponse) GetActionId() *EntityId {
	if a == nil {
		return nil
	}
	return a.ActionId
}

func (a *ActionResponse) GetInstructions() *string {
	if a == nil {
		return nil
	}
	return a.Instructions
}

func (a *ActionResponse) GetLlmInclusionStatus() LlmInclusionStatus {
	if a == nil {
		return ""
	}
	return a.LlmInclusionStatus
}

func (a *ActionResponse) GetSegmentId() *EntityId {
	if a == nil {
		return nil
	}
	return a.SegmentId
}

func (a *ActionResponse) GetPreconditionExplanation() *string {
	if a == nil {
		return nil
	}
	return a.PreconditionExplanation
}

func (a *ActionResponse) GetDeleted() bool {
	if a == nil {
		return false
	}
	return a.Deleted
}

func (a *ActionResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *ActionResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetName(name string) {
	a.Name = name
	a.require(actionResponseFieldName)
}

// SetDescription sets the Description field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetDescription(description string) {
	a.Description = description
	a.require(actionResponseFieldDescription)
}

// SetUserInteractionRequired sets the UserInteractionRequired field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetUserInteractionRequired(userInteractionRequired bool) {
	a.UserInteractionRequired = userInteractionRequired
	a.require(actionResponseFieldUserInteractionRequired)
}

// SetButtonName sets the ButtonName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetButtonName(buttonName *string) {
	a.ButtonName = buttonName
	a.require(actionResponseFieldButtonName)
}

// SetPrecondition sets the Precondition field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetPrecondition(precondition *Precondition) {
	a.Precondition = precondition
	a.require(actionResponseFieldPrecondition)
}

// SetUserFormParameters sets the UserFormParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetUserFormParameters(userFormParameters []*ActionParameter) {
	a.UserFormParameters = userFormParameters
	a.require(actionResponseFieldUserFormParameters)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetLanguage(language *string) {
	a.Language = language
	a.require(actionResponseFieldLanguage)
}

// SetActionId sets the ActionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetActionId(actionId *EntityId) {
	a.ActionId = actionId
	a.require(actionResponseFieldActionId)
}

// SetInstructions sets the Instructions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetInstructions(instructions *string) {
	a.Instructions = instructions
	a.require(actionResponseFieldInstructions)
}

// SetLlmInclusionStatus sets the LlmInclusionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetLlmInclusionStatus(llmInclusionStatus LlmInclusionStatus) {
	a.LlmInclusionStatus = llmInclusionStatus
	a.require(actionResponseFieldLlmInclusionStatus)
}

// SetSegmentId sets the SegmentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetSegmentId(segmentId *EntityId) {
	a.SegmentId = segmentId
	a.require(actionResponseFieldSegmentId)
}

// SetPreconditionExplanation sets the PreconditionExplanation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetPreconditionExplanation(preconditionExplanation *string) {
	a.PreconditionExplanation = preconditionExplanation
	a.require(actionResponseFieldPreconditionExplanation)
}

// SetDeleted sets the Deleted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *ActionResponse) SetDeleted(deleted bool) {
	a.Deleted = deleted
	a.require(actionResponseFieldDeleted)
}

func (a *ActionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ActionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ActionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *ActionResponse) MarshalJSON() ([]byte, error) {
	type embed ActionResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *ActionResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	appPreconditionFieldOperator = big.NewInt(1 << 0)
	appPreconditionFieldAppId    = big.NewInt(1 << 1)
)

type AppPrecondition struct {
	// Operator to apply to this precondition
	Operator *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`
	// Match only conversations created by this appId
	AppId string `json:"appId" url:"appId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AppPrecondition) GetOperator() *PreconditionOperator {
	if a == nil {
		return nil
	}
	return a.Operator
}

func (a *AppPrecondition) GetAppId() string {
	if a == nil {
		return ""
	}
	return a.AppId
}

func (a *AppPrecondition) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppPrecondition) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppPrecondition) SetOperator(operator *PreconditionOperator) {
	a.Operator = operator
	a.require(appPreconditionFieldOperator)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppPrecondition) SetAppId(appId string) {
	a.AppId = appId
	a.require(appPreconditionFieldAppId)
}

func (a *AppPrecondition) UnmarshalJSON(data []byte) error {
	type unmarshaler AppPrecondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppPrecondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppPrecondition) MarshalJSON() ([]byte, error) {
	type embed AppPrecondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AppPrecondition) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	appUserFieldIdentifiers = big.NewInt(1 << 0)
	appUserFieldData        = big.NewInt(1 << 1)
)

type AppUser struct {
	// Used to determine whether two users from different apps are the same
	Identifiers []*AppUserIdentifier `json:"identifiers" url:"identifiers"`
	Data        map[string]*UserData `json:"data" url:"data"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AppUser) GetIdentifiers() []*AppUserIdentifier {
	if a == nil {
		return nil
	}
	return a.Identifiers
}

func (a *AppUser) GetData() map[string]*UserData {
	if a == nil {
		return nil
	}
	return a.Data
}

func (a *AppUser) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppUser) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetIdentifiers sets the Identifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUser) SetIdentifiers(identifiers []*AppUserIdentifier) {
	a.Identifiers = identifiers
	a.require(appUserFieldIdentifiers)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUser) SetData(data map[string]*UserData) {
	a.Data = data
	a.require(appUserFieldData)
}

func (a *AppUser) UnmarshalJSON(data []byte) error {
	type unmarshaler AppUser
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppUser(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppUser) MarshalJSON() ([]byte, error) {
	type embed AppUser
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AppUser) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	appUserIdentifierFieldValue = big.NewInt(1 << 0)
	appUserIdentifierFieldType  = big.NewInt(1 << 1)
)

type AppUserIdentifier struct {
	// The identifying property text
	Value string                         `json:"value" url:"value"`
	Type  AppUserIdentifyingPropertyType `json:"type" url:"type"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AppUserIdentifier) GetValue() string {
	if a == nil {
		return ""
	}
	return a.Value
}

func (a *AppUserIdentifier) GetType() AppUserIdentifyingPropertyType {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AppUserIdentifier) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppUserIdentifier) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserIdentifier) SetValue(value string) {
	a.Value = value
	a.require(appUserIdentifierFieldValue)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserIdentifier) SetType(type_ AppUserIdentifyingPropertyType) {
	a.Type = type_
	a.require(appUserIdentifierFieldType)
}

func (a *AppUserIdentifier) UnmarshalJSON(data []byte) error {
	type unmarshaler AppUserIdentifier
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppUserIdentifier(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppUserIdentifier) MarshalJSON() ([]byte, error) {
	type embed AppUserIdentifier
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AppUserIdentifier) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AppUserIdentifyingPropertyType string

const (
	AppUserIdentifyingPropertyTypeEmail       AppUserIdentifyingPropertyType = "EMAIL"
	AppUserIdentifyingPropertyTypePhoneNumber AppUserIdentifyingPropertyType = "PHONE_NUMBER"
)

func NewAppUserIdentifyingPropertyTypeFromString(s string) (AppUserIdentifyingPropertyType, error) {
	switch s {
	case "EMAIL":
		return AppUserIdentifyingPropertyTypeEmail, nil
	case "PHONE_NUMBER":
		return AppUserIdentifyingPropertyTypePhoneNumber, nil
	}
	var t AppUserIdentifyingPropertyType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AppUserIdentifyingPropertyType) Ptr() *AppUserIdentifyingPropertyType {
	return &a
}

var (
	appUserRequestFieldIdentifiers = big.NewInt(1 << 0)
	appUserRequestFieldData        = big.NewInt(1 << 1)
	appUserRequestFieldUserId      = big.NewInt(1 << 2)
)

type AppUserRequest struct {
	// Used to determine whether two users from different apps are the same
	Identifiers []*AppUserIdentifier `json:"identifiers" url:"identifiers"`
	Data        map[string]*UserData `json:"data" url:"data"`
	// ID that uniquely identifies this app user
	UserId *EntityIdBase `json:"userId" url:"userId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AppUserRequest) GetIdentifiers() []*AppUserIdentifier {
	if a == nil {
		return nil
	}
	return a.Identifiers
}

func (a *AppUserRequest) GetData() map[string]*UserData {
	if a == nil {
		return nil
	}
	return a.Data
}

func (a *AppUserRequest) GetUserId() *EntityIdBase {
	if a == nil {
		return nil
	}
	return a.UserId
}

func (a *AppUserRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppUserRequest) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetIdentifiers sets the Identifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserRequest) SetIdentifiers(identifiers []*AppUserIdentifier) {
	a.Identifiers = identifiers
	a.require(appUserRequestFieldIdentifiers)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserRequest) SetData(data map[string]*UserData) {
	a.Data = data
	a.require(appUserRequestFieldData)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserRequest) SetUserId(userId *EntityIdBase) {
	a.UserId = userId
	a.require(appUserRequestFieldUserId)
}

func (a *AppUserRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AppUserRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppUserRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppUserRequest) MarshalJSON() ([]byte, error) {
	type embed AppUserRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AppUserRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	appUserResponseFieldIdentifiers     = big.NewInt(1 << 0)
	appUserResponseFieldData            = big.NewInt(1 << 1)
	appUserResponseFieldUserId          = big.NewInt(1 << 2)
	appUserResponseFieldAgentUserId     = big.NewInt(1 << 3)
	appUserResponseFieldAllUserData     = big.NewInt(1 << 4)
	appUserResponseFieldDefaultUserData = big.NewInt(1 << 5)
	appUserResponseFieldAgentUserData   = big.NewInt(1 << 6)
)

type AppUserResponse struct {
	// Used to determine whether two users from different apps are the same
	Identifiers []*AppUserIdentifier `json:"identifiers" url:"identifiers"`
	Data        map[string]*UserData `json:"data" url:"data"`
	// ID that uniquely identifies this user
	UserId *EntityId `json:"userId" url:"userId"`
	// The ID of the agent user (merged view) that this app user is associated with
	AgentUserId string `json:"agentUserId" url:"agentUserId"`
	// Data from all apps
	AllUserData map[string]map[string]string `json:"allUserData" url:"allUserData"`
	// Default data for this user
	DefaultUserData map[string]string `json:"defaultUserData" url:"defaultUserData"`
	// All user data for this user, including reverse indexable user data
	AgentUserData map[string][]*UserDataWithReference `json:"agentUserData" url:"agentUserData"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AppUserResponse) GetIdentifiers() []*AppUserIdentifier {
	if a == nil {
		return nil
	}
	return a.Identifiers
}

func (a *AppUserResponse) GetData() map[string]*UserData {
	if a == nil {
		return nil
	}
	return a.Data
}

func (a *AppUserResponse) GetUserId() *EntityId {
	if a == nil {
		return nil
	}
	return a.UserId
}

func (a *AppUserResponse) GetAgentUserId() string {
	if a == nil {
		return ""
	}
	return a.AgentUserId
}

func (a *AppUserResponse) GetAllUserData() map[string]map[string]string {
	if a == nil {
		return nil
	}
	return a.AllUserData
}

func (a *AppUserResponse) GetDefaultUserData() map[string]string {
	if a == nil {
		return nil
	}
	return a.DefaultUserData
}

func (a *AppUserResponse) GetAgentUserData() map[string][]*UserDataWithReference {
	if a == nil {
		return nil
	}
	return a.AgentUserData
}

func (a *AppUserResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AppUserResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetIdentifiers sets the Identifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetIdentifiers(identifiers []*AppUserIdentifier) {
	a.Identifiers = identifiers
	a.require(appUserResponseFieldIdentifiers)
}

// SetData sets the Data field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetData(data map[string]*UserData) {
	a.Data = data
	a.require(appUserResponseFieldData)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetUserId(userId *EntityId) {
	a.UserId = userId
	a.require(appUserResponseFieldUserId)
}

// SetAgentUserId sets the AgentUserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetAgentUserId(agentUserId string) {
	a.AgentUserId = agentUserId
	a.require(appUserResponseFieldAgentUserId)
}

// SetAllUserData sets the AllUserData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetAllUserData(allUserData map[string]map[string]string) {
	a.AllUserData = allUserData
	a.require(appUserResponseFieldAllUserData)
}

// SetDefaultUserData sets the DefaultUserData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetDefaultUserData(defaultUserData map[string]string) {
	a.DefaultUserData = defaultUserData
	a.require(appUserResponseFieldDefaultUserData)
}

// SetAgentUserData sets the AgentUserData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AppUserResponse) SetAgentUserData(agentUserData map[string][]*UserDataWithReference) {
	a.AgentUserData = agentUserData
	a.require(appUserResponseFieldAgentUserData)
}

func (a *AppUserResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AppUserResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AppUserResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AppUserResponse) MarshalJSON() ([]byte, error) {
	type embed AppUserResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AppUserResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// Attachments can be created either with inline data (up to 5MB) using the `content` field or by
// referencing an asynchronously uploaded asset using the `assetId` field.
//
// See the Assets APIs for more details on how to upload assets and get an asset ID.
//
// <Tip>
//
//	Due to backwards compatibility, both the `type` field and the `name` field are present when attaching an Asset by ID.
//	These fields will be ignored in favor of the values supplied during the initial Asset upload.
//	They are only used for inline content uploads.
//
// </Tip>
var (
	attachmentRequestFieldType    = big.NewInt(1 << 0)
	attachmentRequestFieldName    = big.NewInt(1 << 1)
	attachmentRequestFieldContent = big.NewInt(1 << 2)
	attachmentRequestFieldAssetId = big.NewInt(1 << 3)
)

type AttachmentRequest struct {
	// The mime-type of the attachment. Supported types are:
	// - image/jpeg
	// - image/jpg
	// - image/png
	// - image/gif
	// - image/webp
	// - application/pdf
	// - text/plain
	// - text/csv
	// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
	// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
	// - application/vnd.openxmlformats-officedocument.presentationml.presentation
	// - application/msword
	// - application/vnd.ms-excel
	// - application/vnd.ms-powerpoint
	// - audio/aac
	// - audio/mpeg
	// - audio/mp4
	// - audio/wav
	// - audio/ogg
	// - video/mp4
	// - video/webm
	Type string `json:"type" url:"type"`
	// An optional name for the attachment.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// Inline attachment data, up to 5MB.
	Content *[]byte `json:"content,omitempty" url:"content,omitempty"`
	// The ID of an asynchronously uploaded asset.
	AssetId *EntityIdBase `json:"assetId,omitempty" url:"assetId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AttachmentRequest) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AttachmentRequest) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AttachmentRequest) GetContent() *[]byte {
	if a == nil {
		return nil
	}
	return a.Content
}

func (a *AttachmentRequest) GetAssetId() *EntityIdBase {
	if a == nil {
		return nil
	}
	return a.AssetId
}

func (a *AttachmentRequest) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttachmentRequest) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentRequest) SetType(type_ string) {
	a.Type = type_
	a.require(attachmentRequestFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentRequest) SetName(name *string) {
	a.Name = name
	a.require(attachmentRequestFieldName)
}

// SetContent sets the Content field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentRequest) SetContent(content *[]byte) {
	a.Content = content
	a.require(attachmentRequestFieldContent)
}

// SetAssetId sets the AssetId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentRequest) SetAssetId(assetId *EntityIdBase) {
	a.AssetId = assetId
	a.require(attachmentRequestFieldAssetId)
}

func (a *AttachmentRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler AttachmentRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AttachmentRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AttachmentRequest) MarshalJSON() ([]byte, error) {
	type embed AttachmentRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AttachmentRequest) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

var (
	attachmentResponseFieldType      = big.NewInt(1 << 0)
	attachmentResponseFieldName      = big.NewInt(1 << 1)
	attachmentResponseFieldUrl       = big.NewInt(1 << 2)
	attachmentResponseFieldSizeBytes = big.NewInt(1 << 3)
	attachmentResponseFieldStatus    = big.NewInt(1 << 4)
)

type AttachmentResponse struct {
	// The mime-type of the attachment. Supported types are:
	// - image/jpeg
	// - image/jpg
	// - image/png
	// - image/gif
	// - image/webp
	// - application/pdf
	// - text/plain
	// - text/csv
	// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
	// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
	// - application/vnd.openxmlformats-officedocument.presentationml.presentation
	// - application/msword
	// - application/vnd.ms-excel
	// - application/vnd.ms-powerpoint
	// - audio/aac
	// - audio/mpeg
	// - audio/mp4
	// - audio/wav
	// - audio/ogg
	// - video/mp4
	// - video/webm
	Type string `json:"type" url:"type"`
	// An optional name for the attachment.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The URL to access the attachment, The URL will be valid for 20 minutes. Only present when status is `ACCEPTED`.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The size of the attachment in bytes
	SizeBytes *int64 `json:"sizeBytes,omitempty" url:"sizeBytes,omitempty"`
	// The processing status of the attachment.
	Status AttachmentStatus `json:"status" url:"status"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (a *AttachmentResponse) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}

func (a *AttachmentResponse) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AttachmentResponse) GetUrl() *string {
	if a == nil {
		return nil
	}
	return a.Url
}

func (a *AttachmentResponse) GetSizeBytes() *int64 {
	if a == nil {
		return nil
	}
	return a.SizeBytes
}

func (a *AttachmentResponse) GetStatus() AttachmentStatus {
	if a == nil {
		return ""
	}
	return a.Status
}

func (a *AttachmentResponse) GetExtraProperties() map[string]interface{} {
	return a.extraProperties
}

func (a *AttachmentResponse) require(field *big.Int) {
	if a.explicitFields == nil {
		a.explicitFields = big.NewInt(0)
	}
	a.explicitFields.Or(a.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentResponse) SetType(type_ string) {
	a.Type = type_
	a.require(attachmentResponseFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentResponse) SetName(name *string) {
	a.Name = name
	a.require(attachmentResponseFieldName)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentResponse) SetUrl(url *string) {
	a.Url = url
	a.require(attachmentResponseFieldUrl)
}

// SetSizeBytes sets the SizeBytes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentResponse) SetSizeBytes(sizeBytes *int64) {
	a.SizeBytes = sizeBytes
	a.require(attachmentResponseFieldSizeBytes)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (a *AttachmentResponse) SetStatus(status AttachmentStatus) {
	a.Status = status
	a.require(attachmentResponseFieldStatus)
}

func (a *AttachmentResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler AttachmentResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = AttachmentResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *a)
	if err != nil {
		return err
	}
	a.extraProperties = extraProperties
	a.rawJSON = json.RawMessage(data)
	return nil
}

func (a *AttachmentResponse) MarshalJSON() ([]byte, error) {
	type embed AttachmentResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*a),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, a.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (a *AttachmentResponse) String() string {
	if len(a.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(a.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type AttachmentStatus string

const (
	AttachmentStatusPending    AttachmentStatus = "PENDING"
	AttachmentStatusProcessing AttachmentStatus = "PROCESSING"
	AttachmentStatusAccepted   AttachmentStatus = "ACCEPTED"
	AttachmentStatusRejected   AttachmentStatus = "REJECTED"
)

func NewAttachmentStatusFromString(s string) (AttachmentStatus, error) {
	switch s {
	case "PENDING":
		return AttachmentStatusPending, nil
	case "PROCESSING":
		return AttachmentStatusProcessing, nil
	case "ACCEPTED":
		return AttachmentStatusAccepted, nil
	case "REJECTED":
		return AttachmentStatusRejected, nil
	}
	var t AttachmentStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttachmentStatus) Ptr() *AttachmentStatus {
	return &a
}

var (
	baseAttachmentFieldType = big.NewInt(1 << 0)
	baseAttachmentFieldName = big.NewInt(1 << 1)
)

type BaseAttachment struct {
	// The mime-type of the attachment. Supported types are:
	// - image/jpeg
	// - image/jpg
	// - image/png
	// - image/gif
	// - image/webp
	// - application/pdf
	// - text/plain
	// - text/csv
	// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
	// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
	// - application/vnd.openxmlformats-officedocument.presentationml.presentation
	// - application/msword
	// - application/vnd.ms-excel
	// - application/vnd.ms-powerpoint
	// - audio/aac
	// - audio/mpeg
	// - audio/mp4
	// - audio/wav
	// - audio/ogg
	// - video/mp4
	// - video/webm
	Type string `json:"type" url:"type"`
	// An optional name for the attachment.
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseAttachment) GetType() string {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BaseAttachment) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *BaseAttachment) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseAttachment) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseAttachment) SetType(type_ string) {
	b.Type = type_
	b.require(baseAttachmentFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseAttachment) SetName(name *string) {
	b.Name = name
	b.require(baseAttachmentFieldName)
}

func (b *BaseAttachment) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseAttachment
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseAttachment(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseAttachment) MarshalJSON() ([]byte, error) {
	type embed BaseAttachment
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseAttachment) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	baseConversationResponseFieldResponseConfig    = big.NewInt(1 << 0)
	baseConversationResponseFieldSubject           = big.NewInt(1 << 1)
	baseConversationResponseFieldUrl               = big.NewInt(1 << 2)
	baseConversationResponseFieldCreatedAt         = big.NewInt(1 << 3)
	baseConversationResponseFieldUpdatedAt         = big.NewInt(1 << 4)
	baseConversationResponseFieldTags              = big.NewInt(1 << 5)
	baseConversationResponseFieldMetadata          = big.NewInt(1 << 6)
	baseConversationResponseFieldAllMetadata       = big.NewInt(1 << 7)
	baseConversationResponseFieldConversationId    = big.NewInt(1 << 8)
	baseConversationResponseFieldAnalysis          = big.NewInt(1 << 9)
	baseConversationResponseFieldSummary           = big.NewInt(1 << 10)
	baseConversationResponseFieldDeleted           = big.NewInt(1 << 11)
	baseConversationResponseFieldOpen              = big.NewInt(1 << 12)
	baseConversationResponseFieldLlmEnabled        = big.NewInt(1 << 13)
	baseConversationResponseFieldSimulationContext = big.NewInt(1 << 14)
)

type BaseConversationResponse struct {
	// Optional configurations for responses to this conversation
	ResponseConfig *ResponseConfig `json:"responseConfig,omitempty" url:"responseConfig,omitempty"`
	// The subject of the conversation
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The url of the conversation
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// The tags of the conversation. Used for filtering in Agent Designer.
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// The metadata of the conversation supplied by the app which created the conversation.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// All metadata for the conversation. Keyed by appId.
	AllMetadata map[string]map[string]string `json:"allMetadata" url:"allMetadata"`
	// The ID that uniquely identifies this conversation
	ConversationId *EntityId `json:"conversationId" url:"conversationId"`
	// An analysis of the conversation. Fields are generated by Maven via an analysis of user messages. This object is calculated on a delay. Fields will not be up to date on ask requests.
	Analysis *ConversationAnalysis `json:"analysis" url:"analysis"`
	// A summary of the conversation. Fields are calculated from conversation data. Unlike analysis, all fields can be derived from other data available in the API. This object is provided as a convenience and is calculated on a delay. Fields will not be up to date on ask requests.
	Summary *ConversationSummary `json:"summary" url:"summary"`
	// Whether the conversation user-specific data has been deleted. See `deleteConversation` for details.
	Deleted bool `json:"deleted" url:"deleted"`
	// Whether the conversation is able to receive asynchronous messages.
	// Only applicable if a conversation is initialized with the `ASYNC` capability. Defaults to true. Can be closed using the `PATCH` API.
	Open bool `json:"open" url:"open"`
	// Whether the LLM is enabled for this conversation.
	// If true, `USER` messages sent via the ask API will be sent to the LLM and a `BOT_RESPONSE` or `BOT_SUGGESTION` message will be generated.
	// If false, `USER` messages will not be sent to the LLM.
	LlmEnabled bool `json:"llmEnabled" url:"llmEnabled"`
	// Additional context used for simulation runs. When present, this conversation is treated as a simulation.
	// Simulation conversations are excluded from normal search results unless explicitly included via the `simulationFilter` field.
	SimulationContext *SimulationContext `json:"simulationContext,omitempty" url:"simulationContext,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseConversationResponse) GetResponseConfig() *ResponseConfig {
	if b == nil {
		return nil
	}
	return b.ResponseConfig
}

func (b *BaseConversationResponse) GetSubject() *string {
	if b == nil {
		return nil
	}
	return b.Subject
}

func (b *BaseConversationResponse) GetUrl() *string {
	if b == nil {
		return nil
	}
	return b.Url
}

func (b *BaseConversationResponse) GetCreatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BaseConversationResponse) GetUpdatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.UpdatedAt
}

func (b *BaseConversationResponse) GetTags() []string {
	if b == nil {
		return nil
	}
	return b.Tags
}

func (b *BaseConversationResponse) GetMetadata() map[string]string {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BaseConversationResponse) GetAllMetadata() map[string]map[string]string {
	if b == nil {
		return nil
	}
	return b.AllMetadata
}

func (b *BaseConversationResponse) GetConversationId() *EntityId {
	if b == nil {
		return nil
	}
	return b.ConversationId
}

func (b *BaseConversationResponse) GetAnalysis() *ConversationAnalysis {
	if b == nil {
		return nil
	}
	return b.Analysis
}

func (b *BaseConversationResponse) GetSummary() *ConversationSummary {
	if b == nil {
		return nil
	}
	return b.Summary
}

func (b *BaseConversationResponse) GetDeleted() bool {
	if b == nil {
		return false
	}
	return b.Deleted
}

func (b *BaseConversationResponse) GetOpen() bool {
	if b == nil {
		return false
	}
	return b.Open
}

func (b *BaseConversationResponse) GetLlmEnabled() bool {
	if b == nil {
		return false
	}
	return b.LlmEnabled
}

func (b *BaseConversationResponse) GetSimulationContext() *SimulationContext {
	if b == nil {
		return nil
	}
	return b.SimulationContext
}

func (b *BaseConversationResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseConversationResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetResponseConfig sets the ResponseConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetResponseConfig(responseConfig *ResponseConfig) {
	b.ResponseConfig = responseConfig
	b.require(baseConversationResponseFieldResponseConfig)
}

// SetSubject sets the Subject field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetSubject(subject *string) {
	b.Subject = subject
	b.require(baseConversationResponseFieldSubject)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetUrl(url *string) {
	b.Url = url
	b.require(baseConversationResponseFieldUrl)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetCreatedAt(createdAt *time.Time) {
	b.CreatedAt = createdAt
	b.require(baseConversationResponseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetUpdatedAt(updatedAt *time.Time) {
	b.UpdatedAt = updatedAt
	b.require(baseConversationResponseFieldUpdatedAt)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetTags(tags []string) {
	b.Tags = tags
	b.require(baseConversationResponseFieldTags)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetMetadata(metadata map[string]string) {
	b.Metadata = metadata
	b.require(baseConversationResponseFieldMetadata)
}

// SetAllMetadata sets the AllMetadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetAllMetadata(allMetadata map[string]map[string]string) {
	b.AllMetadata = allMetadata
	b.require(baseConversationResponseFieldAllMetadata)
}

// SetConversationId sets the ConversationId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetConversationId(conversationId *EntityId) {
	b.ConversationId = conversationId
	b.require(baseConversationResponseFieldConversationId)
}

// SetAnalysis sets the Analysis field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetAnalysis(analysis *ConversationAnalysis) {
	b.Analysis = analysis
	b.require(baseConversationResponseFieldAnalysis)
}

// SetSummary sets the Summary field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetSummary(summary *ConversationSummary) {
	b.Summary = summary
	b.require(baseConversationResponseFieldSummary)
}

// SetDeleted sets the Deleted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetDeleted(deleted bool) {
	b.Deleted = deleted
	b.require(baseConversationResponseFieldDeleted)
}

// SetOpen sets the Open field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetOpen(open bool) {
	b.Open = open
	b.require(baseConversationResponseFieldOpen)
}

// SetLlmEnabled sets the LlmEnabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetLlmEnabled(llmEnabled bool) {
	b.LlmEnabled = llmEnabled
	b.require(baseConversationResponseFieldLlmEnabled)
}

// SetSimulationContext sets the SimulationContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseConversationResponse) SetSimulationContext(simulationContext *SimulationContext) {
	b.SimulationContext = simulationContext
	b.require(baseConversationResponseFieldSimulationContext)
}

func (b *BaseConversationResponse) UnmarshalJSON(data []byte) error {
	type embed BaseConversationResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BaseConversationResponse(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseConversationResponse) MarshalJSON() ([]byte, error) {
	type embed BaseConversationResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewOptionalDateTime(b.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(b.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseConversationResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	basePaginatedRequestFieldPage     = big.NewInt(1 << 0)
	basePaginatedRequestFieldSize     = big.NewInt(1 << 1)
	basePaginatedRequestFieldSortDesc = big.NewInt(1 << 2)
)

type BasePaginatedRequest struct {
	// Page number to return, defaults to 0
	Page *int `json:"page,omitempty" url:"page,omitempty"`
	// The size of the page to return, defaults to 20
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Whether to sort descending, defaults to true
	SortDesc *bool `json:"sortDesc,omitempty" url:"sortDesc,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BasePaginatedRequest) GetPage() *int {
	if b == nil {
		return nil
	}
	return b.Page
}

func (b *BasePaginatedRequest) GetSize() *int {
	if b == nil {
		return nil
	}
	return b.Size
}

func (b *BasePaginatedRequest) GetSortDesc() *bool {
	if b == nil {
		return nil
	}
	return b.SortDesc
}

func (b *BasePaginatedRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BasePaginatedRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasePaginatedRequest) SetPage(page *int) {
	b.Page = page
	b.require(basePaginatedRequestFieldPage)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasePaginatedRequest) SetSize(size *int) {
	b.Size = size
	b.require(basePaginatedRequestFieldSize)
}

// SetSortDesc sets the SortDesc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BasePaginatedRequest) SetSortDesc(sortDesc *bool) {
	b.SortDesc = sortDesc
	b.require(basePaginatedRequestFieldSortDesc)
}

func (b *BasePaginatedRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BasePaginatedRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BasePaginatedRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BasePaginatedRequest) MarshalJSON() ([]byte, error) {
	type embed BasePaginatedRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BasePaginatedRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	baseSearchRequestFieldPage     = big.NewInt(1 << 0)
	baseSearchRequestFieldSize     = big.NewInt(1 << 1)
	baseSearchRequestFieldSortDesc = big.NewInt(1 << 2)
	baseSearchRequestFieldSortId   = big.NewInt(1 << 3)
)

type BaseSearchRequest struct {
	// Page number to return, defaults to 0
	Page *int `json:"page,omitempty" url:"page,omitempty"`
	// The size of the page to return, defaults to 20
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Whether to sort descending, defaults to true
	SortDesc *bool `json:"sortDesc,omitempty" url:"sortDesc,omitempty"`
	// The field to sort by, defaults to created timestamp
	SortId *string `json:"sortId,omitempty" url:"sortId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BaseSearchRequest) GetPage() *int {
	if b == nil {
		return nil
	}
	return b.Page
}

func (b *BaseSearchRequest) GetSize() *int {
	if b == nil {
		return nil
	}
	return b.Size
}

func (b *BaseSearchRequest) GetSortDesc() *bool {
	if b == nil {
		return nil
	}
	return b.SortDesc
}

func (b *BaseSearchRequest) GetSortId() *string {
	if b == nil {
		return nil
	}
	return b.SortId
}

func (b *BaseSearchRequest) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BaseSearchRequest) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseSearchRequest) SetPage(page *int) {
	b.Page = page
	b.require(baseSearchRequestFieldPage)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseSearchRequest) SetSize(size *int) {
	b.Size = size
	b.require(baseSearchRequestFieldSize)
}

// SetSortDesc sets the SortDesc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseSearchRequest) SetSortDesc(sortDesc *bool) {
	b.SortDesc = sortDesc
	b.require(baseSearchRequestFieldSortDesc)
}

// SetSortId sets the SortId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BaseSearchRequest) SetSortId(sortId *string) {
	b.SortId = sortId
	b.require(baseSearchRequestFieldSortId)
}

func (b *BaseSearchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler BaseSearchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BaseSearchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BaseSearchRequest) MarshalJSON() ([]byte, error) {
	type embed BaseSearchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BaseSearchRequest) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// This response should be rendered as a form which users can submit. Upon submission call the `submitActionForm` API.
var (
	botActionFormResponseFieldId          = big.NewInt(1 << 0)
	botActionFormResponseFieldActionId    = big.NewInt(1 << 1)
	botActionFormResponseFieldFormLabel   = big.NewInt(1 << 2)
	botActionFormResponseFieldFields      = big.NewInt(1 << 3)
	botActionFormResponseFieldSubmitLabel = big.NewInt(1 << 4)
)

type BotActionFormResponse struct {
	// The ID to use when submitting the form via the `submitActionForm` API.
	Id string `json:"id" url:"id"`
	// The ID of the action that will be executed when the form is submitted.
	ActionId *EntityIdWithoutAgent `json:"actionId" url:"actionId"`
	// Text which should be displayed to the user at the top of the form. Provided in the user's language.
	FormLabel string `json:"formLabel" url:"formLabel"`
	// The fields that should be displayed within the form.
	Fields []*ActionFormField `json:"fields" url:"fields"`
	// Text that should be displayed to the user on the submit button. Provided in the user's language.
	SubmitLabel string `json:"submitLabel" url:"submitLabel"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotActionFormResponse) GetId() string {
	if b == nil {
		return ""
	}
	return b.Id
}

func (b *BotActionFormResponse) GetActionId() *EntityIdWithoutAgent {
	if b == nil {
		return nil
	}
	return b.ActionId
}

func (b *BotActionFormResponse) GetFormLabel() string {
	if b == nil {
		return ""
	}
	return b.FormLabel
}

func (b *BotActionFormResponse) GetFields() []*ActionFormField {
	if b == nil {
		return nil
	}
	return b.Fields
}

func (b *BotActionFormResponse) GetSubmitLabel() string {
	if b == nil {
		return ""
	}
	return b.SubmitLabel
}

func (b *BotActionFormResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotActionFormResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotActionFormResponse) SetId(id string) {
	b.Id = id
	b.require(botActionFormResponseFieldId)
}

// SetActionId sets the ActionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotActionFormResponse) SetActionId(actionId *EntityIdWithoutAgent) {
	b.ActionId = actionId
	b.require(botActionFormResponseFieldActionId)
}

// SetFormLabel sets the FormLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotActionFormResponse) SetFormLabel(formLabel string) {
	b.FormLabel = formLabel
	b.require(botActionFormResponseFieldFormLabel)
}

// SetFields sets the Fields field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotActionFormResponse) SetFields(fields []*ActionFormField) {
	b.Fields = fields
	b.require(botActionFormResponseFieldFields)
}

// SetSubmitLabel sets the SubmitLabel field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotActionFormResponse) SetSubmitLabel(submitLabel string) {
	b.SubmitLabel = submitLabel
	b.require(botActionFormResponseFieldSubmitLabel)
}

func (b *BotActionFormResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BotActionFormResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotActionFormResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotActionFormResponse) MarshalJSON() ([]byte, error) {
	type embed BotActionFormResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotActionFormResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// Will only be provided if the responseConfig contains the charts_highcharts_ts capability.
var (
	botChartResponseFieldLabel      = big.NewInt(1 << 0)
	botChartResponseFieldSpecSchema = big.NewInt(1 << 1)
	botChartResponseFieldSpec       = big.NewInt(1 << 2)
)

type BotChartResponse struct {
	// The label of the chart
	Label      string          `json:"label" url:"label"`
	SpecSchema ChartSpecSchema `json:"specSchema" url:"specSchema"`
	// The spec string for the chart. For HIGHCHARTS_TS charts, the spec is the json object that represents the chart options.
	Spec string `json:"spec" url:"spec"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotChartResponse) GetLabel() string {
	if b == nil {
		return ""
	}
	return b.Label
}

func (b *BotChartResponse) GetSpecSchema() ChartSpecSchema {
	if b == nil {
		return ""
	}
	return b.SpecSchema
}

func (b *BotChartResponse) GetSpec() string {
	if b == nil {
		return ""
	}
	return b.Spec
}

func (b *BotChartResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotChartResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotChartResponse) SetLabel(label string) {
	b.Label = label
	b.require(botChartResponseFieldLabel)
}

// SetSpecSchema sets the SpecSchema field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotChartResponse) SetSpecSchema(specSchema ChartSpecSchema) {
	b.SpecSchema = specSchema
	b.require(botChartResponseFieldSpecSchema)
}

// SetSpec sets the Spec field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotChartResponse) SetSpec(spec string) {
	b.Spec = spec
	b.require(botChartResponseFieldSpec)
}

func (b *BotChartResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BotChartResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotChartResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotChartResponse) MarshalJSON() ([]byte, error) {
	type embed BotChartResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotChartResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BotConversationMessageType string

const (
	BotConversationMessageTypeBotResponse   BotConversationMessageType = "BOT_RESPONSE"
	BotConversationMessageTypeBotSuggestion BotConversationMessageType = "BOT_SUGGESTION"
)

func NewBotConversationMessageTypeFromString(s string) (BotConversationMessageType, error) {
	switch s {
	case "BOT_RESPONSE":
		return BotConversationMessageTypeBotResponse, nil
	case "BOT_SUGGESTION":
		return BotConversationMessageTypeBotSuggestion, nil
	}
	var t BotConversationMessageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BotConversationMessageType) Ptr() *BotConversationMessageType {
	return &b
}

var (
	botLogicFieldItems = big.NewInt(1 << 0)
)

type BotLogic struct {
	Items []*BotLogicItem `json:"items" url:"items"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogic) GetItems() []*BotLogicItem {
	if b == nil {
		return nil
	}
	return b.Items
}

func (b *BotLogic) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogic) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetItems sets the Items field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogic) SetItems(items []*BotLogicItem) {
	b.Items = items
	b.require(botLogicFieldItems)
}

func (b *BotLogic) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogic
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogic(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogic) MarshalJSON() ([]byte, error) {
	type embed BotLogic
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogic) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicActionExecutedDetailFieldActionId         = big.NewInt(1 << 0)
	botLogicActionExecutedDetailFieldActionName       = big.NewInt(1 << 1)
	botLogicActionExecutedDetailFieldActionParameters = big.NewInt(1 << 2)
	botLogicActionExecutedDetailFieldExecutionResult  = big.NewInt(1 << 3)
	botLogicActionExecutedDetailFieldExecutionError   = big.NewInt(1 << 4)
)

type BotLogicActionExecutedDetail struct {
	ActionId         *EntityIdWithoutAgent                 `json:"actionId" url:"actionId"`
	ActionName       string                                `json:"actionName" url:"actionName"`
	ActionParameters map[string]*ActionExecutionParamValue `json:"actionParameters" url:"actionParameters"`
	ExecutionResult  *string                               `json:"executionResult,omitempty" url:"executionResult,omitempty"`
	ExecutionError   *string                               `json:"executionError,omitempty" url:"executionError,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicActionExecutedDetail) GetActionId() *EntityIdWithoutAgent {
	if b == nil {
		return nil
	}
	return b.ActionId
}

func (b *BotLogicActionExecutedDetail) GetActionName() string {
	if b == nil {
		return ""
	}
	return b.ActionName
}

func (b *BotLogicActionExecutedDetail) GetActionParameters() map[string]*ActionExecutionParamValue {
	if b == nil {
		return nil
	}
	return b.ActionParameters
}

func (b *BotLogicActionExecutedDetail) GetExecutionResult() *string {
	if b == nil {
		return nil
	}
	return b.ExecutionResult
}

func (b *BotLogicActionExecutedDetail) GetExecutionError() *string {
	if b == nil {
		return nil
	}
	return b.ExecutionError
}

func (b *BotLogicActionExecutedDetail) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicActionExecutedDetail) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetActionId sets the ActionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionExecutedDetail) SetActionId(actionId *EntityIdWithoutAgent) {
	b.ActionId = actionId
	b.require(botLogicActionExecutedDetailFieldActionId)
}

// SetActionName sets the ActionName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionExecutedDetail) SetActionName(actionName string) {
	b.ActionName = actionName
	b.require(botLogicActionExecutedDetailFieldActionName)
}

// SetActionParameters sets the ActionParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionExecutedDetail) SetActionParameters(actionParameters map[string]*ActionExecutionParamValue) {
	b.ActionParameters = actionParameters
	b.require(botLogicActionExecutedDetailFieldActionParameters)
}

// SetExecutionResult sets the ExecutionResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionExecutedDetail) SetExecutionResult(executionResult *string) {
	b.ExecutionResult = executionResult
	b.require(botLogicActionExecutedDetailFieldExecutionResult)
}

// SetExecutionError sets the ExecutionError field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionExecutedDetail) SetExecutionError(executionError *string) {
	b.ExecutionError = executionError
	b.require(botLogicActionExecutedDetailFieldExecutionError)
}

func (b *BotLogicActionExecutedDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicActionExecutedDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicActionExecutedDetail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicActionExecutedDetail) MarshalJSON() ([]byte, error) {
	type embed BotLogicActionExecutedDetail
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicActionExecutedDetail) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicActionItemFieldActionsReviewed = big.NewInt(1 << 0)
	botLogicActionItemFieldActionsExecuted = big.NewInt(1 << 1)
)

type BotLogicActionItem struct {
	ActionsReviewed []*BotLogicActionReviewedDetail `json:"actionsReviewed" url:"actionsReviewed"`
	ActionsExecuted []*BotLogicActionExecutedDetail `json:"actionsExecuted" url:"actionsExecuted"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicActionItem) GetActionsReviewed() []*BotLogicActionReviewedDetail {
	if b == nil {
		return nil
	}
	return b.ActionsReviewed
}

func (b *BotLogicActionItem) GetActionsExecuted() []*BotLogicActionExecutedDetail {
	if b == nil {
		return nil
	}
	return b.ActionsExecuted
}

func (b *BotLogicActionItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicActionItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetActionsReviewed sets the ActionsReviewed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionItem) SetActionsReviewed(actionsReviewed []*BotLogicActionReviewedDetail) {
	b.ActionsReviewed = actionsReviewed
	b.require(botLogicActionItemFieldActionsReviewed)
}

// SetActionsExecuted sets the ActionsExecuted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionItem) SetActionsExecuted(actionsExecuted []*BotLogicActionExecutedDetail) {
	b.ActionsExecuted = actionsExecuted
	b.require(botLogicActionItemFieldActionsExecuted)
}

func (b *BotLogicActionItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicActionItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicActionItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicActionItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicActionItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicActionItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicActionReviewedDetailFieldActionId   = big.NewInt(1 << 0)
	botLogicActionReviewedDetailFieldActionName = big.NewInt(1 << 1)
)

type BotLogicActionReviewedDetail struct {
	ActionId   *EntityIdWithoutAgent `json:"actionId" url:"actionId"`
	ActionName string                `json:"actionName" url:"actionName"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicActionReviewedDetail) GetActionId() *EntityIdWithoutAgent {
	if b == nil {
		return nil
	}
	return b.ActionId
}

func (b *BotLogicActionReviewedDetail) GetActionName() string {
	if b == nil {
		return ""
	}
	return b.ActionName
}

func (b *BotLogicActionReviewedDetail) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicActionReviewedDetail) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetActionId sets the ActionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionReviewedDetail) SetActionId(actionId *EntityIdWithoutAgent) {
	b.ActionId = actionId
	b.require(botLogicActionReviewedDetailFieldActionId)
}

// SetActionName sets the ActionName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicActionReviewedDetail) SetActionName(actionName string) {
	b.ActionName = actionName
	b.require(botLogicActionReviewedDetailFieldActionName)
}

func (b *BotLogicActionReviewedDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicActionReviewedDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicActionReviewedDetail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicActionReviewedDetail) MarshalJSON() ([]byte, error) {
	type embed BotLogicActionReviewedDetail
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicActionReviewedDetail) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicFormSubmissionItemFieldActionId         = big.NewInt(1 << 0)
	botLogicFormSubmissionItemFieldActionName       = big.NewInt(1 << 1)
	botLogicFormSubmissionItemFieldActionParameters = big.NewInt(1 << 2)
	botLogicFormSubmissionItemFieldExecutionResult  = big.NewInt(1 << 3)
	botLogicFormSubmissionItemFieldExecutionError   = big.NewInt(1 << 4)
)

type BotLogicFormSubmissionItem struct {
	ActionId         *EntityIdWithoutAgent                 `json:"actionId" url:"actionId"`
	ActionName       string                                `json:"actionName" url:"actionName"`
	ActionParameters map[string]*ActionExecutionParamValue `json:"actionParameters" url:"actionParameters"`
	ExecutionResult  *string                               `json:"executionResult,omitempty" url:"executionResult,omitempty"`
	ExecutionError   *string                               `json:"executionError,omitempty" url:"executionError,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicFormSubmissionItem) GetActionId() *EntityIdWithoutAgent {
	if b == nil {
		return nil
	}
	return b.ActionId
}

func (b *BotLogicFormSubmissionItem) GetActionName() string {
	if b == nil {
		return ""
	}
	return b.ActionName
}

func (b *BotLogicFormSubmissionItem) GetActionParameters() map[string]*ActionExecutionParamValue {
	if b == nil {
		return nil
	}
	return b.ActionParameters
}

func (b *BotLogicFormSubmissionItem) GetExecutionResult() *string {
	if b == nil {
		return nil
	}
	return b.ExecutionResult
}

func (b *BotLogicFormSubmissionItem) GetExecutionError() *string {
	if b == nil {
		return nil
	}
	return b.ExecutionError
}

func (b *BotLogicFormSubmissionItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicFormSubmissionItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetActionId sets the ActionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicFormSubmissionItem) SetActionId(actionId *EntityIdWithoutAgent) {
	b.ActionId = actionId
	b.require(botLogicFormSubmissionItemFieldActionId)
}

// SetActionName sets the ActionName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicFormSubmissionItem) SetActionName(actionName string) {
	b.ActionName = actionName
	b.require(botLogicFormSubmissionItemFieldActionName)
}

// SetActionParameters sets the ActionParameters field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicFormSubmissionItem) SetActionParameters(actionParameters map[string]*ActionExecutionParamValue) {
	b.ActionParameters = actionParameters
	b.require(botLogicFormSubmissionItemFieldActionParameters)
}

// SetExecutionResult sets the ExecutionResult field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicFormSubmissionItem) SetExecutionResult(executionResult *string) {
	b.ExecutionResult = executionResult
	b.require(botLogicFormSubmissionItemFieldExecutionResult)
}

// SetExecutionError sets the ExecutionError field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicFormSubmissionItem) SetExecutionError(executionError *string) {
	b.ExecutionError = executionError
	b.require(botLogicFormSubmissionItemFieldExecutionError)
}

func (b *BotLogicFormSubmissionItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicFormSubmissionItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicFormSubmissionItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicFormSubmissionItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicFormSubmissionItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicFormSubmissionItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BotLogicItem struct {
	Type      string
	Knowledge *BotLogicKnowledgeItem
	Actions   *BotLogicActionItem
	Form      *BotLogicFormSubmissionItem
	Safety    *BotLogicSafetyItem
	User      *BotLogicUserItem
	Segments  *BotLogicSegmentsItem
}

func (b *BotLogicItem) GetType() string {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BotLogicItem) GetKnowledge() *BotLogicKnowledgeItem {
	if b == nil {
		return nil
	}
	return b.Knowledge
}

func (b *BotLogicItem) GetActions() *BotLogicActionItem {
	if b == nil {
		return nil
	}
	return b.Actions
}

func (b *BotLogicItem) GetForm() *BotLogicFormSubmissionItem {
	if b == nil {
		return nil
	}
	return b.Form
}

func (b *BotLogicItem) GetSafety() *BotLogicSafetyItem {
	if b == nil {
		return nil
	}
	return b.Safety
}

func (b *BotLogicItem) GetUser() *BotLogicUserItem {
	if b == nil {
		return nil
	}
	return b.User
}

func (b *BotLogicItem) GetSegments() *BotLogicSegmentsItem {
	if b == nil {
		return nil
	}
	return b.Segments
}

func (b *BotLogicItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "knowledge":
		value := new(BotLogicKnowledgeItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Knowledge = value
	case "actions":
		value := new(BotLogicActionItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Actions = value
	case "form":
		value := new(BotLogicFormSubmissionItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Form = value
	case "safety":
		value := new(BotLogicSafetyItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Safety = value
	case "user":
		value := new(BotLogicUserItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.User = value
	case "segments":
		value := new(BotLogicSegmentsItem)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Segments = value
	}
	return nil
}

func (b BotLogicItem) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	if b.Knowledge != nil {
		return internal.MarshalJSONWithExtraProperty(b.Knowledge, "type", "knowledge")
	}
	if b.Actions != nil {
		return internal.MarshalJSONWithExtraProperty(b.Actions, "type", "actions")
	}
	if b.Form != nil {
		return internal.MarshalJSONWithExtraProperty(b.Form, "type", "form")
	}
	if b.Safety != nil {
		return internal.MarshalJSONWithExtraProperty(b.Safety, "type", "safety")
	}
	if b.User != nil {
		return internal.MarshalJSONWithExtraProperty(b.User, "type", "user")
	}
	if b.Segments != nil {
		return internal.MarshalJSONWithExtraProperty(b.Segments, "type", "segments")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BotLogicItemVisitor interface {
	VisitKnowledge(*BotLogicKnowledgeItem) error
	VisitActions(*BotLogicActionItem) error
	VisitForm(*BotLogicFormSubmissionItem) error
	VisitSafety(*BotLogicSafetyItem) error
	VisitUser(*BotLogicUserItem) error
	VisitSegments(*BotLogicSegmentsItem) error
}

func (b *BotLogicItem) Accept(visitor BotLogicItemVisitor) error {
	if b.Knowledge != nil {
		return visitor.VisitKnowledge(b.Knowledge)
	}
	if b.Actions != nil {
		return visitor.VisitActions(b.Actions)
	}
	if b.Form != nil {
		return visitor.VisitForm(b.Form)
	}
	if b.Safety != nil {
		return visitor.VisitSafety(b.Safety)
	}
	if b.User != nil {
		return visitor.VisitUser(b.User)
	}
	if b.Segments != nil {
		return visitor.VisitSegments(b.Segments)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

func (b *BotLogicItem) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Knowledge != nil {
		fields = append(fields, "knowledge")
	}
	if b.Actions != nil {
		fields = append(fields, "actions")
	}
	if b.Form != nil {
		fields = append(fields, "form")
	}
	if b.Safety != nil {
		fields = append(fields, "safety")
	}
	if b.User != nil {
		fields = append(fields, "user")
	}
	if b.Segments != nil {
		fields = append(fields, "segments")
	}
	if len(fields) == 0 {
		if b.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Type)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Type != "" {
		field := fields[0]
		if b.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Type,
				b,
			)
		}
	}
	return nil
}

var (
	botLogicKnowledgeDetailFieldKnowledgeBaseId = big.NewInt(1 << 0)
	botLogicKnowledgeDetailFieldDocumentId      = big.NewInt(1 << 1)
	botLogicKnowledgeDetailFieldDocumentName    = big.NewInt(1 << 2)
	botLogicKnowledgeDetailFieldDocumentExcerpt = big.NewInt(1 << 3)
)

type BotLogicKnowledgeDetail struct {
	KnowledgeBaseId *EntityIdWithoutAgent `json:"knowledgeBaseId" url:"knowledgeBaseId"`
	DocumentId      *EntityIdWithoutAgent `json:"documentId" url:"documentId"`
	DocumentName    string                `json:"documentName" url:"documentName"`
	DocumentExcerpt string                `json:"documentExcerpt" url:"documentExcerpt"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicKnowledgeDetail) GetKnowledgeBaseId() *EntityIdWithoutAgent {
	if b == nil {
		return nil
	}
	return b.KnowledgeBaseId
}

func (b *BotLogicKnowledgeDetail) GetDocumentId() *EntityIdWithoutAgent {
	if b == nil {
		return nil
	}
	return b.DocumentId
}

func (b *BotLogicKnowledgeDetail) GetDocumentName() string {
	if b == nil {
		return ""
	}
	return b.DocumentName
}

func (b *BotLogicKnowledgeDetail) GetDocumentExcerpt() string {
	if b == nil {
		return ""
	}
	return b.DocumentExcerpt
}

func (b *BotLogicKnowledgeDetail) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicKnowledgeDetail) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetKnowledgeBaseId sets the KnowledgeBaseId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeDetail) SetKnowledgeBaseId(knowledgeBaseId *EntityIdWithoutAgent) {
	b.KnowledgeBaseId = knowledgeBaseId
	b.require(botLogicKnowledgeDetailFieldKnowledgeBaseId)
}

// SetDocumentId sets the DocumentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeDetail) SetDocumentId(documentId *EntityIdWithoutAgent) {
	b.DocumentId = documentId
	b.require(botLogicKnowledgeDetailFieldDocumentId)
}

// SetDocumentName sets the DocumentName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeDetail) SetDocumentName(documentName string) {
	b.DocumentName = documentName
	b.require(botLogicKnowledgeDetailFieldDocumentName)
}

// SetDocumentExcerpt sets the DocumentExcerpt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeDetail) SetDocumentExcerpt(documentExcerpt string) {
	b.DocumentExcerpt = documentExcerpt
	b.require(botLogicKnowledgeDetailFieldDocumentExcerpt)
}

func (b *BotLogicKnowledgeDetail) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicKnowledgeDetail
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicKnowledgeDetail(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicKnowledgeDetail) MarshalJSON() ([]byte, error) {
	type embed BotLogicKnowledgeDetail
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicKnowledgeDetail) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicKnowledgeItemFieldKnowledgeReviewed = big.NewInt(1 << 0)
	botLogicKnowledgeItemFieldKnowledgeUtilized = big.NewInt(1 << 1)
)

type BotLogicKnowledgeItem struct {
	KnowledgeReviewed []*BotLogicKnowledgeDetail `json:"knowledgeReviewed" url:"knowledgeReviewed"`
	KnowledgeUtilized []*BotLogicKnowledgeDetail `json:"knowledgeUtilized" url:"knowledgeUtilized"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicKnowledgeItem) GetKnowledgeReviewed() []*BotLogicKnowledgeDetail {
	if b == nil {
		return nil
	}
	return b.KnowledgeReviewed
}

func (b *BotLogicKnowledgeItem) GetKnowledgeUtilized() []*BotLogicKnowledgeDetail {
	if b == nil {
		return nil
	}
	return b.KnowledgeUtilized
}

func (b *BotLogicKnowledgeItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicKnowledgeItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetKnowledgeReviewed sets the KnowledgeReviewed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeItem) SetKnowledgeReviewed(knowledgeReviewed []*BotLogicKnowledgeDetail) {
	b.KnowledgeReviewed = knowledgeReviewed
	b.require(botLogicKnowledgeItemFieldKnowledgeReviewed)
}

// SetKnowledgeUtilized sets the KnowledgeUtilized field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicKnowledgeItem) SetKnowledgeUtilized(knowledgeUtilized []*BotLogicKnowledgeDetail) {
	b.KnowledgeUtilized = knowledgeUtilized
	b.require(botLogicKnowledgeItemFieldKnowledgeUtilized)
}

func (b *BotLogicKnowledgeItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicKnowledgeItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicKnowledgeItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicKnowledgeItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicKnowledgeItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicKnowledgeItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicSafetyItemFieldSafetyCheckPassed = big.NewInt(1 << 0)
)

type BotLogicSafetyItem struct {
	SafetyCheckPassed bool `json:"safetyCheckPassed" url:"safetyCheckPassed"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicSafetyItem) GetSafetyCheckPassed() bool {
	if b == nil {
		return false
	}
	return b.SafetyCheckPassed
}

func (b *BotLogicSafetyItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicSafetyItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetSafetyCheckPassed sets the SafetyCheckPassed field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicSafetyItem) SetSafetyCheckPassed(safetyCheckPassed bool) {
	b.SafetyCheckPassed = safetyCheckPassed
	b.require(botLogicSafetyItemFieldSafetyCheckPassed)
}

func (b *BotLogicSafetyItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicSafetyItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicSafetyItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicSafetyItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicSafetyItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicSafetyItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicSegmentsItemFieldMatchingSegmentIds = big.NewInt(1 << 0)
)

type BotLogicSegmentsItem struct {
	MatchingSegmentIds []*EntityId `json:"matchingSegmentIds" url:"matchingSegmentIds"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicSegmentsItem) GetMatchingSegmentIds() []*EntityId {
	if b == nil {
		return nil
	}
	return b.MatchingSegmentIds
}

func (b *BotLogicSegmentsItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicSegmentsItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetMatchingSegmentIds sets the MatchingSegmentIds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicSegmentsItem) SetMatchingSegmentIds(matchingSegmentIds []*EntityId) {
	b.MatchingSegmentIds = matchingSegmentIds
	b.require(botLogicSegmentsItemFieldMatchingSegmentIds)
}

func (b *BotLogicSegmentsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicSegmentsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicSegmentsItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicSegmentsItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicSegmentsItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicSegmentsItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botLogicUserItemFieldUserData = big.NewInt(1 << 0)
)

type BotLogicUserItem struct {
	UserData map[string]string `json:"userData" url:"userData"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotLogicUserItem) GetUserData() map[string]string {
	if b == nil {
		return nil
	}
	return b.UserData
}

func (b *BotLogicUserItem) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotLogicUserItem) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetUserData sets the UserData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotLogicUserItem) SetUserData(userData map[string]string) {
	b.UserData = userData
	b.require(botLogicUserItemFieldUserData)
}

func (b *BotLogicUserItem) UnmarshalJSON(data []byte) error {
	type unmarshaler BotLogicUserItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotLogicUserItem(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotLogicUserItem) MarshalJSON() ([]byte, error) {
	type embed BotLogicUserItem
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotLogicUserItem) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	botMessageFieldCreatedAt             = big.NewInt(1 << 0)
	botMessageFieldUpdatedAt             = big.NewInt(1 << 1)
	botMessageFieldConversationMessageId = big.NewInt(1 << 2)
	botMessageFieldBotMessageType        = big.NewInt(1 << 3)
	botMessageFieldResponses             = big.NewInt(1 << 4)
	botMessageFieldMetadata              = big.NewInt(1 << 5)
	botMessageFieldStatus                = big.NewInt(1 << 6)
	botMessageFieldLogic                 = big.NewInt(1 << 7)
)

type BotMessage struct {
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// The ID that uniquely identifies this message within the conversation
	ConversationMessageId *EntityId                  `json:"conversationMessageId" url:"conversationMessageId"`
	BotMessageType        BotConversationMessageType `json:"botMessageType" url:"botMessageType"`
	Responses             []*BotResponse             `json:"responses" url:"responses"`
	Metadata              *BotResponseMetadata       `json:"metadata" url:"metadata"`
	Status                MessageStatus              `json:"status" url:"status"`
	// The logic that was used to generate the response. Response size may be large; only present on the getConversation request.
	Logic *BotLogic `json:"logic,omitempty" url:"logic,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotMessage) GetCreatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.CreatedAt
}

func (b *BotMessage) GetUpdatedAt() *time.Time {
	if b == nil {
		return nil
	}
	return b.UpdatedAt
}

func (b *BotMessage) GetConversationMessageId() *EntityId {
	if b == nil {
		return nil
	}
	return b.ConversationMessageId
}

func (b *BotMessage) GetBotMessageType() BotConversationMessageType {
	if b == nil {
		return ""
	}
	return b.BotMessageType
}

func (b *BotMessage) GetResponses() []*BotResponse {
	if b == nil {
		return nil
	}
	return b.Responses
}

func (b *BotMessage) GetMetadata() *BotResponseMetadata {
	if b == nil {
		return nil
	}
	return b.Metadata
}

func (b *BotMessage) GetStatus() MessageStatus {
	if b == nil {
		return ""
	}
	return b.Status
}

func (b *BotMessage) GetLogic() *BotLogic {
	if b == nil {
		return nil
	}
	return b.Logic
}

func (b *BotMessage) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotMessage) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetCreatedAt(createdAt *time.Time) {
	b.CreatedAt = createdAt
	b.require(botMessageFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetUpdatedAt(updatedAt *time.Time) {
	b.UpdatedAt = updatedAt
	b.require(botMessageFieldUpdatedAt)
}

// SetConversationMessageId sets the ConversationMessageId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetConversationMessageId(conversationMessageId *EntityId) {
	b.ConversationMessageId = conversationMessageId
	b.require(botMessageFieldConversationMessageId)
}

// SetBotMessageType sets the BotMessageType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetBotMessageType(botMessageType BotConversationMessageType) {
	b.BotMessageType = botMessageType
	b.require(botMessageFieldBotMessageType)
}

// SetResponses sets the Responses field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetResponses(responses []*BotResponse) {
	b.Responses = responses
	b.require(botMessageFieldResponses)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetMetadata(metadata *BotResponseMetadata) {
	b.Metadata = metadata
	b.require(botMessageFieldMetadata)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetStatus(status MessageStatus) {
	b.Status = status
	b.require(botMessageFieldStatus)
}

// SetLogic sets the Logic field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotMessage) SetLogic(logic *BotLogic) {
	b.Logic = logic
	b.require(botMessageFieldLogic)
}

func (b *BotMessage) UnmarshalJSON(data []byte) error {
	type embed BotMessage
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*b),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*b = BotMessage(unmarshaler.embed)
	b.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	b.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotMessage) MarshalJSON() ([]byte, error) {
	type embed BotMessage
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*b),
		CreatedAt: internal.NewOptionalDateTime(b.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(b.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotMessage) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// This response should be rendered as a single button that starts an OAuth authorization flow.
var (
	botOAuthButtonResponseFieldButtonName = big.NewInt(1 << 0)
	botOAuthButtonResponseFieldUrl        = big.NewInt(1 << 1)
)

type BotOAuthButtonResponse struct {
	// Text that should be displayed to the user on the button.
	ButtonName string `json:"buttonName" url:"buttonName"`
	// The OAuth authorization URL to open when the button is clicked. Will only be provided on ask responses.
	Url *string `json:"url,omitempty" url:"url,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotOAuthButtonResponse) GetButtonName() string {
	if b == nil {
		return ""
	}
	return b.ButtonName
}

func (b *BotOAuthButtonResponse) GetUrl() *string {
	if b == nil {
		return nil
	}
	return b.Url
}

func (b *BotOAuthButtonResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotOAuthButtonResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetButtonName sets the ButtonName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotOAuthButtonResponse) SetButtonName(buttonName string) {
	b.ButtonName = buttonName
	b.require(botOAuthButtonResponseFieldButtonName)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotOAuthButtonResponse) SetUrl(url *string) {
	b.Url = url
	b.require(botOAuthButtonResponseFieldUrl)
}

func (b *BotOAuthButtonResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BotOAuthButtonResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotOAuthButtonResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotOAuthButtonResponse) MarshalJSON() ([]byte, error) {
	type embed BotOAuthButtonResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotOAuthButtonResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A structured object generated by the bot in response to a schema-based generateObject request. Should be rendered as JSON.
var (
	botObjectResponseFieldLabel  = big.NewInt(1 << 0)
	botObjectResponseFieldObject = big.NewInt(1 << 1)
)

type BotObjectResponse struct {
	// A human-readable name for the generated object, for use in the UI.
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// The generated object conforming to the provided schema.
	Object interface{} `json:"object" url:"object"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotObjectResponse) GetLabel() *string {
	if b == nil {
		return nil
	}
	return b.Label
}

func (b *BotObjectResponse) GetObject() interface{} {
	if b == nil {
		return nil
	}
	return b.Object
}

func (b *BotObjectResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotObjectResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetLabel sets the Label field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotObjectResponse) SetLabel(label *string) {
	b.Label = label
	b.require(botObjectResponseFieldLabel)
}

// SetObject sets the Object field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotObjectResponse) SetObject(object interface{}) {
	b.Object = object
	b.require(botObjectResponseFieldObject)
}

func (b *BotObjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BotObjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotObjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotObjectResponse) MarshalJSON() ([]byte, error) {
	type embed BotObjectResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotObjectResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BotResponse struct {
	Type        string
	Text        *BotTextResponse
	ActionForm  *BotActionFormResponse
	OauthButton *BotOAuthButtonResponse
	Chart       *BotChartResponse
	Object      *BotObjectResponse
}

func (b *BotResponse) GetType() string {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BotResponse) GetText() *BotTextResponse {
	if b == nil {
		return nil
	}
	return b.Text
}

func (b *BotResponse) GetActionForm() *BotActionFormResponse {
	if b == nil {
		return nil
	}
	return b.ActionForm
}

func (b *BotResponse) GetOauthButton() *BotOAuthButtonResponse {
	if b == nil {
		return nil
	}
	return b.OauthButton
}

func (b *BotResponse) GetChart() *BotChartResponse {
	if b == nil {
		return nil
	}
	return b.Chart
}

func (b *BotResponse) GetObject() *BotObjectResponse {
	if b == nil {
		return nil
	}
	return b.Object
}

func (b *BotResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	b.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", b)
	}
	switch unmarshaler.Type {
	case "text":
		value := new(BotTextResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Text = value
	case "actionForm":
		value := new(BotActionFormResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.ActionForm = value
	case "oauthButton":
		value := new(BotOAuthButtonResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.OauthButton = value
	case "chart":
		value := new(BotChartResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Chart = value
	case "object":
		value := new(BotObjectResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		b.Object = value
	}
	return nil
}

func (b BotResponse) MarshalJSON() ([]byte, error) {
	if err := b.validate(); err != nil {
		return nil, err
	}
	if b.Text != nil {
		return internal.MarshalJSONWithExtraProperty(b.Text, "type", "text")
	}
	if b.ActionForm != nil {
		return internal.MarshalJSONWithExtraProperty(b.ActionForm, "type", "actionForm")
	}
	if b.OauthButton != nil {
		return internal.MarshalJSONWithExtraProperty(b.OauthButton, "type", "oauthButton")
	}
	if b.Chart != nil {
		return internal.MarshalJSONWithExtraProperty(b.Chart, "type", "chart")
	}
	if b.Object != nil {
		return internal.MarshalJSONWithExtraProperty(b.Object, "type", "object")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", b)
}

type BotResponseVisitor interface {
	VisitText(*BotTextResponse) error
	VisitActionForm(*BotActionFormResponse) error
	VisitOauthButton(*BotOAuthButtonResponse) error
	VisitChart(*BotChartResponse) error
	VisitObject(*BotObjectResponse) error
}

func (b *BotResponse) Accept(visitor BotResponseVisitor) error {
	if b.Text != nil {
		return visitor.VisitText(b.Text)
	}
	if b.ActionForm != nil {
		return visitor.VisitActionForm(b.ActionForm)
	}
	if b.OauthButton != nil {
		return visitor.VisitOauthButton(b.OauthButton)
	}
	if b.Chart != nil {
		return visitor.VisitChart(b.Chart)
	}
	if b.Object != nil {
		return visitor.VisitObject(b.Object)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", b)
}

func (b *BotResponse) validate() error {
	if b == nil {
		return fmt.Errorf("type %T is nil", b)
	}
	var fields []string
	if b.Text != nil {
		fields = append(fields, "text")
	}
	if b.ActionForm != nil {
		fields = append(fields, "actionForm")
	}
	if b.OauthButton != nil {
		fields = append(fields, "oauthButton")
	}
	if b.Chart != nil {
		fields = append(fields, "chart")
	}
	if b.Object != nil {
		fields = append(fields, "object")
	}
	if len(fields) == 0 {
		if b.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", b, b.Type)
		}
		return fmt.Errorf("type %T is empty", b)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", b, fields)
	}
	if b.Type != "" {
		field := fields[0]
		if b.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				b,
				b.Type,
				b,
			)
		}
	}
	return nil
}

var (
	botResponseMetadataFieldFollowupQuestions = big.NewInt(1 << 0)
	botResponseMetadataFieldSources           = big.NewInt(1 << 1)
	botResponseMetadataFieldLanguage          = big.NewInt(1 << 2)
)

type BotResponseMetadata struct {
	FollowupQuestions []string  `json:"followupQuestions" url:"followupQuestions"`
	Sources           []*Source `json:"sources" url:"sources"`
	// The language of the message in ISO 639-1 code format
	Language *string `json:"language,omitempty" url:"language,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotResponseMetadata) GetFollowupQuestions() []string {
	if b == nil {
		return nil
	}
	return b.FollowupQuestions
}

func (b *BotResponseMetadata) GetSources() []*Source {
	if b == nil {
		return nil
	}
	return b.Sources
}

func (b *BotResponseMetadata) GetLanguage() *string {
	if b == nil {
		return nil
	}
	return b.Language
}

func (b *BotResponseMetadata) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotResponseMetadata) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetFollowupQuestions sets the FollowupQuestions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotResponseMetadata) SetFollowupQuestions(followupQuestions []string) {
	b.FollowupQuestions = followupQuestions
	b.require(botResponseMetadataFieldFollowupQuestions)
}

// SetSources sets the Sources field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotResponseMetadata) SetSources(sources []*Source) {
	b.Sources = sources
	b.require(botResponseMetadataFieldSources)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotResponseMetadata) SetLanguage(language *string) {
	b.Language = language
	b.require(botResponseMetadataFieldLanguage)
}

func (b *BotResponseMetadata) UnmarshalJSON(data []byte) error {
	type unmarshaler BotResponseMetadata
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotResponseMetadata(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotResponseMetadata) MarshalJSON() ([]byte, error) {
	type embed BotResponseMetadata
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotResponseMetadata) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

// A text answer to the user's question. Should be rendered to the user.
var (
	botTextResponseFieldText = big.NewInt(1 << 0)
)

type BotTextResponse struct {
	Text string `json:"text" url:"text"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BotTextResponse) GetText() string {
	if b == nil {
		return ""
	}
	return b.Text
}

func (b *BotTextResponse) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BotTextResponse) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BotTextResponse) SetText(text string) {
	b.Text = text
	b.require(botTextResponseFieldText)
}

func (b *BotTextResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler BotTextResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BotTextResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BotTextResponse) MarshalJSON() ([]byte, error) {
	type embed BotTextResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BotTextResponse) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

var (
	browserInfoFieldType      = big.NewInt(1 << 0)
	browserInfoFieldName      = big.NewInt(1 << 1)
	browserInfoFieldVersion   = big.NewInt(1 << 2)
	browserInfoFieldUserAgent = big.NewInt(1 << 3)
)

type BrowserInfo struct {
	Type      BrowserType `json:"type" url:"type"`
	Name      *string     `json:"name,omitempty" url:"name,omitempty"`
	Version   *string     `json:"version,omitempty" url:"version,omitempty"`
	UserAgent *string     `json:"userAgent,omitempty" url:"userAgent,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (b *BrowserInfo) GetType() BrowserType {
	if b == nil {
		return ""
	}
	return b.Type
}

func (b *BrowserInfo) GetName() *string {
	if b == nil {
		return nil
	}
	return b.Name
}

func (b *BrowserInfo) GetVersion() *string {
	if b == nil {
		return nil
	}
	return b.Version
}

func (b *BrowserInfo) GetUserAgent() *string {
	if b == nil {
		return nil
	}
	return b.UserAgent
}

func (b *BrowserInfo) GetExtraProperties() map[string]interface{} {
	return b.extraProperties
}

func (b *BrowserInfo) require(field *big.Int) {
	if b.explicitFields == nil {
		b.explicitFields = big.NewInt(0)
	}
	b.explicitFields.Or(b.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfo) SetType(type_ BrowserType) {
	b.Type = type_
	b.require(browserInfoFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfo) SetName(name *string) {
	b.Name = name
	b.require(browserInfoFieldName)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfo) SetVersion(version *string) {
	b.Version = version
	b.require(browserInfoFieldVersion)
}

// SetUserAgent sets the UserAgent field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (b *BrowserInfo) SetUserAgent(userAgent *string) {
	b.UserAgent = userAgent
	b.require(browserInfoFieldUserAgent)
}

func (b *BrowserInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler BrowserInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*b = BrowserInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *b)
	if err != nil {
		return err
	}
	b.extraProperties = extraProperties
	b.rawJSON = json.RawMessage(data)
	return nil
}

func (b *BrowserInfo) MarshalJSON() ([]byte, error) {
	type embed BrowserInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*b),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, b.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (b *BrowserInfo) String() string {
	if len(b.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(b.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(b); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", b)
}

type BrowserType string

const (
	BrowserTypeChrome  BrowserType = "CHROME"
	BrowserTypeFirefox BrowserType = "FIREFOX"
	BrowserTypeSafari  BrowserType = "SAFARI"
	BrowserTypeOpera   BrowserType = "OPERA"
	BrowserTypeEdge    BrowserType = "EDGE"
	BrowserTypeOther   BrowserType = "OTHER"
)

func NewBrowserTypeFromString(s string) (BrowserType, error) {
	switch s {
	case "CHROME":
		return BrowserTypeChrome, nil
	case "FIREFOX":
		return BrowserTypeFirefox, nil
	case "SAFARI":
		return BrowserTypeSafari, nil
	case "OPERA":
		return BrowserTypeOpera, nil
	case "EDGE":
		return BrowserTypeEdge, nil
	case "OTHER":
		return BrowserTypeOther, nil
	}
	var t BrowserType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BrowserType) Ptr() *BrowserType {
	return &b
}

type Capability string

const (
	CapabilityMarkdown           Capability = "MARKDOWN"
	CapabilityForms              Capability = "FORMS"
	CapabilityImages             Capability = "IMAGES"
	CapabilityChartsHighchartsTs Capability = "CHARTS_HIGHCHARTS_TS"
	CapabilityAsync              Capability = "ASYNC"
	CapabilityOauthButtons       Capability = "OAUTH_BUTTONS"
)

func NewCapabilityFromString(s string) (Capability, error) {
	switch s {
	case "MARKDOWN":
		return CapabilityMarkdown, nil
	case "FORMS":
		return CapabilityForms, nil
	case "IMAGES":
		return CapabilityImages, nil
	case "CHARTS_HIGHCHARTS_TS":
		return CapabilityChartsHighchartsTs, nil
	case "ASYNC":
		return CapabilityAsync, nil
	case "OAUTH_BUTTONS":
		return CapabilityOauthButtons, nil
	}
	var t Capability
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c Capability) Ptr() *Capability {
	return &c
}

type ChartSpecSchema string

const (
	ChartSpecSchemaHighchartsTs ChartSpecSchema = "HIGHCHARTS_TS"
)

func NewChartSpecSchemaFromString(s string) (ChartSpecSchema, error) {
	switch s {
	case "HIGHCHARTS_TS":
		return ChartSpecSchemaHighchartsTs, nil
	}
	var t ChartSpecSchema
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChartSpecSchema) Ptr() *ChartSpecSchema {
	return &c
}

var (
	contextInfoFieldAdditionalData = big.NewInt(1 << 0)
)

type ContextInfo struct {
	AdditionalData map[string]string `json:"additionalData" url:"additionalData"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ContextInfo) GetAdditionalData() map[string]string {
	if c == nil {
		return nil
	}
	return c.AdditionalData
}

func (c *ContextInfo) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ContextInfo) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetAdditionalData sets the AdditionalData field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ContextInfo) SetAdditionalData(additionalData map[string]string) {
	c.AdditionalData = additionalData
	c.require(contextInfoFieldAdditionalData)
}

func (c *ContextInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ContextInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ContextInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ContextInfo) MarshalJSON() ([]byte, error) {
	type embed ContextInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ContextInfo) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationAnalysisFieldUserRequest      = big.NewInt(1 << 0)
	conversationAnalysisFieldAgentResponse    = big.NewInt(1 << 1)
	conversationAnalysisFieldResolutionStatus = big.NewInt(1 << 2)
	conversationAnalysisFieldCategory         = big.NewInt(1 << 3)
	conversationAnalysisFieldSentiment        = big.NewInt(1 << 4)
	conversationAnalysisFieldQuality          = big.NewInt(1 << 5)
	conversationAnalysisFieldQualityReason    = big.NewInt(1 << 6)
	conversationAnalysisFieldResolvedByMaven  = big.NewInt(1 << 7)
	conversationAnalysisFieldPrimaryLanguage  = big.NewInt(1 << 8)
	conversationAnalysisFieldPredictedNps     = big.NewInt(1 << 9)
)

type ConversationAnalysis struct {
	// Generated user request summary of the conversation
	UserRequest *string `json:"userRequest,omitempty" url:"userRequest,omitempty"`
	// Generated agent response summary of the conversation
	AgentResponse *string `json:"agentResponse,omitempty" url:"agentResponse,omitempty"`
	// Generated resolution status of the conversation
	ResolutionStatus *string `json:"resolutionStatus,omitempty" url:"resolutionStatus,omitempty"`
	// Generated category of the conversation
	Category *string `json:"category,omitempty" url:"category,omitempty"`
	// Generated sentiment of the conversation
	Sentiment *Sentiment `json:"sentiment,omitempty" url:"sentiment,omitempty"`
	// Generated quality of the conversation
	Quality *Quality `json:"quality,omitempty" url:"quality,omitempty"`
	// If the quality of the conversation is `UNKNOWN` or `NEEDS_IMPROVEMENT` then a reason for the quality will be provided when possible.
	QualityReason *QualityReason `json:"qualityReason,omitempty" url:"qualityReason,omitempty"`
	// Whether the conversation was resolved by Maven
	ResolvedByMaven *bool `json:"resolvedByMaven,omitempty" url:"resolvedByMaven,omitempty"`
	// Primary language of the conversation in ISO 639-1 code format
	PrimaryLanguage *string `json:"primaryLanguage,omitempty" url:"primaryLanguage,omitempty"`
	// The predicted NPS of the conversation.
	PredictedNps *float64 `json:"predictedNps,omitempty" url:"predictedNps,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationAnalysis) GetUserRequest() *string {
	if c == nil {
		return nil
	}
	return c.UserRequest
}

func (c *ConversationAnalysis) GetAgentResponse() *string {
	if c == nil {
		return nil
	}
	return c.AgentResponse
}

func (c *ConversationAnalysis) GetResolutionStatus() *string {
	if c == nil {
		return nil
	}
	return c.ResolutionStatus
}

func (c *ConversationAnalysis) GetCategory() *string {
	if c == nil {
		return nil
	}
	return c.Category
}

func (c *ConversationAnalysis) GetSentiment() *Sentiment {
	if c == nil {
		return nil
	}
	return c.Sentiment
}

func (c *ConversationAnalysis) GetQuality() *Quality {
	if c == nil {
		return nil
	}
	return c.Quality
}

func (c *ConversationAnalysis) GetQualityReason() *QualityReason {
	if c == nil {
		return nil
	}
	return c.QualityReason
}

func (c *ConversationAnalysis) GetResolvedByMaven() *bool {
	if c == nil {
		return nil
	}
	return c.ResolvedByMaven
}

func (c *ConversationAnalysis) GetPrimaryLanguage() *string {
	if c == nil {
		return nil
	}
	return c.PrimaryLanguage
}

func (c *ConversationAnalysis) GetPredictedNps() *float64 {
	if c == nil {
		return nil
	}
	return c.PredictedNps
}

func (c *ConversationAnalysis) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationAnalysis) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetUserRequest sets the UserRequest field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetUserRequest(userRequest *string) {
	c.UserRequest = userRequest
	c.require(conversationAnalysisFieldUserRequest)
}

// SetAgentResponse sets the AgentResponse field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetAgentResponse(agentResponse *string) {
	c.AgentResponse = agentResponse
	c.require(conversationAnalysisFieldAgentResponse)
}

// SetResolutionStatus sets the ResolutionStatus field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetResolutionStatus(resolutionStatus *string) {
	c.ResolutionStatus = resolutionStatus
	c.require(conversationAnalysisFieldResolutionStatus)
}

// SetCategory sets the Category field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetCategory(category *string) {
	c.Category = category
	c.require(conversationAnalysisFieldCategory)
}

// SetSentiment sets the Sentiment field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetSentiment(sentiment *Sentiment) {
	c.Sentiment = sentiment
	c.require(conversationAnalysisFieldSentiment)
}

// SetQuality sets the Quality field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetQuality(quality *Quality) {
	c.Quality = quality
	c.require(conversationAnalysisFieldQuality)
}

// SetQualityReason sets the QualityReason field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetQualityReason(qualityReason *QualityReason) {
	c.QualityReason = qualityReason
	c.require(conversationAnalysisFieldQualityReason)
}

// SetResolvedByMaven sets the ResolvedByMaven field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetResolvedByMaven(resolvedByMaven *bool) {
	c.ResolvedByMaven = resolvedByMaven
	c.require(conversationAnalysisFieldResolvedByMaven)
}

// SetPrimaryLanguage sets the PrimaryLanguage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetPrimaryLanguage(primaryLanguage *string) {
	c.PrimaryLanguage = primaryLanguage
	c.require(conversationAnalysisFieldPrimaryLanguage)
}

// SetPredictedNps sets the PredictedNps field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationAnalysis) SetPredictedNps(predictedNps *float64) {
	c.PredictedNps = predictedNps
	c.require(conversationAnalysisFieldPredictedNps)
}

func (c *ConversationAnalysis) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationAnalysis
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationAnalysis(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationAnalysis) MarshalJSON() ([]byte, error) {
	type embed ConversationAnalysis
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationAnalysis) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationExecutedActionPreconditionFieldOperator = big.NewInt(1 << 0)
	conversationExecutedActionPreconditionFieldActionId = big.NewInt(1 << 1)
	conversationExecutedActionPreconditionFieldAppId    = big.NewInt(1 << 2)
)

type ConversationExecutedActionPrecondition struct {
	// Operator to apply to this precondition
	Operator *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`
	// ID of an action that must have executed in this conversation for the precondition to be met
	ActionId string `json:"actionId" url:"actionId"`
	// App ID that the given actionId belongs to. If not provided, the calling appId will be used.
	AppId *string `json:"appId,omitempty" url:"appId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationExecutedActionPrecondition) GetOperator() *PreconditionOperator {
	if c == nil {
		return nil
	}
	return c.Operator
}

func (c *ConversationExecutedActionPrecondition) GetActionId() string {
	if c == nil {
		return ""
	}
	return c.ActionId
}

func (c *ConversationExecutedActionPrecondition) GetAppId() *string {
	if c == nil {
		return nil
	}
	return c.AppId
}

func (c *ConversationExecutedActionPrecondition) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationExecutedActionPrecondition) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationExecutedActionPrecondition) SetOperator(operator *PreconditionOperator) {
	c.Operator = operator
	c.require(conversationExecutedActionPreconditionFieldOperator)
}

// SetActionId sets the ActionId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationExecutedActionPrecondition) SetActionId(actionId string) {
	c.ActionId = actionId
	c.require(conversationExecutedActionPreconditionFieldActionId)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationExecutedActionPrecondition) SetAppId(appId *string) {
	c.AppId = appId
	c.require(conversationExecutedActionPreconditionFieldAppId)
}

func (c *ConversationExecutedActionPrecondition) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationExecutedActionPrecondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationExecutedActionPrecondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationExecutedActionPrecondition) MarshalJSON() ([]byte, error) {
	type embed ConversationExecutedActionPrecondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationExecutedActionPrecondition) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationInformationFieldConversationId = big.NewInt(1 << 0)
)

type ConversationInformation struct {
	// Unique identifier for the conversation.
	ConversationId *EntityIdWithoutAgent `json:"conversationId" url:"conversationId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationInformation) GetConversationId() *EntityIdWithoutAgent {
	if c == nil {
		return nil
	}
	return c.ConversationId
}

func (c *ConversationInformation) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationInformation) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetConversationId sets the ConversationId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationInformation) SetConversationId(conversationId *EntityIdWithoutAgent) {
	c.ConversationId = conversationId
	c.require(conversationInformationFieldConversationId)
}

func (c *ConversationInformation) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationInformation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationInformation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationInformation) MarshalJSON() ([]byte, error) {
	type embed ConversationInformation
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationInformation) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationMessageBaseFieldCreatedAt = big.NewInt(1 << 0)
	conversationMessageBaseFieldUpdatedAt = big.NewInt(1 << 1)
)

type ConversationMessageBase struct {
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationMessageBase) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *ConversationMessageBase) GetUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *ConversationMessageBase) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationMessageBase) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMessageBase) SetCreatedAt(createdAt *time.Time) {
	c.CreatedAt = createdAt
	c.require(conversationMessageBaseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationMessageBase) SetUpdatedAt(updatedAt *time.Time) {
	c.UpdatedAt = updatedAt
	c.require(conversationMessageBaseFieldUpdatedAt)
}

func (c *ConversationMessageBase) UnmarshalJSON(data []byte) error {
	type embed ConversationMessageBase
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationMessageBase(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationMessageBase) MarshalJSON() ([]byte, error) {
	type embed ConversationMessageBase
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewOptionalDateTime(c.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationMessageBase) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ConversationMessageResponse struct {
	Type string
	User *UserMessage
	Bot  *BotMessage
}

func (c *ConversationMessageResponse) GetType() string {
	if c == nil {
		return ""
	}
	return c.Type
}

func (c *ConversationMessageResponse) GetUser() *UserMessage {
	if c == nil {
		return nil
	}
	return c.User
}

func (c *ConversationMessageResponse) GetBot() *BotMessage {
	if c == nil {
		return nil
	}
	return c.Bot
}

func (c *ConversationMessageResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", c)
	}
	switch unmarshaler.Type {
	case "user":
		value := new(UserMessage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.User = value
	case "bot":
		value := new(BotMessage)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Bot = value
	}
	return nil
}

func (c ConversationMessageResponse) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.User != nil {
		return internal.MarshalJSONWithExtraProperty(c.User, "type", "user")
	}
	if c.Bot != nil {
		return internal.MarshalJSONWithExtraProperty(c.Bot, "type", "bot")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ConversationMessageResponseVisitor interface {
	VisitUser(*UserMessage) error
	VisitBot(*BotMessage) error
}

func (c *ConversationMessageResponse) Accept(visitor ConversationMessageResponseVisitor) error {
	if c.User != nil {
		return visitor.VisitUser(c.User)
	}
	if c.Bot != nil {
		return visitor.VisitBot(c.Bot)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *ConversationMessageResponse) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.User != nil {
		fields = append(fields, "user")
	}
	if c.Bot != nil {
		fields = append(fields, "bot")
	}
	if len(fields) == 0 {
		if c.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.Type)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.Type != "" {
		field := fields[0]
		if c.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.Type,
				c,
			)
		}
	}
	return nil
}

type ConversationPrecondition struct {
	ConversationPreconditionType string
	Tags                         *TagsPrecondition
	Metadata                     *MetadataPrecondition
	ActionExecuted               *ConversationExecutedActionPrecondition
	ResponseConfig               *ResponseConfigPrecondition
	App                          *AppPrecondition
}

func (c *ConversationPrecondition) GetConversationPreconditionType() string {
	if c == nil {
		return ""
	}
	return c.ConversationPreconditionType
}

func (c *ConversationPrecondition) GetTags() *TagsPrecondition {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *ConversationPrecondition) GetMetadata() *MetadataPrecondition {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ConversationPrecondition) GetActionExecuted() *ConversationExecutedActionPrecondition {
	if c == nil {
		return nil
	}
	return c.ActionExecuted
}

func (c *ConversationPrecondition) GetResponseConfig() *ResponseConfigPrecondition {
	if c == nil {
		return nil
	}
	return c.ResponseConfig
}

func (c *ConversationPrecondition) GetApp() *AppPrecondition {
	if c == nil {
		return nil
	}
	return c.App
}

func (c *ConversationPrecondition) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ConversationPreconditionType string `json:"conversationPreconditionType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	c.ConversationPreconditionType = unmarshaler.ConversationPreconditionType
	if unmarshaler.ConversationPreconditionType == "" {
		return fmt.Errorf("%T did not include discriminant conversationPreconditionType", c)
	}
	switch unmarshaler.ConversationPreconditionType {
	case "tags":
		value := new(TagsPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Tags = value
	case "metadata":
		value := new(MetadataPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.Metadata = value
	case "actionExecuted":
		value := new(ConversationExecutedActionPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ActionExecuted = value
	case "responseConfig":
		value := new(ResponseConfigPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.ResponseConfig = value
	case "app":
		value := new(AppPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		c.App = value
	}
	return nil
}

func (c ConversationPrecondition) MarshalJSON() ([]byte, error) {
	if err := c.validate(); err != nil {
		return nil, err
	}
	if c.Tags != nil {
		return internal.MarshalJSONWithExtraProperty(c.Tags, "conversationPreconditionType", "tags")
	}
	if c.Metadata != nil {
		return internal.MarshalJSONWithExtraProperty(c.Metadata, "conversationPreconditionType", "metadata")
	}
	if c.ActionExecuted != nil {
		return internal.MarshalJSONWithExtraProperty(c.ActionExecuted, "conversationPreconditionType", "actionExecuted")
	}
	if c.ResponseConfig != nil {
		return internal.MarshalJSONWithExtraProperty(c.ResponseConfig, "conversationPreconditionType", "responseConfig")
	}
	if c.App != nil {
		return internal.MarshalJSONWithExtraProperty(c.App, "conversationPreconditionType", "app")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", c)
}

type ConversationPreconditionVisitor interface {
	VisitTags(*TagsPrecondition) error
	VisitMetadata(*MetadataPrecondition) error
	VisitActionExecuted(*ConversationExecutedActionPrecondition) error
	VisitResponseConfig(*ResponseConfigPrecondition) error
	VisitApp(*AppPrecondition) error
}

func (c *ConversationPrecondition) Accept(visitor ConversationPreconditionVisitor) error {
	if c.Tags != nil {
		return visitor.VisitTags(c.Tags)
	}
	if c.Metadata != nil {
		return visitor.VisitMetadata(c.Metadata)
	}
	if c.ActionExecuted != nil {
		return visitor.VisitActionExecuted(c.ActionExecuted)
	}
	if c.ResponseConfig != nil {
		return visitor.VisitResponseConfig(c.ResponseConfig)
	}
	if c.App != nil {
		return visitor.VisitApp(c.App)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", c)
}

func (c *ConversationPrecondition) validate() error {
	if c == nil {
		return fmt.Errorf("type %T is nil", c)
	}
	var fields []string
	if c.Tags != nil {
		fields = append(fields, "tags")
	}
	if c.Metadata != nil {
		fields = append(fields, "metadata")
	}
	if c.ActionExecuted != nil {
		fields = append(fields, "actionExecuted")
	}
	if c.ResponseConfig != nil {
		fields = append(fields, "responseConfig")
	}
	if c.App != nil {
		fields = append(fields, "app")
	}
	if len(fields) == 0 {
		if c.ConversationPreconditionType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", c, c.ConversationPreconditionType)
		}
		return fmt.Errorf("type %T is empty", c)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", c, fields)
	}
	if c.ConversationPreconditionType != "" {
		field := fields[0]
		if c.ConversationPreconditionType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				c,
				c.ConversationPreconditionType,
				c,
			)
		}
	}
	return nil
}

var (
	conversationPreviewFieldResponseConfig    = big.NewInt(1 << 0)
	conversationPreviewFieldSubject           = big.NewInt(1 << 1)
	conversationPreviewFieldUrl               = big.NewInt(1 << 2)
	conversationPreviewFieldCreatedAt         = big.NewInt(1 << 3)
	conversationPreviewFieldUpdatedAt         = big.NewInt(1 << 4)
	conversationPreviewFieldTags              = big.NewInt(1 << 5)
	conversationPreviewFieldMetadata          = big.NewInt(1 << 6)
	conversationPreviewFieldAllMetadata       = big.NewInt(1 << 7)
	conversationPreviewFieldConversationId    = big.NewInt(1 << 8)
	conversationPreviewFieldAnalysis          = big.NewInt(1 << 9)
	conversationPreviewFieldSummary           = big.NewInt(1 << 10)
	conversationPreviewFieldDeleted           = big.NewInt(1 << 11)
	conversationPreviewFieldOpen              = big.NewInt(1 << 12)
	conversationPreviewFieldLlmEnabled        = big.NewInt(1 << 13)
	conversationPreviewFieldSimulationContext = big.NewInt(1 << 14)
)

type ConversationPreview struct {
	// Optional configurations for responses to this conversation
	ResponseConfig *ResponseConfig `json:"responseConfig,omitempty" url:"responseConfig,omitempty"`
	// The subject of the conversation
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The url of the conversation
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// The tags of the conversation. Used for filtering in Agent Designer.
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// The metadata of the conversation supplied by the app which created the conversation.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// All metadata for the conversation. Keyed by appId.
	AllMetadata map[string]map[string]string `json:"allMetadata" url:"allMetadata"`
	// The ID that uniquely identifies this conversation
	ConversationId *EntityId `json:"conversationId" url:"conversationId"`
	// An analysis of the conversation. Fields are generated by Maven via an analysis of user messages. This object is calculated on a delay. Fields will not be up to date on ask requests.
	Analysis *ConversationAnalysis `json:"analysis" url:"analysis"`
	// A summary of the conversation. Fields are calculated from conversation data. Unlike analysis, all fields can be derived from other data available in the API. This object is provided as a convenience and is calculated on a delay. Fields will not be up to date on ask requests.
	Summary *ConversationSummary `json:"summary" url:"summary"`
	// Whether the conversation user-specific data has been deleted. See `deleteConversation` for details.
	Deleted bool `json:"deleted" url:"deleted"`
	// Whether the conversation is able to receive asynchronous messages.
	// Only applicable if a conversation is initialized with the `ASYNC` capability. Defaults to true. Can be closed using the `PATCH` API.
	Open bool `json:"open" url:"open"`
	// Whether the LLM is enabled for this conversation.
	// If true, `USER` messages sent via the ask API will be sent to the LLM and a `BOT_RESPONSE` or `BOT_SUGGESTION` message will be generated.
	// If false, `USER` messages will not be sent to the LLM.
	LlmEnabled bool `json:"llmEnabled" url:"llmEnabled"`
	// Additional context used for simulation runs. When present, this conversation is treated as a simulation.
	// Simulation conversations are excluded from normal search results unless explicitly included via the `simulationFilter` field.
	SimulationContext *SimulationContext `json:"simulationContext,omitempty" url:"simulationContext,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationPreview) GetResponseConfig() *ResponseConfig {
	if c == nil {
		return nil
	}
	return c.ResponseConfig
}

func (c *ConversationPreview) GetSubject() *string {
	if c == nil {
		return nil
	}
	return c.Subject
}

func (c *ConversationPreview) GetUrl() *string {
	if c == nil {
		return nil
	}
	return c.Url
}

func (c *ConversationPreview) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *ConversationPreview) GetUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *ConversationPreview) GetTags() []string {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *ConversationPreview) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ConversationPreview) GetAllMetadata() map[string]map[string]string {
	if c == nil {
		return nil
	}
	return c.AllMetadata
}

func (c *ConversationPreview) GetConversationId() *EntityId {
	if c == nil {
		return nil
	}
	return c.ConversationId
}

func (c *ConversationPreview) GetAnalysis() *ConversationAnalysis {
	if c == nil {
		return nil
	}
	return c.Analysis
}

func (c *ConversationPreview) GetSummary() *ConversationSummary {
	if c == nil {
		return nil
	}
	return c.Summary
}

func (c *ConversationPreview) GetDeleted() bool {
	if c == nil {
		return false
	}
	return c.Deleted
}

func (c *ConversationPreview) GetOpen() bool {
	if c == nil {
		return false
	}
	return c.Open
}

func (c *ConversationPreview) GetLlmEnabled() bool {
	if c == nil {
		return false
	}
	return c.LlmEnabled
}

func (c *ConversationPreview) GetSimulationContext() *SimulationContext {
	if c == nil {
		return nil
	}
	return c.SimulationContext
}

func (c *ConversationPreview) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationPreview) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetResponseConfig sets the ResponseConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetResponseConfig(responseConfig *ResponseConfig) {
	c.ResponseConfig = responseConfig
	c.require(conversationPreviewFieldResponseConfig)
}

// SetSubject sets the Subject field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetSubject(subject *string) {
	c.Subject = subject
	c.require(conversationPreviewFieldSubject)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetUrl(url *string) {
	c.Url = url
	c.require(conversationPreviewFieldUrl)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetCreatedAt(createdAt *time.Time) {
	c.CreatedAt = createdAt
	c.require(conversationPreviewFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetUpdatedAt(updatedAt *time.Time) {
	c.UpdatedAt = updatedAt
	c.require(conversationPreviewFieldUpdatedAt)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetTags(tags []string) {
	c.Tags = tags
	c.require(conversationPreviewFieldTags)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetMetadata(metadata map[string]string) {
	c.Metadata = metadata
	c.require(conversationPreviewFieldMetadata)
}

// SetAllMetadata sets the AllMetadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetAllMetadata(allMetadata map[string]map[string]string) {
	c.AllMetadata = allMetadata
	c.require(conversationPreviewFieldAllMetadata)
}

// SetConversationId sets the ConversationId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetConversationId(conversationId *EntityId) {
	c.ConversationId = conversationId
	c.require(conversationPreviewFieldConversationId)
}

// SetAnalysis sets the Analysis field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetAnalysis(analysis *ConversationAnalysis) {
	c.Analysis = analysis
	c.require(conversationPreviewFieldAnalysis)
}

// SetSummary sets the Summary field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetSummary(summary *ConversationSummary) {
	c.Summary = summary
	c.require(conversationPreviewFieldSummary)
}

// SetDeleted sets the Deleted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetDeleted(deleted bool) {
	c.Deleted = deleted
	c.require(conversationPreviewFieldDeleted)
}

// SetOpen sets the Open field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetOpen(open bool) {
	c.Open = open
	c.require(conversationPreviewFieldOpen)
}

// SetLlmEnabled sets the LlmEnabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetLlmEnabled(llmEnabled bool) {
	c.LlmEnabled = llmEnabled
	c.require(conversationPreviewFieldLlmEnabled)
}

// SetSimulationContext sets the SimulationContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationPreview) SetSimulationContext(simulationContext *SimulationContext) {
	c.SimulationContext = simulationContext
	c.require(conversationPreviewFieldSimulationContext)
}

func (c *ConversationPreview) UnmarshalJSON(data []byte) error {
	type embed ConversationPreview
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationPreview(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationPreview) MarshalJSON() ([]byte, error) {
	type embed ConversationPreview
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewOptionalDateTime(c.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationPreview) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationResponseFieldResponseConfig    = big.NewInt(1 << 0)
	conversationResponseFieldSubject           = big.NewInt(1 << 1)
	conversationResponseFieldUrl               = big.NewInt(1 << 2)
	conversationResponseFieldCreatedAt         = big.NewInt(1 << 3)
	conversationResponseFieldUpdatedAt         = big.NewInt(1 << 4)
	conversationResponseFieldTags              = big.NewInt(1 << 5)
	conversationResponseFieldMetadata          = big.NewInt(1 << 6)
	conversationResponseFieldAllMetadata       = big.NewInt(1 << 7)
	conversationResponseFieldConversationId    = big.NewInt(1 << 8)
	conversationResponseFieldAnalysis          = big.NewInt(1 << 9)
	conversationResponseFieldSummary           = big.NewInt(1 << 10)
	conversationResponseFieldDeleted           = big.NewInt(1 << 11)
	conversationResponseFieldOpen              = big.NewInt(1 << 12)
	conversationResponseFieldLlmEnabled        = big.NewInt(1 << 13)
	conversationResponseFieldSimulationContext = big.NewInt(1 << 14)
	conversationResponseFieldMessages          = big.NewInt(1 << 15)
	conversationResponseFieldAttachments       = big.NewInt(1 << 16)
)

type ConversationResponse struct {
	// Optional configurations for responses to this conversation
	ResponseConfig *ResponseConfig `json:"responseConfig,omitempty" url:"responseConfig,omitempty"`
	// The subject of the conversation
	Subject *string `json:"subject,omitempty" url:"subject,omitempty"`
	// The url of the conversation
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// The tags of the conversation. Used for filtering in Agent Designer.
	Tags []string `json:"tags,omitempty" url:"tags,omitempty"`
	// The metadata of the conversation supplied by the app which created the conversation.
	Metadata map[string]string `json:"metadata,omitempty" url:"metadata,omitempty"`
	// All metadata for the conversation. Keyed by appId.
	AllMetadata map[string]map[string]string `json:"allMetadata" url:"allMetadata"`
	// The ID that uniquely identifies this conversation
	ConversationId *EntityId `json:"conversationId" url:"conversationId"`
	// An analysis of the conversation. Fields are generated by Maven via an analysis of user messages. This object is calculated on a delay. Fields will not be up to date on ask requests.
	Analysis *ConversationAnalysis `json:"analysis" url:"analysis"`
	// A summary of the conversation. Fields are calculated from conversation data. Unlike analysis, all fields can be derived from other data available in the API. This object is provided as a convenience and is calculated on a delay. Fields will not be up to date on ask requests.
	Summary *ConversationSummary `json:"summary" url:"summary"`
	// Whether the conversation user-specific data has been deleted. See `deleteConversation` for details.
	Deleted bool `json:"deleted" url:"deleted"`
	// Whether the conversation is able to receive asynchronous messages.
	// Only applicable if a conversation is initialized with the `ASYNC` capability. Defaults to true. Can be closed using the `PATCH` API.
	Open bool `json:"open" url:"open"`
	// Whether the LLM is enabled for this conversation.
	// If true, `USER` messages sent via the ask API will be sent to the LLM and a `BOT_RESPONSE` or `BOT_SUGGESTION` message will be generated.
	// If false, `USER` messages will not be sent to the LLM.
	LlmEnabled bool `json:"llmEnabled" url:"llmEnabled"`
	// Additional context used for simulation runs. When present, this conversation is treated as a simulation.
	// Simulation conversations are excluded from normal search results unless explicitly included via the `simulationFilter` field.
	SimulationContext *SimulationContext `json:"simulationContext,omitempty" url:"simulationContext,omitempty"`
	// The messages in the conversation
	Messages []*ConversationMessageResponse `json:"messages" url:"messages"`
	// The attachments associated with this conversation. Additional attachments may be associated to individual messages.
	//
	// Message attachments are included in LLM context, conversation attachments are not.
	Attachments []*AttachmentResponse `json:"attachments" url:"attachments"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationResponse) GetResponseConfig() *ResponseConfig {
	if c == nil {
		return nil
	}
	return c.ResponseConfig
}

func (c *ConversationResponse) GetSubject() *string {
	if c == nil {
		return nil
	}
	return c.Subject
}

func (c *ConversationResponse) GetUrl() *string {
	if c == nil {
		return nil
	}
	return c.Url
}

func (c *ConversationResponse) GetCreatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.CreatedAt
}

func (c *ConversationResponse) GetUpdatedAt() *time.Time {
	if c == nil {
		return nil
	}
	return c.UpdatedAt
}

func (c *ConversationResponse) GetTags() []string {
	if c == nil {
		return nil
	}
	return c.Tags
}

func (c *ConversationResponse) GetMetadata() map[string]string {
	if c == nil {
		return nil
	}
	return c.Metadata
}

func (c *ConversationResponse) GetAllMetadata() map[string]map[string]string {
	if c == nil {
		return nil
	}
	return c.AllMetadata
}

func (c *ConversationResponse) GetConversationId() *EntityId {
	if c == nil {
		return nil
	}
	return c.ConversationId
}

func (c *ConversationResponse) GetAnalysis() *ConversationAnalysis {
	if c == nil {
		return nil
	}
	return c.Analysis
}

func (c *ConversationResponse) GetSummary() *ConversationSummary {
	if c == nil {
		return nil
	}
	return c.Summary
}

func (c *ConversationResponse) GetDeleted() bool {
	if c == nil {
		return false
	}
	return c.Deleted
}

func (c *ConversationResponse) GetOpen() bool {
	if c == nil {
		return false
	}
	return c.Open
}

func (c *ConversationResponse) GetLlmEnabled() bool {
	if c == nil {
		return false
	}
	return c.LlmEnabled
}

func (c *ConversationResponse) GetSimulationContext() *SimulationContext {
	if c == nil {
		return nil
	}
	return c.SimulationContext
}

func (c *ConversationResponse) GetMessages() []*ConversationMessageResponse {
	if c == nil {
		return nil
	}
	return c.Messages
}

func (c *ConversationResponse) GetAttachments() []*AttachmentResponse {
	if c == nil {
		return nil
	}
	return c.Attachments
}

func (c *ConversationResponse) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationResponse) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetResponseConfig sets the ResponseConfig field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetResponseConfig(responseConfig *ResponseConfig) {
	c.ResponseConfig = responseConfig
	c.require(conversationResponseFieldResponseConfig)
}

// SetSubject sets the Subject field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetSubject(subject *string) {
	c.Subject = subject
	c.require(conversationResponseFieldSubject)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetUrl(url *string) {
	c.Url = url
	c.require(conversationResponseFieldUrl)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetCreatedAt(createdAt *time.Time) {
	c.CreatedAt = createdAt
	c.require(conversationResponseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetUpdatedAt(updatedAt *time.Time) {
	c.UpdatedAt = updatedAt
	c.require(conversationResponseFieldUpdatedAt)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetTags(tags []string) {
	c.Tags = tags
	c.require(conversationResponseFieldTags)
}

// SetMetadata sets the Metadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetMetadata(metadata map[string]string) {
	c.Metadata = metadata
	c.require(conversationResponseFieldMetadata)
}

// SetAllMetadata sets the AllMetadata field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetAllMetadata(allMetadata map[string]map[string]string) {
	c.AllMetadata = allMetadata
	c.require(conversationResponseFieldAllMetadata)
}

// SetConversationId sets the ConversationId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetConversationId(conversationId *EntityId) {
	c.ConversationId = conversationId
	c.require(conversationResponseFieldConversationId)
}

// SetAnalysis sets the Analysis field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetAnalysis(analysis *ConversationAnalysis) {
	c.Analysis = analysis
	c.require(conversationResponseFieldAnalysis)
}

// SetSummary sets the Summary field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetSummary(summary *ConversationSummary) {
	c.Summary = summary
	c.require(conversationResponseFieldSummary)
}

// SetDeleted sets the Deleted field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetDeleted(deleted bool) {
	c.Deleted = deleted
	c.require(conversationResponseFieldDeleted)
}

// SetOpen sets the Open field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetOpen(open bool) {
	c.Open = open
	c.require(conversationResponseFieldOpen)
}

// SetLlmEnabled sets the LlmEnabled field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetLlmEnabled(llmEnabled bool) {
	c.LlmEnabled = llmEnabled
	c.require(conversationResponseFieldLlmEnabled)
}

// SetSimulationContext sets the SimulationContext field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetSimulationContext(simulationContext *SimulationContext) {
	c.SimulationContext = simulationContext
	c.require(conversationResponseFieldSimulationContext)
}

// SetMessages sets the Messages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetMessages(messages []*ConversationMessageResponse) {
	c.Messages = messages
	c.require(conversationResponseFieldMessages)
}

// SetAttachments sets the Attachments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationResponse) SetAttachments(attachments []*AttachmentResponse) {
	c.Attachments = attachments
	c.require(conversationResponseFieldAttachments)
}

func (c *ConversationResponse) UnmarshalJSON(data []byte) error {
	type embed ConversationResponse
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = ConversationResponse(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	c.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationResponse) MarshalJSON() ([]byte, error) {
	type embed ConversationResponse
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*c),
		CreatedAt: internal.NewOptionalDateTime(c.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(c.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationResponse) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	conversationSummaryFieldActionIds               = big.NewInt(1 << 0)
	conversationSummaryFieldIncompleteActionIds     = big.NewInt(1 << 1)
	conversationSummaryFieldInsertCount             = big.NewInt(1 << 2)
	conversationSummaryFieldThumbsUpCount           = big.NewInt(1 << 3)
	conversationSummaryFieldThumbsDownCount         = big.NewInt(1 << 4)
	conversationSummaryFieldHandoffCount            = big.NewInt(1 << 5)
	conversationSummaryFieldUserMessageCount        = big.NewInt(1 << 6)
	conversationSummaryFieldHandleTime              = big.NewInt(1 << 7)
	conversationSummaryFieldHumanAgentResponseDelay = big.NewInt(1 << 8)
	conversationSummaryFieldHumanAgents             = big.NewInt(1 << 9)
	conversationSummaryFieldHumanAgentsWithInserts  = big.NewInt(1 << 10)
	conversationSummaryFieldUsers                   = big.NewInt(1 << 11)
	conversationSummaryFieldUserIdentifiers         = big.NewInt(1 << 12)
	conversationSummaryFieldLastUserMessage         = big.NewInt(1 << 13)
	conversationSummaryFieldLastBotMessage          = big.NewInt(1 << 14)
)

type ConversationSummary struct {
	// The IDs of the actions that were taken by Maven in the conversation
	ActionIds []*EntityIdWithoutAgent `json:"actionIds" url:"actionIds"`
	// The IDs of the actions that were taken by Maven but not completed in the conversation. Occurs when the user is shown an action form but does not submit it.
	IncompleteActionIds []*EntityIdWithoutAgent `json:"incompleteActionIds" url:"incompleteActionIds"`
	// The number of insert events on messages in the conversation.
	InsertCount int `json:"insertCount" url:"insertCount"`
	// The number of thumbs up events on messages in the conversation.
	ThumbsUpCount int `json:"thumbsUpCount" url:"thumbsUpCount"`
	// The number of thumbs down events on messages in the conversation.
	ThumbsDownCount int `json:"thumbsDownCount" url:"thumbsDownCount"`
	// The number of bot response messages that failed and returned the Agent's system fallback message.
	HandoffCount int `json:"handoffCount" url:"handoffCount"`
	// The number of messages of type `USER` in the conversation.
	UserMessageCount int `json:"userMessageCount" url:"userMessageCount"`
	// The total time in milliseconds that the user spent interacting with the conversation.
	// Calculated by taking the timestamp of the last message in the conversation minus the timestamp of the first message.
	HandleTime *int64 `json:"handleTime,omitempty" url:"handleTime,omitempty"`
	// The time in milliseconds that elapsed before a human agent responded to the conversation.
	// Calculated by taking the timestamp of the first message of type `HUMAN_AGENT`
	// minus the timestamp of the first message in the conversation.
	//
	// Will not be provided if the conversation does not have a message of type `HUMAN_AGENT`.
	HumanAgentResponseDelay *int64 `json:"humanAgentResponseDelay,omitempty" url:"humanAgentResponseDelay,omitempty"`
	// The names of all users that have a message of type `HUMAN_AGENT` on the conversation.
	HumanAgents []string `json:"humanAgents" url:"humanAgents"`
	// The names of all users that have an associated insert event on the conversation.
	HumanAgentsWithInserts []string `json:"humanAgentsWithInserts" url:"humanAgentsWithInserts"`
	// The names of all users that have a message of type `USER` on the conversation.
	Users []string `json:"users" url:"users"`
	// The user identifiers (typically email addresses or phone numbers) of all users that have a message of type `USER` on the conversation.
	UserIdentifiers []string `json:"userIdentifiers" url:"userIdentifiers"`
	// The text of the last user message in the conversation.
	LastUserMessage *string `json:"lastUserMessage,omitempty" url:"lastUserMessage,omitempty"`
	// The text of the last bot message in the conversation.
	LastBotMessage *string `json:"lastBotMessage,omitempty" url:"lastBotMessage,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (c *ConversationSummary) GetActionIds() []*EntityIdWithoutAgent {
	if c == nil {
		return nil
	}
	return c.ActionIds
}

func (c *ConversationSummary) GetIncompleteActionIds() []*EntityIdWithoutAgent {
	if c == nil {
		return nil
	}
	return c.IncompleteActionIds
}

func (c *ConversationSummary) GetInsertCount() int {
	if c == nil {
		return 0
	}
	return c.InsertCount
}

func (c *ConversationSummary) GetThumbsUpCount() int {
	if c == nil {
		return 0
	}
	return c.ThumbsUpCount
}

func (c *ConversationSummary) GetThumbsDownCount() int {
	if c == nil {
		return 0
	}
	return c.ThumbsDownCount
}

func (c *ConversationSummary) GetHandoffCount() int {
	if c == nil {
		return 0
	}
	return c.HandoffCount
}

func (c *ConversationSummary) GetUserMessageCount() int {
	if c == nil {
		return 0
	}
	return c.UserMessageCount
}

func (c *ConversationSummary) GetHandleTime() *int64 {
	if c == nil {
		return nil
	}
	return c.HandleTime
}

func (c *ConversationSummary) GetHumanAgentResponseDelay() *int64 {
	if c == nil {
		return nil
	}
	return c.HumanAgentResponseDelay
}

func (c *ConversationSummary) GetHumanAgents() []string {
	if c == nil {
		return nil
	}
	return c.HumanAgents
}

func (c *ConversationSummary) GetHumanAgentsWithInserts() []string {
	if c == nil {
		return nil
	}
	return c.HumanAgentsWithInserts
}

func (c *ConversationSummary) GetUsers() []string {
	if c == nil {
		return nil
	}
	return c.Users
}

func (c *ConversationSummary) GetUserIdentifiers() []string {
	if c == nil {
		return nil
	}
	return c.UserIdentifiers
}

func (c *ConversationSummary) GetLastUserMessage() *string {
	if c == nil {
		return nil
	}
	return c.LastUserMessage
}

func (c *ConversationSummary) GetLastBotMessage() *string {
	if c == nil {
		return nil
	}
	return c.LastBotMessage
}

func (c *ConversationSummary) GetExtraProperties() map[string]interface{} {
	return c.extraProperties
}

func (c *ConversationSummary) require(field *big.Int) {
	if c.explicitFields == nil {
		c.explicitFields = big.NewInt(0)
	}
	c.explicitFields.Or(c.explicitFields, field)
}

// SetActionIds sets the ActionIds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetActionIds(actionIds []*EntityIdWithoutAgent) {
	c.ActionIds = actionIds
	c.require(conversationSummaryFieldActionIds)
}

// SetIncompleteActionIds sets the IncompleteActionIds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetIncompleteActionIds(incompleteActionIds []*EntityIdWithoutAgent) {
	c.IncompleteActionIds = incompleteActionIds
	c.require(conversationSummaryFieldIncompleteActionIds)
}

// SetInsertCount sets the InsertCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetInsertCount(insertCount int) {
	c.InsertCount = insertCount
	c.require(conversationSummaryFieldInsertCount)
}

// SetThumbsUpCount sets the ThumbsUpCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetThumbsUpCount(thumbsUpCount int) {
	c.ThumbsUpCount = thumbsUpCount
	c.require(conversationSummaryFieldThumbsUpCount)
}

// SetThumbsDownCount sets the ThumbsDownCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetThumbsDownCount(thumbsDownCount int) {
	c.ThumbsDownCount = thumbsDownCount
	c.require(conversationSummaryFieldThumbsDownCount)
}

// SetHandoffCount sets the HandoffCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetHandoffCount(handoffCount int) {
	c.HandoffCount = handoffCount
	c.require(conversationSummaryFieldHandoffCount)
}

// SetUserMessageCount sets the UserMessageCount field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetUserMessageCount(userMessageCount int) {
	c.UserMessageCount = userMessageCount
	c.require(conversationSummaryFieldUserMessageCount)
}

// SetHandleTime sets the HandleTime field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetHandleTime(handleTime *int64) {
	c.HandleTime = handleTime
	c.require(conversationSummaryFieldHandleTime)
}

// SetHumanAgentResponseDelay sets the HumanAgentResponseDelay field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetHumanAgentResponseDelay(humanAgentResponseDelay *int64) {
	c.HumanAgentResponseDelay = humanAgentResponseDelay
	c.require(conversationSummaryFieldHumanAgentResponseDelay)
}

// SetHumanAgents sets the HumanAgents field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetHumanAgents(humanAgents []string) {
	c.HumanAgents = humanAgents
	c.require(conversationSummaryFieldHumanAgents)
}

// SetHumanAgentsWithInserts sets the HumanAgentsWithInserts field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetHumanAgentsWithInserts(humanAgentsWithInserts []string) {
	c.HumanAgentsWithInserts = humanAgentsWithInserts
	c.require(conversationSummaryFieldHumanAgentsWithInserts)
}

// SetUsers sets the Users field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetUsers(users []string) {
	c.Users = users
	c.require(conversationSummaryFieldUsers)
}

// SetUserIdentifiers sets the UserIdentifiers field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetUserIdentifiers(userIdentifiers []string) {
	c.UserIdentifiers = userIdentifiers
	c.require(conversationSummaryFieldUserIdentifiers)
}

// SetLastUserMessage sets the LastUserMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetLastUserMessage(lastUserMessage *string) {
	c.LastUserMessage = lastUserMessage
	c.require(conversationSummaryFieldLastUserMessage)
}

// SetLastBotMessage sets the LastBotMessage field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (c *ConversationSummary) SetLastBotMessage(lastBotMessage *string) {
	c.LastBotMessage = lastBotMessage
	c.require(conversationSummaryFieldLastBotMessage)
}

func (c *ConversationSummary) UnmarshalJSON(data []byte) error {
	type unmarshaler ConversationSummary
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConversationSummary(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *c)
	if err != nil {
		return err
	}
	c.extraProperties = extraProperties
	c.rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConversationSummary) MarshalJSON() ([]byte, error) {
	type embed ConversationSummary
	var marshaler = struct {
		embed
	}{
		embed: embed(*c),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, c.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (c *ConversationSummary) String() string {
	if len(c.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(c.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

var (
	deviceInfoFieldType    = big.NewInt(1 << 0)
	deviceInfoFieldName    = big.NewInt(1 << 1)
	deviceInfoFieldVersion = big.NewInt(1 << 2)
	deviceInfoFieldOsInfo  = big.NewInt(1 << 3)
)

type DeviceInfo struct {
	Type    DeviceType `json:"type" url:"type"`
	Name    *string    `json:"name,omitempty" url:"name,omitempty"`
	Version *string    `json:"version,omitempty" url:"version,omitempty"`
	OsInfo  *OsInfo    `json:"osInfo,omitempty" url:"osInfo,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DeviceInfo) GetType() DeviceType {
	if d == nil {
		return ""
	}
	return d.Type
}

func (d *DeviceInfo) GetName() *string {
	if d == nil {
		return nil
	}
	return d.Name
}

func (d *DeviceInfo) GetVersion() *string {
	if d == nil {
		return nil
	}
	return d.Version
}

func (d *DeviceInfo) GetOsInfo() *OsInfo {
	if d == nil {
		return nil
	}
	return d.OsInfo
}

func (d *DeviceInfo) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DeviceInfo) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceInfo) SetType(type_ DeviceType) {
	d.Type = type_
	d.require(deviceInfoFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceInfo) SetName(name *string) {
	d.Name = name
	d.require(deviceInfoFieldName)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceInfo) SetVersion(version *string) {
	d.Version = version
	d.require(deviceInfoFieldVersion)
}

// SetOsInfo sets the OsInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DeviceInfo) SetOsInfo(osInfo *OsInfo) {
	d.OsInfo = osInfo
	d.require(deviceInfoFieldOsInfo)
}

func (d *DeviceInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler DeviceInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DeviceInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DeviceInfo) MarshalJSON() ([]byte, error) {
	type embed DeviceInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DeviceInfo) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DeviceType string

const (
	DeviceTypeDesktop DeviceType = "DESKTOP"
	DeviceTypeMobile  DeviceType = "MOBILE"
	DeviceTypeTablet  DeviceType = "TABLET"
	DeviceTypeOther   DeviceType = "OTHER"
)

func NewDeviceTypeFromString(s string) (DeviceType, error) {
	switch s {
	case "DESKTOP":
		return DeviceTypeDesktop, nil
	case "MOBILE":
		return DeviceTypeMobile, nil
	case "TABLET":
		return DeviceTypeTablet, nil
	case "OTHER":
		return DeviceTypeOther, nil
	}
	var t DeviceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DeviceType) Ptr() *DeviceType {
	return &d
}

var (
	documentInformationFieldKnowledgeBaseId = big.NewInt(1 << 0)
	documentInformationFieldDocumentId      = big.NewInt(1 << 1)
	documentInformationFieldTitle           = big.NewInt(1 << 2)
	documentInformationFieldSnippet         = big.NewInt(1 << 3)
)

type DocumentInformation struct {
	// Unique identifier for the knowledge base.
	KnowledgeBaseId *EntityIdWithoutAgent `json:"knowledgeBaseId" url:"knowledgeBaseId"`
	// Unique identifier for the document.
	DocumentId *EntityIdWithoutAgent `json:"documentId" url:"documentId"`
	// Title of the document.
	Title *string `json:"title,omitempty" url:"title,omitempty"`
	// Snippet or summary of the document.
	Snippet *string `json:"snippet,omitempty" url:"snippet,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (d *DocumentInformation) GetKnowledgeBaseId() *EntityIdWithoutAgent {
	if d == nil {
		return nil
	}
	return d.KnowledgeBaseId
}

func (d *DocumentInformation) GetDocumentId() *EntityIdWithoutAgent {
	if d == nil {
		return nil
	}
	return d.DocumentId
}

func (d *DocumentInformation) GetTitle() *string {
	if d == nil {
		return nil
	}
	return d.Title
}

func (d *DocumentInformation) GetSnippet() *string {
	if d == nil {
		return nil
	}
	return d.Snippet
}

func (d *DocumentInformation) GetExtraProperties() map[string]interface{} {
	return d.extraProperties
}

func (d *DocumentInformation) require(field *big.Int) {
	if d.explicitFields == nil {
		d.explicitFields = big.NewInt(0)
	}
	d.explicitFields.Or(d.explicitFields, field)
}

// SetKnowledgeBaseId sets the KnowledgeBaseId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DocumentInformation) SetKnowledgeBaseId(knowledgeBaseId *EntityIdWithoutAgent) {
	d.KnowledgeBaseId = knowledgeBaseId
	d.require(documentInformationFieldKnowledgeBaseId)
}

// SetDocumentId sets the DocumentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DocumentInformation) SetDocumentId(documentId *EntityIdWithoutAgent) {
	d.DocumentId = documentId
	d.require(documentInformationFieldDocumentId)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DocumentInformation) SetTitle(title *string) {
	d.Title = title
	d.require(documentInformationFieldTitle)
}

// SetSnippet sets the Snippet field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (d *DocumentInformation) SetSnippet(snippet *string) {
	d.Snippet = snippet
	d.require(documentInformationFieldSnippet)
}

func (d *DocumentInformation) UnmarshalJSON(data []byte) error {
	type unmarshaler DocumentInformation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DocumentInformation(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *d)
	if err != nil {
		return err
	}
	d.extraProperties = extraProperties
	d.rawJSON = json.RawMessage(data)
	return nil
}

func (d *DocumentInformation) MarshalJSON() ([]byte, error) {
	type embed DocumentInformation
	var marshaler = struct {
		embed
	}{
		embed: embed(*d),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, d.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (d *DocumentInformation) String() string {
	if len(d.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(d.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// A fully specified object ID, unique across the entire system.
var (
	entityIdFieldReferenceId    = big.NewInt(1 << 0)
	entityIdFieldType           = big.NewInt(1 << 1)
	entityIdFieldAppId          = big.NewInt(1 << 2)
	entityIdFieldOrganizationId = big.NewInt(1 << 3)
	entityIdFieldAgentId        = big.NewInt(1 << 4)
)

type EntityId struct {
	// Externally supplied ID to uniquely identify this object. Is globally unique when combined with all other entityId fields (type, appId, organizationId, agentId)
	ReferenceId string `json:"referenceId" url:"referenceId"`
	// The object type
	Type EntityType `json:"type" url:"type"`
	// The ID of the application that created this object
	AppId string `json:"appId" url:"appId"`
	// The ID of the organization that this object belongs to
	OrganizationId string `json:"organizationId" url:"organizationId"`
	// The ID of the agent that this object belongs to
	AgentId string `json:"agentId" url:"agentId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityId) GetReferenceId() string {
	if e == nil {
		return ""
	}
	return e.ReferenceId
}

func (e *EntityId) GetType() EntityType {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EntityId) GetAppId() string {
	if e == nil {
		return ""
	}
	return e.AppId
}

func (e *EntityId) GetOrganizationId() string {
	if e == nil {
		return ""
	}
	return e.OrganizationId
}

func (e *EntityId) GetAgentId() string {
	if e == nil {
		return ""
	}
	return e.AgentId
}

func (e *EntityId) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityId) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetReferenceId sets the ReferenceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityId) SetReferenceId(referenceId string) {
	e.ReferenceId = referenceId
	e.require(entityIdFieldReferenceId)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityId) SetType(type_ EntityType) {
	e.Type = type_
	e.require(entityIdFieldType)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityId) SetAppId(appId string) {
	e.AppId = appId
	e.require(entityIdFieldAppId)
}

// SetOrganizationId sets the OrganizationId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityId) SetOrganizationId(organizationId string) {
	e.OrganizationId = organizationId
	e.require(entityIdFieldOrganizationId)
}

// SetAgentId sets the AgentId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityId) SetAgentId(agentId string) {
	e.AgentId = agentId
	e.require(entityIdFieldAgentId)
}

func (e *EntityId) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityId
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityId(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityId) MarshalJSON() ([]byte, error) {
	type embed EntityId
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityId) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// All other entityId fields are inferred from the API request.
var (
	entityIdBaseFieldReferenceId = big.NewInt(1 << 0)
)

type EntityIdBase struct {
	// Externally supplied ID to uniquely identify this object. Is globally unique when combined with all other entityId fields (type, appId, organizationId, agentId)
	ReferenceId string `json:"referenceId" url:"referenceId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityIdBase) GetReferenceId() string {
	if e == nil {
		return ""
	}
	return e.ReferenceId
}

func (e *EntityIdBase) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityIdBase) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetReferenceId sets the ReferenceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIdBase) SetReferenceId(referenceId string) {
	e.ReferenceId = referenceId
	e.require(entityIdBaseFieldReferenceId)
}

func (e *EntityIdBase) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityIdBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityIdBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityIdBase) MarshalJSON() ([]byte, error) {
	type embed EntityIdBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityIdBase) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	entityIdFilterFieldReferenceId = big.NewInt(1 << 0)
	entityIdFilterFieldAppId       = big.NewInt(1 << 1)
)

type EntityIdFilter struct {
	ReferenceId string `json:"referenceId" url:"referenceId"`
	AppId       string `json:"appId" url:"appId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityIdFilter) GetReferenceId() string {
	if e == nil {
		return ""
	}
	return e.ReferenceId
}

func (e *EntityIdFilter) GetAppId() string {
	if e == nil {
		return ""
	}
	return e.AppId
}

func (e *EntityIdFilter) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityIdFilter) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetReferenceId sets the ReferenceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIdFilter) SetReferenceId(referenceId string) {
	e.ReferenceId = referenceId
	e.require(entityIdFilterFieldReferenceId)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIdFilter) SetAppId(appId string) {
	e.AppId = appId
	e.require(entityIdFilterFieldAppId)
}

func (e *EntityIdFilter) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityIdFilter
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityIdFilter(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityIdFilter) MarshalJSON() ([]byte, error) {
	type embed EntityIdFilter
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityIdFilter) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The organizationId and agentId are inferred from the context.
var (
	entityIdWithoutAgentFieldReferenceId = big.NewInt(1 << 0)
	entityIdWithoutAgentFieldType        = big.NewInt(1 << 1)
	entityIdWithoutAgentFieldAppId       = big.NewInt(1 << 2)
)

type EntityIdWithoutAgent struct {
	// Externally supplied ID to uniquely identify this object. Is globally unique when combined with all other entityId fields (type, appId, organizationId, agentId)
	ReferenceId string `json:"referenceId" url:"referenceId"`
	// The object type
	Type EntityType `json:"type" url:"type"`
	// The ID of the application that created this object
	AppId string `json:"appId" url:"appId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityIdWithoutAgent) GetReferenceId() string {
	if e == nil {
		return ""
	}
	return e.ReferenceId
}

func (e *EntityIdWithoutAgent) GetType() EntityType {
	if e == nil {
		return ""
	}
	return e.Type
}

func (e *EntityIdWithoutAgent) GetAppId() string {
	if e == nil {
		return ""
	}
	return e.AppId
}

func (e *EntityIdWithoutAgent) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityIdWithoutAgent) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetReferenceId sets the ReferenceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIdWithoutAgent) SetReferenceId(referenceId string) {
	e.ReferenceId = referenceId
	e.require(entityIdWithoutAgentFieldReferenceId)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIdWithoutAgent) SetType(type_ EntityType) {
	e.Type = type_
	e.require(entityIdWithoutAgentFieldType)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityIdWithoutAgent) SetAppId(appId string) {
	e.AppId = appId
	e.require(entityIdWithoutAgentFieldAppId)
}

func (e *EntityIdWithoutAgent) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityIdWithoutAgent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityIdWithoutAgent(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityIdWithoutAgent) MarshalJSON() ([]byte, error) {
	type embed EntityIdWithoutAgent
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityIdWithoutAgent) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	entityResultFieldReferenceId = big.NewInt(1 << 0)
	entityResultFieldAppId       = big.NewInt(1 << 1)
	entityResultFieldName        = big.NewInt(1 << 2)
)

type EntityResult struct {
	ReferenceId string `json:"referenceId" url:"referenceId"`
	AppId       string `json:"appId" url:"appId"`
	// Human-readable name for the referenced entity (e.g., action name or document title).
	Name *string `json:"name,omitempty" url:"name,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EntityResult) GetReferenceId() string {
	if e == nil {
		return ""
	}
	return e.ReferenceId
}

func (e *EntityResult) GetAppId() string {
	if e == nil {
		return ""
	}
	return e.AppId
}

func (e *EntityResult) GetName() *string {
	if e == nil {
		return nil
	}
	return e.Name
}

func (e *EntityResult) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EntityResult) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetReferenceId sets the ReferenceId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityResult) SetReferenceId(referenceId string) {
	e.ReferenceId = referenceId
	e.require(entityResultFieldReferenceId)
}

// SetAppId sets the AppId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityResult) SetAppId(appId string) {
	e.AppId = appId
	e.require(entityResultFieldAppId)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EntityResult) SetName(name *string) {
	e.Name = name
	e.require(entityResultFieldName)
}

func (e *EntityResult) UnmarshalJSON(data []byte) error {
	type unmarshaler EntityResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EntityResult(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EntityResult) MarshalJSON() ([]byte, error) {
	type embed EntityResult
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EntityResult) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EntityType string

const (
	EntityTypeAgent                EntityType = "AGENT"
	EntityTypeConversation         EntityType = "CONVERSATION"
	EntityTypeConversationMessage  EntityType = "CONVERSATION_MESSAGE"
	EntityTypeKnowledgeBase        EntityType = "KNOWLEDGE_BASE"
	EntityTypeKnowledgeBaseVersion EntityType = "KNOWLEDGE_BASE_VERSION"
	EntityTypeKnowledgeDocument    EntityType = "KNOWLEDGE_DOCUMENT"
	EntityTypeAction               EntityType = "ACTION"
	EntityTypeUser                 EntityType = "USER"
	EntityTypeEvent                EntityType = "EVENT"
	EntityTypeEventTrigger         EntityType = "EVENT_TRIGGER"
	EntityTypeUserProfile          EntityType = "USER_PROFILE"
	EntityTypeFeedback             EntityType = "FEEDBACK"
	EntityTypeInboxItem            EntityType = "INBOX_ITEM"
	EntityTypeInboxItemFix         EntityType = "INBOX_ITEM_FIX"
	EntityTypeSegment              EntityType = "SEGMENT"
	EntityTypeCustomer             EntityType = "CUSTOMER"
)

func NewEntityTypeFromString(s string) (EntityType, error) {
	switch s {
	case "AGENT":
		return EntityTypeAgent, nil
	case "CONVERSATION":
		return EntityTypeConversation, nil
	case "CONVERSATION_MESSAGE":
		return EntityTypeConversationMessage, nil
	case "KNOWLEDGE_BASE":
		return EntityTypeKnowledgeBase, nil
	case "KNOWLEDGE_BASE_VERSION":
		return EntityTypeKnowledgeBaseVersion, nil
	case "KNOWLEDGE_DOCUMENT":
		return EntityTypeKnowledgeDocument, nil
	case "ACTION":
		return EntityTypeAction, nil
	case "USER":
		return EntityTypeUser, nil
	case "EVENT":
		return EntityTypeEvent, nil
	case "EVENT_TRIGGER":
		return EntityTypeEventTrigger, nil
	case "USER_PROFILE":
		return EntityTypeUserProfile, nil
	case "FEEDBACK":
		return EntityTypeFeedback, nil
	case "INBOX_ITEM":
		return EntityTypeInboxItem, nil
	case "INBOX_ITEM_FIX":
		return EntityTypeInboxItemFix, nil
	case "SEGMENT":
		return EntityTypeSegment, nil
	case "CUSTOMER":
		return EntityTypeCustomer, nil
	}
	var t EntityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EntityType) Ptr() *EntityType {
	return &e
}

var (
	errorMessageFieldMessage = big.NewInt(1 << 0)
)

type ErrorMessage struct {
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *ErrorMessage) GetMessage() *string {
	if e == nil {
		return nil
	}
	return e.Message
}

func (e *ErrorMessage) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorMessage) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetMessage sets the Message field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *ErrorMessage) SetMessage(message *string) {
	e.Message = message
	e.require(errorMessageFieldMessage)
}

func (e *ErrorMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorMessage(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorMessage) MarshalJSON() ([]byte, error) {
	type embed ErrorMessage
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *ErrorMessage) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventBaseNoIdFieldTimestamp   = big.NewInt(1 << 0)
	eventBaseNoIdFieldReferences  = big.NewInt(1 << 1)
	eventBaseNoIdFieldSourceInfo  = big.NewInt(1 << 2)
	eventBaseNoIdFieldSessionInfo = big.NewInt(1 << 3)
	eventBaseNoIdFieldContextInfo = big.NewInt(1 << 4)
)

type EventBaseNoId struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventBaseNoId) GetTimestamp() *time.Time {
	if e == nil {
		return nil
	}
	return e.Timestamp
}

func (e *EventBaseNoId) GetReferences() []*ScopedEntity {
	if e == nil {
		return nil
	}
	return e.References
}

func (e *EventBaseNoId) GetSourceInfo() *SourceInfo {
	if e == nil {
		return nil
	}
	return e.SourceInfo
}

func (e *EventBaseNoId) GetSessionInfo() *SessionInfo {
	if e == nil {
		return nil
	}
	return e.SessionInfo
}

func (e *EventBaseNoId) GetContextInfo() *ContextInfo {
	if e == nil {
		return nil
	}
	return e.ContextInfo
}

func (e *EventBaseNoId) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventBaseNoId) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBaseNoId) SetTimestamp(timestamp *time.Time) {
	e.Timestamp = timestamp
	e.require(eventBaseNoIdFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBaseNoId) SetReferences(references []*ScopedEntity) {
	e.References = references
	e.require(eventBaseNoIdFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBaseNoId) SetSourceInfo(sourceInfo *SourceInfo) {
	e.SourceInfo = sourceInfo
	e.require(eventBaseNoIdFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBaseNoId) SetSessionInfo(sessionInfo *SessionInfo) {
	e.SessionInfo = sessionInfo
	e.require(eventBaseNoIdFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventBaseNoId) SetContextInfo(contextInfo *ContextInfo) {
	e.ContextInfo = contextInfo
	e.require(eventBaseNoIdFieldContextInfo)
}

func (e *EventBaseNoId) UnmarshalJSON(data []byte) error {
	type embed EventBaseNoId
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EventBaseNoId(unmarshaler.embed)
	e.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventBaseNoId) MarshalJSON() ([]byte, error) {
	type embed EventBaseNoId
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*e),
		Timestamp: internal.NewOptionalDateTime(e.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventBaseNoId) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventField string

const (
	EventFieldCreatedAt EventField = "CREATED_AT"
)

func NewEventFieldFromString(s string) (EventField, error) {
	switch s {
	case "CREATED_AT":
		return EventFieldCreatedAt, nil
	}
	var t EventField
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventField) Ptr() *EventField {
	return &e
}

var (
	eventFilterFieldSearch              = big.NewInt(1 << 0)
	eventFilterFieldCreatedAfter        = big.NewInt(1 << 1)
	eventFilterFieldCreatedBefore       = big.NewInt(1 << 2)
	eventFilterFieldReferences          = big.NewInt(1 << 3)
	eventFilterFieldEventTypes          = big.NewInt(1 << 4)
	eventFilterFieldUserEventNames      = big.NewInt(1 << 5)
	eventFilterFieldSystemEventNames    = big.NewInt(1 << 6)
	eventFilterFieldAgentUserIds        = big.NewInt(1 << 7)
	eventFilterFieldLegacyFeedbackTypes = big.NewInt(1 << 8)
	eventFilterFieldHasEventText        = big.NewInt(1 << 9)
)

type EventFilter struct {
	Search              *string           `json:"search,omitempty" url:"search,omitempty"`
	CreatedAfter        *time.Time        `json:"createdAfter,omitempty" url:"createdAfter,omitempty"`
	CreatedBefore       *time.Time        `json:"createdBefore,omitempty" url:"createdBefore,omitempty"`
	References          []*ScopedEntity   `json:"references,omitempty" url:"references,omitempty"`
	EventTypes          []EventType       `json:"eventTypes,omitempty" url:"eventTypes,omitempty"`
	UserEventNames      []UserEventName   `json:"userEventNames,omitempty" url:"userEventNames,omitempty"`
	SystemEventNames    []SystemEventName `json:"systemEventNames,omitempty" url:"systemEventNames,omitempty"`
	AgentUserIds        []string          `json:"agentUserIds,omitempty" url:"agentUserIds,omitempty"`
	LegacyFeedbackTypes []FeedbackType    `json:"legacyFeedbackTypes,omitempty" url:"legacyFeedbackTypes,omitempty"`
	HasEventText        *bool             `json:"hasEventText,omitempty" url:"hasEventText,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventFilter) GetSearch() *string {
	if e == nil {
		return nil
	}
	return e.Search
}

func (e *EventFilter) GetCreatedAfter() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedAfter
}

func (e *EventFilter) GetCreatedBefore() *time.Time {
	if e == nil {
		return nil
	}
	return e.CreatedBefore
}

func (e *EventFilter) GetReferences() []*ScopedEntity {
	if e == nil {
		return nil
	}
	return e.References
}

func (e *EventFilter) GetEventTypes() []EventType {
	if e == nil {
		return nil
	}
	return e.EventTypes
}

func (e *EventFilter) GetUserEventNames() []UserEventName {
	if e == nil {
		return nil
	}
	return e.UserEventNames
}

func (e *EventFilter) GetSystemEventNames() []SystemEventName {
	if e == nil {
		return nil
	}
	return e.SystemEventNames
}

func (e *EventFilter) GetAgentUserIds() []string {
	if e == nil {
		return nil
	}
	return e.AgentUserIds
}

func (e *EventFilter) GetLegacyFeedbackTypes() []FeedbackType {
	if e == nil {
		return nil
	}
	return e.LegacyFeedbackTypes
}

func (e *EventFilter) GetHasEventText() *bool {
	if e == nil {
		return nil
	}
	return e.HasEventText
}

func (e *EventFilter) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventFilter) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetSearch sets the Search field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetSearch(search *string) {
	e.Search = search
	e.require(eventFilterFieldSearch)
}

// SetCreatedAfter sets the CreatedAfter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetCreatedAfter(createdAfter *time.Time) {
	e.CreatedAfter = createdAfter
	e.require(eventFilterFieldCreatedAfter)
}

// SetCreatedBefore sets the CreatedBefore field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetCreatedBefore(createdBefore *time.Time) {
	e.CreatedBefore = createdBefore
	e.require(eventFilterFieldCreatedBefore)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetReferences(references []*ScopedEntity) {
	e.References = references
	e.require(eventFilterFieldReferences)
}

// SetEventTypes sets the EventTypes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetEventTypes(eventTypes []EventType) {
	e.EventTypes = eventTypes
	e.require(eventFilterFieldEventTypes)
}

// SetUserEventNames sets the UserEventNames field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetUserEventNames(userEventNames []UserEventName) {
	e.UserEventNames = userEventNames
	e.require(eventFilterFieldUserEventNames)
}

// SetSystemEventNames sets the SystemEventNames field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetSystemEventNames(systemEventNames []SystemEventName) {
	e.SystemEventNames = systemEventNames
	e.require(eventFilterFieldSystemEventNames)
}

// SetAgentUserIds sets the AgentUserIds field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetAgentUserIds(agentUserIds []string) {
	e.AgentUserIds = agentUserIds
	e.require(eventFilterFieldAgentUserIds)
}

// SetLegacyFeedbackTypes sets the LegacyFeedbackTypes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetLegacyFeedbackTypes(legacyFeedbackTypes []FeedbackType) {
	e.LegacyFeedbackTypes = legacyFeedbackTypes
	e.require(eventFilterFieldLegacyFeedbackTypes)
}

// SetHasEventText sets the HasEventText field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventFilter) SetHasEventText(hasEventText *bool) {
	e.HasEventText = hasEventText
	e.require(eventFilterFieldHasEventText)
}

func (e *EventFilter) UnmarshalJSON(data []byte) error {
	type embed EventFilter
	var unmarshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EventFilter(unmarshaler.embed)
	e.CreatedAfter = unmarshaler.CreatedAfter.TimePtr()
	e.CreatedBefore = unmarshaler.CreatedBefore.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventFilter) MarshalJSON() ([]byte, error) {
	type embed EventFilter
	var marshaler = struct {
		embed
		CreatedAfter  *internal.DateTime `json:"createdAfter,omitempty"`
		CreatedBefore *internal.DateTime `json:"createdBefore,omitempty"`
	}{
		embed:         embed(*e),
		CreatedAfter:  internal.NewOptionalDateTime(e.CreatedAfter),
		CreatedBefore: internal.NewOptionalDateTime(e.CreatedBefore),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventFilter) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EventRequest struct {
	EventType   string
	UserEvent   *NovelUserEvent
	SystemEvent *NovelSystemEvent
}

func (e *EventRequest) GetEventType() string {
	if e == nil {
		return ""
	}
	return e.EventType
}

func (e *EventRequest) GetUserEvent() *NovelUserEvent {
	if e == nil {
		return nil
	}
	return e.UserEvent
}

func (e *EventRequest) GetSystemEvent() *NovelSystemEvent {
	if e == nil {
		return nil
	}
	return e.SystemEvent
}

func (e *EventRequest) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"eventType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.EventType = unmarshaler.EventType
	if unmarshaler.EventType == "" {
		return fmt.Errorf("%T did not include discriminant eventType", e)
	}
	switch unmarshaler.EventType {
	case "userEvent":
		value := new(NovelUserEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.UserEvent = value
	case "systemEvent":
		value := new(NovelSystemEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SystemEvent = value
	}
	return nil
}

func (e EventRequest) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.UserEvent != nil {
		return internal.MarshalJSONWithExtraProperty(e.UserEvent, "eventType", "userEvent")
	}
	if e.SystemEvent != nil {
		return internal.MarshalJSONWithExtraProperty(e.SystemEvent, "eventType", "systemEvent")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EventRequestVisitor interface {
	VisitUserEvent(*NovelUserEvent) error
	VisitSystemEvent(*NovelSystemEvent) error
}

func (e *EventRequest) Accept(visitor EventRequestVisitor) error {
	if e.UserEvent != nil {
		return visitor.VisitUserEvent(e.UserEvent)
	}
	if e.SystemEvent != nil {
		return visitor.VisitSystemEvent(e.SystemEvent)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *EventRequest) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.UserEvent != nil {
		fields = append(fields, "userEvent")
	}
	if e.SystemEvent != nil {
		fields = append(fields, "systemEvent")
	}
	if len(fields) == 0 {
		if e.EventType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.EventType)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.EventType != "" {
		field := fields[0]
		if e.EventType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.EventType,
				e,
			)
		}
	}
	return nil
}

type EventResponse struct {
	EventType   string
	UserEvent   *UserEvent
	SystemEvent *SystemEvent
}

func (e *EventResponse) GetEventType() string {
	if e == nil {
		return ""
	}
	return e.EventType
}

func (e *EventResponse) GetUserEvent() *UserEvent {
	if e == nil {
		return nil
	}
	return e.UserEvent
}

func (e *EventResponse) GetSystemEvent() *SystemEvent {
	if e == nil {
		return nil
	}
	return e.SystemEvent
}

func (e *EventResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"eventType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.EventType = unmarshaler.EventType
	if unmarshaler.EventType == "" {
		return fmt.Errorf("%T did not include discriminant eventType", e)
	}
	switch unmarshaler.EventType {
	case "userEvent":
		value := new(UserEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.UserEvent = value
	case "systemEvent":
		value := new(SystemEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.SystemEvent = value
	}
	return nil
}

func (e EventResponse) MarshalJSON() ([]byte, error) {
	if err := e.validate(); err != nil {
		return nil, err
	}
	if e.UserEvent != nil {
		return internal.MarshalJSONWithExtraProperty(e.UserEvent, "eventType", "userEvent")
	}
	if e.SystemEvent != nil {
		return internal.MarshalJSONWithExtraProperty(e.SystemEvent, "eventType", "systemEvent")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EventResponseVisitor interface {
	VisitUserEvent(*UserEvent) error
	VisitSystemEvent(*SystemEvent) error
}

func (e *EventResponse) Accept(visitor EventResponseVisitor) error {
	if e.UserEvent != nil {
		return visitor.VisitUserEvent(e.UserEvent)
	}
	if e.SystemEvent != nil {
		return visitor.VisitSystemEvent(e.SystemEvent)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

func (e *EventResponse) validate() error {
	if e == nil {
		return fmt.Errorf("type %T is nil", e)
	}
	var fields []string
	if e.UserEvent != nil {
		fields = append(fields, "userEvent")
	}
	if e.SystemEvent != nil {
		fields = append(fields, "systemEvent")
	}
	if len(fields) == 0 {
		if e.EventType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", e, e.EventType)
		}
		return fmt.Errorf("type %T is empty", e)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", e, fields)
	}
	if e.EventType != "" {
		field := fields[0]
		if e.EventType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				e,
				e.EventType,
				e,
			)
		}
	}
	return nil
}

type EventType string

const (
	EventTypeUser   EventType = "USER"
	EventTypeSystem EventType = "SYSTEM"
)

func NewEventTypeFromString(s string) (EventType, error) {
	switch s {
	case "USER":
		return EventTypeUser, nil
	case "SYSTEM":
		return EventTypeSystem, nil
	}
	var t EventType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventType) Ptr() *EventType {
	return &e
}

var (
	eventUserInfoFieldId              = big.NewInt(1 << 0)
	eventUserInfoFieldUserDisplayName = big.NewInt(1 << 1)
)

type EventUserInfo struct {
	Id              *EntityId `json:"id,omitempty" url:"id,omitempty"`
	UserDisplayName *string   `json:"userDisplayName,omitempty" url:"userDisplayName,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventUserInfo) GetId() *EntityId {
	if e == nil {
		return nil
	}
	return e.Id
}

func (e *EventUserInfo) GetUserDisplayName() *string {
	if e == nil {
		return nil
	}
	return e.UserDisplayName
}

func (e *EventUserInfo) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventUserInfo) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventUserInfo) SetId(id *EntityId) {
	e.Id = id
	e.require(eventUserInfoFieldId)
}

// SetUserDisplayName sets the UserDisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventUserInfo) SetUserDisplayName(userDisplayName *string) {
	e.UserDisplayName = userDisplayName
	e.require(eventUserInfoFieldUserDisplayName)
}

func (e *EventUserInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler EventUserInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventUserInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventUserInfo) MarshalJSON() ([]byte, error) {
	type embed EventUserInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventUserInfo) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventUserInfoBaseFieldId = big.NewInt(1 << 0)
)

type EventUserInfoBase struct {
	Id *EntityIdBase `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventUserInfoBase) GetId() *EntityIdBase {
	if e == nil {
		return nil
	}
	return e.Id
}

func (e *EventUserInfoBase) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventUserInfoBase) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventUserInfoBase) SetId(id *EntityIdBase) {
	e.Id = id
	e.require(eventUserInfoBaseFieldId)
}

func (e *EventUserInfoBase) UnmarshalJSON(data []byte) error {
	type unmarshaler EventUserInfoBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventUserInfoBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventUserInfoBase) MarshalJSON() ([]byte, error) {
	type embed EventUserInfoBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventUserInfoBase) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventsSearchRequestFieldPage     = big.NewInt(1 << 0)
	eventsSearchRequestFieldSize     = big.NewInt(1 << 1)
	eventsSearchRequestFieldSortDesc = big.NewInt(1 << 2)
	eventsSearchRequestFieldSort     = big.NewInt(1 << 3)
	eventsSearchRequestFieldFilter   = big.NewInt(1 << 4)
)

type EventsSearchRequest struct {
	// Page number to return, defaults to 0
	Page *int `json:"page,omitempty" url:"page,omitempty"`
	// The size of the page to return, defaults to 20
	Size *int `json:"size,omitempty" url:"size,omitempty"`
	// Whether to sort descending, defaults to true
	SortDesc *bool        `json:"sortDesc,omitempty" url:"sortDesc,omitempty"`
	Sort     *EventField  `json:"sort,omitempty" url:"sort,omitempty"`
	Filter   *EventFilter `json:"filter,omitempty" url:"filter,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventsSearchRequest) GetPage() *int {
	if e == nil {
		return nil
	}
	return e.Page
}

func (e *EventsSearchRequest) GetSize() *int {
	if e == nil {
		return nil
	}
	return e.Size
}

func (e *EventsSearchRequest) GetSortDesc() *bool {
	if e == nil {
		return nil
	}
	return e.SortDesc
}

func (e *EventsSearchRequest) GetSort() *EventField {
	if e == nil {
		return nil
	}
	return e.Sort
}

func (e *EventsSearchRequest) GetFilter() *EventFilter {
	if e == nil {
		return nil
	}
	return e.Filter
}

func (e *EventsSearchRequest) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventsSearchRequest) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetPage sets the Page field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchRequest) SetPage(page *int) {
	e.Page = page
	e.require(eventsSearchRequestFieldPage)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchRequest) SetSize(size *int) {
	e.Size = size
	e.require(eventsSearchRequestFieldSize)
}

// SetSortDesc sets the SortDesc field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchRequest) SetSortDesc(sortDesc *bool) {
	e.SortDesc = sortDesc
	e.require(eventsSearchRequestFieldSortDesc)
}

// SetSort sets the Sort field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchRequest) SetSort(sort *EventField) {
	e.Sort = sort
	e.require(eventsSearchRequestFieldSort)
}

// SetFilter sets the Filter field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchRequest) SetFilter(filter *EventFilter) {
	e.Filter = filter
	e.require(eventsSearchRequestFieldFilter)
}

func (e *EventsSearchRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler EventsSearchRequest
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventsSearchRequest(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventsSearchRequest) MarshalJSON() ([]byte, error) {
	type embed EventsSearchRequest
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventsSearchRequest) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	eventsSearchResponseFieldNumber        = big.NewInt(1 << 0)
	eventsSearchResponseFieldSize          = big.NewInt(1 << 1)
	eventsSearchResponseFieldTotalElements = big.NewInt(1 << 2)
	eventsSearchResponseFieldTotalPages    = big.NewInt(1 << 3)
	eventsSearchResponseFieldEvents        = big.NewInt(1 << 4)
)

type EventsSearchResponse struct {
	// The page being returned, starts at 0
	Number int `json:"number" url:"number"`
	// The number of elements in this page
	Size int `json:"size" url:"size"`
	// The total number of elements in the collection
	TotalElements int64 `json:"totalElements" url:"totalElements"`
	// The total number of pages in the collection
	TotalPages int `json:"totalPages" url:"totalPages"`
	// The list of events
	Events []*EventResponse `json:"events" url:"events"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (e *EventsSearchResponse) GetNumber() int {
	if e == nil {
		return 0
	}
	return e.Number
}

func (e *EventsSearchResponse) GetSize() int {
	if e == nil {
		return 0
	}
	return e.Size
}

func (e *EventsSearchResponse) GetTotalElements() int64 {
	if e == nil {
		return 0
	}
	return e.TotalElements
}

func (e *EventsSearchResponse) GetTotalPages() int {
	if e == nil {
		return 0
	}
	return e.TotalPages
}

func (e *EventsSearchResponse) GetEvents() []*EventResponse {
	if e == nil {
		return nil
	}
	return e.Events
}

func (e *EventsSearchResponse) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *EventsSearchResponse) require(field *big.Int) {
	if e.explicitFields == nil {
		e.explicitFields = big.NewInt(0)
	}
	e.explicitFields.Or(e.explicitFields, field)
}

// SetNumber sets the Number field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchResponse) SetNumber(number int) {
	e.Number = number
	e.require(eventsSearchResponseFieldNumber)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchResponse) SetSize(size int) {
	e.Size = size
	e.require(eventsSearchResponseFieldSize)
}

// SetTotalElements sets the TotalElements field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchResponse) SetTotalElements(totalElements int64) {
	e.TotalElements = totalElements
	e.require(eventsSearchResponseFieldTotalElements)
}

// SetTotalPages sets the TotalPages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchResponse) SetTotalPages(totalPages int) {
	e.TotalPages = totalPages
	e.require(eventsSearchResponseFieldTotalPages)
}

// SetEvents sets the Events field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (e *EventsSearchResponse) SetEvents(events []*EventResponse) {
	e.Events = events
	e.require(eventsSearchResponseFieldEvents)
}

func (e *EventsSearchResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EventsSearchResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventsSearchResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties
	e.rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventsSearchResponse) MarshalJSON() ([]byte, error) {
	type embed EventsSearchResponse
	var marshaler = struct {
		embed
	}{
		embed: embed(*e),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, e.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (e *EventsSearchResponse) String() string {
	if len(e.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(e.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

var (
	feedbackFieldType                  = big.NewInt(1 << 0)
	feedbackFieldText                  = big.NewInt(1 << 1)
	feedbackFieldFeedbackId            = big.NewInt(1 << 2)
	feedbackFieldConversationId        = big.NewInt(1 << 3)
	feedbackFieldConversationMessageId = big.NewInt(1 << 4)
	feedbackFieldUserId                = big.NewInt(1 << 5)
	feedbackFieldCreatedAt             = big.NewInt(1 << 6)
)

type Feedback struct {
	// The type of feedback
	Type FeedbackType `json:"type" url:"type"`
	// The feedback text
	Text *string `json:"text,omitempty" url:"text,omitempty"`
	// The ID of the piece of feedback
	FeedbackId *EntityId `json:"feedbackId" url:"feedbackId"`
	// The ID of the conversation the feedback is about
	ConversationId *EntityId `json:"conversationId" url:"conversationId"`
	// The ID of the conversation message the feedback is about
	ConversationMessageId *EntityId `json:"conversationMessageId" url:"conversationMessageId"`
	// The ID of the user who created the feedback
	UserId *EntityId `json:"userId,omitempty" url:"userId,omitempty"`
	// The date and time the feedback was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *Feedback) GetType() FeedbackType {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *Feedback) GetText() *string {
	if f == nil {
		return nil
	}
	return f.Text
}

func (f *Feedback) GetFeedbackId() *EntityId {
	if f == nil {
		return nil
	}
	return f.FeedbackId
}

func (f *Feedback) GetConversationId() *EntityId {
	if f == nil {
		return nil
	}
	return f.ConversationId
}

func (f *Feedback) GetConversationMessageId() *EntityId {
	if f == nil {
		return nil
	}
	return f.ConversationMessageId
}

func (f *Feedback) GetUserId() *EntityId {
	if f == nil {
		return nil
	}
	return f.UserId
}

func (f *Feedback) GetCreatedAt() *time.Time {
	if f == nil {
		return nil
	}
	return f.CreatedAt
}

func (f *Feedback) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *Feedback) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetType(type_ FeedbackType) {
	f.Type = type_
	f.require(feedbackFieldType)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetText(text *string) {
	f.Text = text
	f.require(feedbackFieldText)
}

// SetFeedbackId sets the FeedbackId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetFeedbackId(feedbackId *EntityId) {
	f.FeedbackId = feedbackId
	f.require(feedbackFieldFeedbackId)
}

// SetConversationId sets the ConversationId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetConversationId(conversationId *EntityId) {
	f.ConversationId = conversationId
	f.require(feedbackFieldConversationId)
}

// SetConversationMessageId sets the ConversationMessageId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetConversationMessageId(conversationMessageId *EntityId) {
	f.ConversationMessageId = conversationMessageId
	f.require(feedbackFieldConversationMessageId)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetUserId(userId *EntityId) {
	f.UserId = userId
	f.require(feedbackFieldUserId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *Feedback) SetCreatedAt(createdAt *time.Time) {
	f.CreatedAt = createdAt
	f.require(feedbackFieldCreatedAt)
}

func (f *Feedback) UnmarshalJSON(data []byte) error {
	type embed Feedback
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = Feedback(unmarshaler.embed)
	f.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *Feedback) MarshalJSON() ([]byte, error) {
	type embed Feedback
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
	}{
		embed:     embed(*f),
		CreatedAt: internal.NewOptionalDateTime(f.CreatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *Feedback) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	feedbackBaseFieldType = big.NewInt(1 << 0)
	feedbackBaseFieldText = big.NewInt(1 << 1)
)

type FeedbackBase struct {
	// The type of feedback
	Type FeedbackType `json:"type" url:"type"`
	// The feedback text
	Text *string `json:"text,omitempty" url:"text,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackBase) GetType() FeedbackType {
	if f == nil {
		return ""
	}
	return f.Type
}

func (f *FeedbackBase) GetText() *string {
	if f == nil {
		return nil
	}
	return f.Text
}

func (f *FeedbackBase) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackBase) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackBase) SetType(type_ FeedbackType) {
	f.Type = type_
	f.require(feedbackBaseFieldType)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackBase) SetText(text *string) {
	f.Text = text
	f.require(feedbackBaseFieldText)
}

func (f *FeedbackBase) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackBase) MarshalJSON() ([]byte, error) {
	type embed FeedbackBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackBase) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

var (
	feedbackInfoFieldRating  = big.NewInt(1 << 0)
	feedbackInfoFieldThumbUp = big.NewInt(1 << 1)
	feedbackInfoFieldSurvey  = big.NewInt(1 << 2)
)

type FeedbackInfo struct {
	// The rating of the feedback as a ratio [0.0, 1.0]
	Rating *float64 `json:"rating,omitempty" url:"rating,omitempty"`
	// Whether the feedback was marked as a thumbs up
	ThumbUp *bool `json:"thumbUp,omitempty" url:"thumbUp,omitempty"`
	// A question and answer associated with the feedback
	Survey *SurveyInfo `json:"survey,omitempty" url:"survey,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (f *FeedbackInfo) GetRating() *float64 {
	if f == nil {
		return nil
	}
	return f.Rating
}

func (f *FeedbackInfo) GetThumbUp() *bool {
	if f == nil {
		return nil
	}
	return f.ThumbUp
}

func (f *FeedbackInfo) GetSurvey() *SurveyInfo {
	if f == nil {
		return nil
	}
	return f.Survey
}

func (f *FeedbackInfo) GetExtraProperties() map[string]interface{} {
	return f.extraProperties
}

func (f *FeedbackInfo) require(field *big.Int) {
	if f.explicitFields == nil {
		f.explicitFields = big.NewInt(0)
	}
	f.explicitFields.Or(f.explicitFields, field)
}

// SetRating sets the Rating field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackInfo) SetRating(rating *float64) {
	f.Rating = rating
	f.require(feedbackInfoFieldRating)
}

// SetThumbUp sets the ThumbUp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackInfo) SetThumbUp(thumbUp *bool) {
	f.ThumbUp = thumbUp
	f.require(feedbackInfoFieldThumbUp)
}

// SetSurvey sets the Survey field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (f *FeedbackInfo) SetSurvey(survey *SurveyInfo) {
	f.Survey = survey
	f.require(feedbackInfoFieldSurvey)
}

func (f *FeedbackInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler FeedbackInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FeedbackInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *f)
	if err != nil {
		return err
	}
	f.extraProperties = extraProperties
	f.rawJSON = json.RawMessage(data)
	return nil
}

func (f *FeedbackInfo) MarshalJSON() ([]byte, error) {
	type embed FeedbackInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, f.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (f *FeedbackInfo) String() string {
	if len(f.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(f.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

// The type of feedback
type FeedbackType string

const (
	FeedbackTypeThumbsUp   FeedbackType = "THUMBS_UP"
	FeedbackTypeThumbsDown FeedbackType = "THUMBS_DOWN"
	FeedbackTypeInsert     FeedbackType = "INSERT"
	FeedbackTypeHandoff    FeedbackType = "HANDOFF"
)

func NewFeedbackTypeFromString(s string) (FeedbackType, error) {
	switch s {
	case "THUMBS_UP":
		return FeedbackTypeThumbsUp, nil
	case "THUMBS_DOWN":
		return FeedbackTypeThumbsDown, nil
	case "INSERT":
		return FeedbackTypeInsert, nil
	case "HANDOFF":
		return FeedbackTypeHandoff, nil
	}
	var t FeedbackType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FeedbackType) Ptr() *FeedbackType {
	return &f
}

var (
	geoInfoFieldCity      = big.NewInt(1 << 0)
	geoInfoFieldState     = big.NewInt(1 << 1)
	geoInfoFieldCountry   = big.NewInt(1 << 2)
	geoInfoFieldRegion    = big.NewInt(1 << 3)
	geoInfoFieldLatitude  = big.NewInt(1 << 4)
	geoInfoFieldLongitude = big.NewInt(1 << 5)
)

type GeoInfo struct {
	City      *string  `json:"city,omitempty" url:"city,omitempty"`
	State     *string  `json:"state,omitempty" url:"state,omitempty"`
	Country   *string  `json:"country,omitempty" url:"country,omitempty"`
	Region    *string  `json:"region,omitempty" url:"region,omitempty"`
	Latitude  *float64 `json:"latitude,omitempty" url:"latitude,omitempty"`
	Longitude *float64 `json:"longitude,omitempty" url:"longitude,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GeoInfo) GetCity() *string {
	if g == nil {
		return nil
	}
	return g.City
}

func (g *GeoInfo) GetState() *string {
	if g == nil {
		return nil
	}
	return g.State
}

func (g *GeoInfo) GetCountry() *string {
	if g == nil {
		return nil
	}
	return g.Country
}

func (g *GeoInfo) GetRegion() *string {
	if g == nil {
		return nil
	}
	return g.Region
}

func (g *GeoInfo) GetLatitude() *float64 {
	if g == nil {
		return nil
	}
	return g.Latitude
}

func (g *GeoInfo) GetLongitude() *float64 {
	if g == nil {
		return nil
	}
	return g.Longitude
}

func (g *GeoInfo) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GeoInfo) require(field *big.Int) {
	if g.explicitFields == nil {
		g.explicitFields = big.NewInt(0)
	}
	g.explicitFields.Or(g.explicitFields, field)
}

// SetCity sets the City field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetCity(city *string) {
	g.City = city
	g.require(geoInfoFieldCity)
}

// SetState sets the State field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetState(state *string) {
	g.State = state
	g.require(geoInfoFieldState)
}

// SetCountry sets the Country field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetCountry(country *string) {
	g.Country = country
	g.require(geoInfoFieldCountry)
}

// SetRegion sets the Region field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetRegion(region *string) {
	g.Region = region
	g.require(geoInfoFieldRegion)
}

// SetLatitude sets the Latitude field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetLatitude(latitude *float64) {
	g.Latitude = latitude
	g.require(geoInfoFieldLatitude)
}

// SetLongitude sets the Longitude field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (g *GeoInfo) SetLongitude(longitude *float64) {
	g.Longitude = longitude
	g.require(geoInfoFieldLongitude)
}

func (g *GeoInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler GeoInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GeoInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GeoInfo) MarshalJSON() ([]byte, error) {
	type embed GeoInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*g),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, g.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (g *GeoInfo) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type InboxItem struct {
	Type               string
	DuplicateDocuments *InboxItemDuplicateDocuments
	MissingKnowledge   *InboxItemMissingKnowledge
}

func (i *InboxItem) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InboxItem) GetDuplicateDocuments() *InboxItemDuplicateDocuments {
	if i == nil {
		return nil
	}
	return i.DuplicateDocuments
}

func (i *InboxItem) GetMissingKnowledge() *InboxItemMissingKnowledge {
	if i == nil {
		return nil
	}
	return i.MissingKnowledge
}

func (i *InboxItem) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "duplicateDocuments":
		value := new(InboxItemDuplicateDocuments)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.DuplicateDocuments = value
	case "missingKnowledge":
		value := new(InboxItemMissingKnowledge)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.MissingKnowledge = value
	}
	return nil
}

func (i InboxItem) MarshalJSON() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	if i.DuplicateDocuments != nil {
		return internal.MarshalJSONWithExtraProperty(i.DuplicateDocuments, "type", "duplicateDocuments")
	}
	if i.MissingKnowledge != nil {
		return internal.MarshalJSONWithExtraProperty(i.MissingKnowledge, "type", "missingKnowledge")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type InboxItemVisitor interface {
	VisitDuplicateDocuments(*InboxItemDuplicateDocuments) error
	VisitMissingKnowledge(*InboxItemMissingKnowledge) error
}

func (i *InboxItem) Accept(visitor InboxItemVisitor) error {
	if i.DuplicateDocuments != nil {
		return visitor.VisitDuplicateDocuments(i.DuplicateDocuments)
	}
	if i.MissingKnowledge != nil {
		return visitor.VisitMissingKnowledge(i.MissingKnowledge)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

func (i *InboxItem) validate() error {
	if i == nil {
		return fmt.Errorf("type %T is nil", i)
	}
	var fields []string
	if i.DuplicateDocuments != nil {
		fields = append(fields, "duplicateDocuments")
	}
	if i.MissingKnowledge != nil {
		fields = append(fields, "missingKnowledge")
	}
	if len(fields) == 0 {
		if i.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", i, i.Type)
		}
		return fmt.Errorf("type %T is empty", i)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", i, fields)
	}
	if i.Type != "" {
		field := fields[0]
		if i.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				i,
				i.Type,
				i,
			)
		}
	}
	return nil
}

var (
	inboxItemBaseFieldId        = big.NewInt(1 << 0)
	inboxItemBaseFieldCreatedAt = big.NewInt(1 << 1)
	inboxItemBaseFieldUpdatedAt = big.NewInt(1 << 2)
	inboxItemBaseFieldStatus    = big.NewInt(1 << 3)
	inboxItemBaseFieldSeverity  = big.NewInt(1 << 4)
)

type InboxItemBase struct {
	// Unique identifier for the inbox item.
	Id *EntityId `json:"id" url:"id"`
	// Timestamp when the inbox item was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Timestamp when the inbox item was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Status of the inbox item.
	Status InboxItemStatus `json:"status" url:"status"`
	// Severity of the inbox item.
	Severity InboxItemSeverity `json:"severity" url:"severity"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemBase) GetId() *EntityId {
	if i == nil {
		return nil
	}
	return i.Id
}

func (i *InboxItemBase) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InboxItemBase) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InboxItemBase) GetStatus() InboxItemStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InboxItemBase) GetSeverity() InboxItemSeverity {
	if i == nil {
		return ""
	}
	return i.Severity
}

func (i *InboxItemBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemBase) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemBase) SetId(id *EntityId) {
	i.Id = id
	i.require(inboxItemBaseFieldId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemBase) SetCreatedAt(createdAt time.Time) {
	i.CreatedAt = createdAt
	i.require(inboxItemBaseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemBase) SetUpdatedAt(updatedAt time.Time) {
	i.UpdatedAt = updatedAt
	i.require(inboxItemBaseFieldUpdatedAt)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemBase) SetStatus(status InboxItemStatus) {
	i.Status = status
	i.require(inboxItemBaseFieldStatus)
}

// SetSeverity sets the Severity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemBase) SetSeverity(severity InboxItemSeverity) {
	i.Severity = severity
	i.require(inboxItemBaseFieldSeverity)
}

func (i *InboxItemBase) UnmarshalJSON(data []byte) error {
	type embed InboxItemBase
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InboxItemBase(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemBase) MarshalJSON() ([]byte, error) {
	type embed InboxItemBase
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
		UpdatedAt: internal.NewDateTime(i.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	inboxItemDuplicateDocumentsFieldId               = big.NewInt(1 << 0)
	inboxItemDuplicateDocumentsFieldCreatedAt        = big.NewInt(1 << 1)
	inboxItemDuplicateDocumentsFieldUpdatedAt        = big.NewInt(1 << 2)
	inboxItemDuplicateDocumentsFieldStatus           = big.NewInt(1 << 3)
	inboxItemDuplicateDocumentsFieldSeverity         = big.NewInt(1 << 4)
	inboxItemDuplicateDocumentsFieldRecommendedFixes = big.NewInt(1 << 5)
	inboxItemDuplicateDocumentsFieldOtherFixes       = big.NewInt(1 << 6)
	inboxItemDuplicateDocumentsFieldSourceDocument   = big.NewInt(1 << 7)
	inboxItemDuplicateDocumentsFieldDocuments        = big.NewInt(1 << 8)
)

type InboxItemDuplicateDocuments struct {
	// Unique identifier for the inbox item.
	Id *EntityId `json:"id" url:"id"`
	// Timestamp when the inbox item was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Timestamp when the inbox item was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Status of the inbox item.
	Status InboxItemStatus `json:"status" url:"status"`
	// Severity of the inbox item.
	Severity InboxItemSeverity `json:"severity" url:"severity"`
	// The fix recommended for being applied
	RecommendedFixes []*InboxItemFixDeactivateDocument `json:"recommendedFixes" url:"recommendedFixes"`
	// List of fixes associated with the inbox item.
	OtherFixes []*InboxItemFixDeactivateDocument `json:"otherFixes" url:"otherFixes"`
	// Information about the source document associated with the inbox item.
	SourceDocument *DocumentInformation `json:"sourceDocument" url:"sourceDocument"`
	// List of Document information objects related to the inbox item.
	Documents []*DocumentInformation `json:"documents" url:"documents"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemDuplicateDocuments) GetId() *EntityId {
	if i == nil {
		return nil
	}
	return i.Id
}

func (i *InboxItemDuplicateDocuments) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InboxItemDuplicateDocuments) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InboxItemDuplicateDocuments) GetStatus() InboxItemStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InboxItemDuplicateDocuments) GetSeverity() InboxItemSeverity {
	if i == nil {
		return ""
	}
	return i.Severity
}

func (i *InboxItemDuplicateDocuments) GetRecommendedFixes() []*InboxItemFixDeactivateDocument {
	if i == nil {
		return nil
	}
	return i.RecommendedFixes
}

func (i *InboxItemDuplicateDocuments) GetOtherFixes() []*InboxItemFixDeactivateDocument {
	if i == nil {
		return nil
	}
	return i.OtherFixes
}

func (i *InboxItemDuplicateDocuments) GetSourceDocument() *DocumentInformation {
	if i == nil {
		return nil
	}
	return i.SourceDocument
}

func (i *InboxItemDuplicateDocuments) GetDocuments() []*DocumentInformation {
	if i == nil {
		return nil
	}
	return i.Documents
}

func (i *InboxItemDuplicateDocuments) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemDuplicateDocuments) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetId(id *EntityId) {
	i.Id = id
	i.require(inboxItemDuplicateDocumentsFieldId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetCreatedAt(createdAt time.Time) {
	i.CreatedAt = createdAt
	i.require(inboxItemDuplicateDocumentsFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetUpdatedAt(updatedAt time.Time) {
	i.UpdatedAt = updatedAt
	i.require(inboxItemDuplicateDocumentsFieldUpdatedAt)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetStatus(status InboxItemStatus) {
	i.Status = status
	i.require(inboxItemDuplicateDocumentsFieldStatus)
}

// SetSeverity sets the Severity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetSeverity(severity InboxItemSeverity) {
	i.Severity = severity
	i.require(inboxItemDuplicateDocumentsFieldSeverity)
}

// SetRecommendedFixes sets the RecommendedFixes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetRecommendedFixes(recommendedFixes []*InboxItemFixDeactivateDocument) {
	i.RecommendedFixes = recommendedFixes
	i.require(inboxItemDuplicateDocumentsFieldRecommendedFixes)
}

// SetOtherFixes sets the OtherFixes field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetOtherFixes(otherFixes []*InboxItemFixDeactivateDocument) {
	i.OtherFixes = otherFixes
	i.require(inboxItemDuplicateDocumentsFieldOtherFixes)
}

// SetSourceDocument sets the SourceDocument field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetSourceDocument(sourceDocument *DocumentInformation) {
	i.SourceDocument = sourceDocument
	i.require(inboxItemDuplicateDocumentsFieldSourceDocument)
}

// SetDocuments sets the Documents field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemDuplicateDocuments) SetDocuments(documents []*DocumentInformation) {
	i.Documents = documents
	i.require(inboxItemDuplicateDocumentsFieldDocuments)
}

func (i *InboxItemDuplicateDocuments) UnmarshalJSON(data []byte) error {
	type embed InboxItemDuplicateDocuments
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InboxItemDuplicateDocuments(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemDuplicateDocuments) MarshalJSON() ([]byte, error) {
	type embed InboxItemDuplicateDocuments
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
		UpdatedAt: internal.NewDateTime(i.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemDuplicateDocuments) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InboxItemFix struct {
	Type               string
	AddDocument        *InboxItemFixAddDocument
	DeactivateDocument *InboxItemFixDeactivateDocument
}

func (i *InboxItemFix) GetType() string {
	if i == nil {
		return ""
	}
	return i.Type
}

func (i *InboxItemFix) GetAddDocument() *InboxItemFixAddDocument {
	if i == nil {
		return nil
	}
	return i.AddDocument
}

func (i *InboxItemFix) GetDeactivateDocument() *InboxItemFixDeactivateDocument {
	if i == nil {
		return nil
	}
	return i.DeactivateDocument
}

func (i *InboxItemFix) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	if unmarshaler.Type == "" {
		return fmt.Errorf("%T did not include discriminant type", i)
	}
	switch unmarshaler.Type {
	case "addDocument":
		value := new(InboxItemFixAddDocument)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.AddDocument = value
	case "deactivateDocument":
		value := new(InboxItemFixDeactivateDocument)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.DeactivateDocument = value
	}
	return nil
}

func (i InboxItemFix) MarshalJSON() ([]byte, error) {
	if err := i.validate(); err != nil {
		return nil, err
	}
	if i.AddDocument != nil {
		return internal.MarshalJSONWithExtraProperty(i.AddDocument, "type", "addDocument")
	}
	if i.DeactivateDocument != nil {
		return internal.MarshalJSONWithExtraProperty(i.DeactivateDocument, "type", "deactivateDocument")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", i)
}

type InboxItemFixVisitor interface {
	VisitAddDocument(*InboxItemFixAddDocument) error
	VisitDeactivateDocument(*InboxItemFixDeactivateDocument) error
}

func (i *InboxItemFix) Accept(visitor InboxItemFixVisitor) error {
	if i.AddDocument != nil {
		return visitor.VisitAddDocument(i.AddDocument)
	}
	if i.DeactivateDocument != nil {
		return visitor.VisitDeactivateDocument(i.DeactivateDocument)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", i)
}

func (i *InboxItemFix) validate() error {
	if i == nil {
		return fmt.Errorf("type %T is nil", i)
	}
	var fields []string
	if i.AddDocument != nil {
		fields = append(fields, "addDocument")
	}
	if i.DeactivateDocument != nil {
		fields = append(fields, "deactivateDocument")
	}
	if len(fields) == 0 {
		if i.Type != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", i, i.Type)
		}
		return fmt.Errorf("type %T is empty", i)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", i, fields)
	}
	if i.Type != "" {
		field := fields[0]
		if i.Type != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				i,
				i.Type,
				i,
			)
		}
	}
	return nil
}

var (
	inboxItemFixAddDocumentFieldId                 = big.NewInt(1 << 0)
	inboxItemFixAddDocumentFieldSuggestedTextTitle = big.NewInt(1 << 1)
	inboxItemFixAddDocumentFieldSuggestedText      = big.NewInt(1 << 2)
)

type InboxItemFixAddDocument struct {
	// Unique identifier for the inbox item fix.
	Id *EntityId `json:"id" url:"id"`
	// Suggested document title if the fix type is ADD_DOCUMENT.
	SuggestedTextTitle string `json:"suggestedTextTitle" url:"suggestedTextTitle"`
	// Suggested document text if the fix type is ADD_DOCUMENT.
	SuggestedText string `json:"suggestedText" url:"suggestedText"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemFixAddDocument) GetId() *EntityId {
	if i == nil {
		return nil
	}
	return i.Id
}

func (i *InboxItemFixAddDocument) GetSuggestedTextTitle() string {
	if i == nil {
		return ""
	}
	return i.SuggestedTextTitle
}

func (i *InboxItemFixAddDocument) GetSuggestedText() string {
	if i == nil {
		return ""
	}
	return i.SuggestedText
}

func (i *InboxItemFixAddDocument) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemFixAddDocument) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixAddDocument) SetId(id *EntityId) {
	i.Id = id
	i.require(inboxItemFixAddDocumentFieldId)
}

// SetSuggestedTextTitle sets the SuggestedTextTitle field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixAddDocument) SetSuggestedTextTitle(suggestedTextTitle string) {
	i.SuggestedTextTitle = suggestedTextTitle
	i.require(inboxItemFixAddDocumentFieldSuggestedTextTitle)
}

// SetSuggestedText sets the SuggestedText field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixAddDocument) SetSuggestedText(suggestedText string) {
	i.SuggestedText = suggestedText
	i.require(inboxItemFixAddDocumentFieldSuggestedText)
}

func (i *InboxItemFixAddDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler InboxItemFixAddDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InboxItemFixAddDocument(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemFixAddDocument) MarshalJSON() ([]byte, error) {
	type embed InboxItemFixAddDocument
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemFixAddDocument) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	inboxItemFixBaseFieldId = big.NewInt(1 << 0)
)

type InboxItemFixBase struct {
	// Unique identifier for the inbox item fix.
	Id *EntityId `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemFixBase) GetId() *EntityId {
	if i == nil {
		return nil
	}
	return i.Id
}

func (i *InboxItemFixBase) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemFixBase) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixBase) SetId(id *EntityId) {
	i.Id = id
	i.require(inboxItemFixBaseFieldId)
}

func (i *InboxItemFixBase) UnmarshalJSON(data []byte) error {
	type unmarshaler InboxItemFixBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InboxItemFixBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemFixBase) MarshalJSON() ([]byte, error) {
	type embed InboxItemFixBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemFixBase) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	inboxItemFixDeactivateDocumentFieldId                  = big.NewInt(1 << 0)
	inboxItemFixDeactivateDocumentFieldDocumentInformation = big.NewInt(1 << 1)
)

type InboxItemFixDeactivateDocument struct {
	// Unique identifier for the inbox item fix.
	Id *EntityId `json:"id" url:"id"`
	// Information about the document associated with this fix.
	DocumentInformation *DocumentInformation `json:"documentInformation" url:"documentInformation"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemFixDeactivateDocument) GetId() *EntityId {
	if i == nil {
		return nil
	}
	return i.Id
}

func (i *InboxItemFixDeactivateDocument) GetDocumentInformation() *DocumentInformation {
	if i == nil {
		return nil
	}
	return i.DocumentInformation
}

func (i *InboxItemFixDeactivateDocument) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemFixDeactivateDocument) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixDeactivateDocument) SetId(id *EntityId) {
	i.Id = id
	i.require(inboxItemFixDeactivateDocumentFieldId)
}

// SetDocumentInformation sets the DocumentInformation field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemFixDeactivateDocument) SetDocumentInformation(documentInformation *DocumentInformation) {
	i.DocumentInformation = documentInformation
	i.require(inboxItemFixDeactivateDocumentFieldDocumentInformation)
}

func (i *InboxItemFixDeactivateDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler InboxItemFixDeactivateDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = InboxItemFixDeactivateDocument(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemFixDeactivateDocument) MarshalJSON() ([]byte, error) {
	type embed InboxItemFixDeactivateDocument
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemFixDeactivateDocument) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	inboxItemMissingKnowledgeFieldId            = big.NewInt(1 << 0)
	inboxItemMissingKnowledgeFieldCreatedAt     = big.NewInt(1 << 1)
	inboxItemMissingKnowledgeFieldUpdatedAt     = big.NewInt(1 << 2)
	inboxItemMissingKnowledgeFieldStatus        = big.NewInt(1 << 3)
	inboxItemMissingKnowledgeFieldSeverity      = big.NewInt(1 << 4)
	inboxItemMissingKnowledgeFieldFix           = big.NewInt(1 << 5)
	inboxItemMissingKnowledgeFieldConversations = big.NewInt(1 << 6)
)

type InboxItemMissingKnowledge struct {
	// Unique identifier for the inbox item.
	Id *EntityId `json:"id" url:"id"`
	// Timestamp when the inbox item was created.
	CreatedAt time.Time `json:"createdAt" url:"createdAt"`
	// Timestamp when the inbox item was last updated.
	UpdatedAt time.Time `json:"updatedAt" url:"updatedAt"`
	// Status of the inbox item.
	Status InboxItemStatus `json:"status" url:"status"`
	// Severity of the inbox item.
	Severity InboxItemSeverity `json:"severity" url:"severity"`
	// Fix associated with the inbox item.
	Fix *InboxItemFixAddDocument `json:"fix" url:"fix"`
	// List of Conversation information objects related to the inbox item.
	Conversations []*ConversationInformation `json:"conversations" url:"conversations"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *InboxItemMissingKnowledge) GetId() *EntityId {
	if i == nil {
		return nil
	}
	return i.Id
}

func (i *InboxItemMissingKnowledge) GetCreatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.CreatedAt
}

func (i *InboxItemMissingKnowledge) GetUpdatedAt() time.Time {
	if i == nil {
		return time.Time{}
	}
	return i.UpdatedAt
}

func (i *InboxItemMissingKnowledge) GetStatus() InboxItemStatus {
	if i == nil {
		return ""
	}
	return i.Status
}

func (i *InboxItemMissingKnowledge) GetSeverity() InboxItemSeverity {
	if i == nil {
		return ""
	}
	return i.Severity
}

func (i *InboxItemMissingKnowledge) GetFix() *InboxItemFixAddDocument {
	if i == nil {
		return nil
	}
	return i.Fix
}

func (i *InboxItemMissingKnowledge) GetConversations() []*ConversationInformation {
	if i == nil {
		return nil
	}
	return i.Conversations
}

func (i *InboxItemMissingKnowledge) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *InboxItemMissingKnowledge) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetId(id *EntityId) {
	i.Id = id
	i.require(inboxItemMissingKnowledgeFieldId)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetCreatedAt(createdAt time.Time) {
	i.CreatedAt = createdAt
	i.require(inboxItemMissingKnowledgeFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetUpdatedAt(updatedAt time.Time) {
	i.UpdatedAt = updatedAt
	i.require(inboxItemMissingKnowledgeFieldUpdatedAt)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetStatus(status InboxItemStatus) {
	i.Status = status
	i.require(inboxItemMissingKnowledgeFieldStatus)
}

// SetSeverity sets the Severity field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetSeverity(severity InboxItemSeverity) {
	i.Severity = severity
	i.require(inboxItemMissingKnowledgeFieldSeverity)
}

// SetFix sets the Fix field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetFix(fix *InboxItemFixAddDocument) {
	i.Fix = fix
	i.require(inboxItemMissingKnowledgeFieldFix)
}

// SetConversations sets the Conversations field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *InboxItemMissingKnowledge) SetConversations(conversations []*ConversationInformation) {
	i.Conversations = conversations
	i.require(inboxItemMissingKnowledgeFieldConversations)
}

func (i *InboxItemMissingKnowledge) UnmarshalJSON(data []byte) error {
	type embed InboxItemMissingKnowledge
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed: embed(*i),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*i = InboxItemMissingKnowledge(unmarshaler.embed)
	i.CreatedAt = unmarshaler.CreatedAt.Time()
	i.UpdatedAt = unmarshaler.UpdatedAt.Time()
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *InboxItemMissingKnowledge) MarshalJSON() ([]byte, error) {
	type embed InboxItemMissingKnowledge
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt"`
		UpdatedAt *internal.DateTime `json:"updatedAt"`
	}{
		embed:     embed(*i),
		CreatedAt: internal.NewDateTime(i.CreatedAt),
		UpdatedAt: internal.NewDateTime(i.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *InboxItemMissingKnowledge) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

type InboxItemSeverity string

const (
	InboxItemSeverityLow    InboxItemSeverity = "LOW"
	InboxItemSeverityMedium InboxItemSeverity = "MEDIUM"
	InboxItemSeverityHigh   InboxItemSeverity = "HIGH"
)

func NewInboxItemSeverityFromString(s string) (InboxItemSeverity, error) {
	switch s {
	case "LOW":
		return InboxItemSeverityLow, nil
	case "MEDIUM":
		return InboxItemSeverityMedium, nil
	case "HIGH":
		return InboxItemSeverityHigh, nil
	}
	var t InboxItemSeverity
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InboxItemSeverity) Ptr() *InboxItemSeverity {
	return &i
}

type InboxItemStatus string

const (
	// The inbox item is open.
	InboxItemStatusOpen InboxItemStatus = "OPEN"
	// The inbox item was resolved by the user.
	InboxItemStatusUserResolved InboxItemStatus = "USER_RESOLVED"
	// The inbox item was resolved by the system.
	InboxItemStatusSystemResolved InboxItemStatus = "SYSTEM_RESOLVED"
	// The inbox item has regressed.
	InboxItemStatusRegressed InboxItemStatus = "REGRESSED"
	// The inbox item was ignored.
	InboxItemStatusIgnored InboxItemStatus = "IGNORED"
)

func NewInboxItemStatusFromString(s string) (InboxItemStatus, error) {
	switch s {
	case "OPEN":
		return InboxItemStatusOpen, nil
	case "USER_RESOLVED":
		return InboxItemStatusUserResolved, nil
	case "SYSTEM_RESOLVED":
		return InboxItemStatusSystemResolved, nil
	case "REGRESSED":
		return InboxItemStatusRegressed, nil
	case "IGNORED":
		return InboxItemStatusIgnored, nil
	}
	var t InboxItemStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InboxItemStatus) Ptr() *InboxItemStatus {
	return &i
}

type InboxItemType string

const (
	// The inbox item is a duplicate document.
	InboxItemTypeDuplicateDocument InboxItemType = "DUPLICATE_DOCUMENT"
	// The inbox item is missing knowledge.
	InboxItemTypeMissingKnowledge InboxItemType = "MISSING_KNOWLEDGE"
)

func NewInboxItemTypeFromString(s string) (InboxItemType, error) {
	switch s {
	case "DUPLICATE_DOCUMENT":
		return InboxItemTypeDuplicateDocument, nil
	case "MISSING_KNOWLEDGE":
		return InboxItemTypeMissingKnowledge, nil
	}
	var t InboxItemType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i InboxItemType) Ptr() *InboxItemType {
	return &i
}

var (
	ipInfoFieldIp = big.NewInt(1 << 0)
)

type IpInfo struct {
	Ip *string `json:"ip,omitempty" url:"ip,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (i *IpInfo) GetIp() *string {
	if i == nil {
		return nil
	}
	return i.Ip
}

func (i *IpInfo) GetExtraProperties() map[string]interface{} {
	return i.extraProperties
}

func (i *IpInfo) require(field *big.Int) {
	if i.explicitFields == nil {
		i.explicitFields = big.NewInt(0)
	}
	i.explicitFields.Or(i.explicitFields, field)
}

// SetIp sets the Ip field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (i *IpInfo) SetIp(ip *string) {
	i.Ip = ip
	i.require(ipInfoFieldIp)
}

func (i *IpInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler IpInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*i = IpInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *i)
	if err != nil {
		return err
	}
	i.extraProperties = extraProperties
	i.rawJSON = json.RawMessage(data)
	return nil
}

func (i *IpInfo) MarshalJSON() ([]byte, error) {
	type embed IpInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*i),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, i.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (i *IpInfo) String() string {
	if len(i.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(i.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(i); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", i)
}

var (
	languageInfoFieldCode = big.NewInt(1 << 0)
)

type LanguageInfo struct {
	Code *string `json:"code,omitempty" url:"code,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *LanguageInfo) GetCode() *string {
	if l == nil {
		return nil
	}
	return l.Code
}

func (l *LanguageInfo) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *LanguageInfo) require(field *big.Int) {
	if l.explicitFields == nil {
		l.explicitFields = big.NewInt(0)
	}
	l.explicitFields.Or(l.explicitFields, field)
}

// SetCode sets the Code field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (l *LanguageInfo) SetCode(code *string) {
	l.Code = code
	l.require(languageInfoFieldCode)
}

func (l *LanguageInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler LanguageInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LanguageInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *LanguageInfo) MarshalJSON() ([]byte, error) {
	type embed LanguageInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*l),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, l.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (l *LanguageInfo) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type LlmInclusionStatus string

const (
	LlmInclusionStatusAlways       LlmInclusionStatus = "ALWAYS"
	LlmInclusionStatusWhenRelevant LlmInclusionStatus = "WHEN_RELEVANT"
	LlmInclusionStatusNever        LlmInclusionStatus = "NEVER"
)

func NewLlmInclusionStatusFromString(s string) (LlmInclusionStatus, error) {
	switch s {
	case "ALWAYS":
		return LlmInclusionStatusAlways, nil
	case "WHEN_RELEVANT":
		return LlmInclusionStatusWhenRelevant, nil
	case "NEVER":
		return LlmInclusionStatusNever, nil
	}
	var t LlmInclusionStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LlmInclusionStatus) Ptr() *LlmInclusionStatus {
	return &l
}

type LlmPersona string

const (
	LlmPersonaCasualBuddy         LlmPersona = "CASUAL_BUDDY"
	LlmPersonaEmpatheticSupporter LlmPersona = "EMPATHETIC_SUPPORTER"
	LlmPersonaFormalProfessional  LlmPersona = "FORMAL_PROFESSIONAL"
	LlmPersonaConciseExpert       LlmPersona = "CONCISE_EXPERT"
	LlmPersonaEnthusiasticHelper  LlmPersona = "ENTHUSIASTIC_HELPER"
	LlmPersonaPatientEducator     LlmPersona = "PATIENT_EDUCATOR"
	LlmPersonaPirate              LlmPersona = "PIRATE"
)

func NewLlmPersonaFromString(s string) (LlmPersona, error) {
	switch s {
	case "CASUAL_BUDDY":
		return LlmPersonaCasualBuddy, nil
	case "EMPATHETIC_SUPPORTER":
		return LlmPersonaEmpatheticSupporter, nil
	case "FORMAL_PROFESSIONAL":
		return LlmPersonaFormalProfessional, nil
	case "CONCISE_EXPERT":
		return LlmPersonaConciseExpert, nil
	case "ENTHUSIASTIC_HELPER":
		return LlmPersonaEnthusiasticHelper, nil
	case "PATIENT_EDUCATOR":
		return LlmPersonaPatientEducator, nil
	case "PIRATE":
		return LlmPersonaPirate, nil
	}
	var t LlmPersona
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (l LlmPersona) Ptr() *LlmPersona {
	return &l
}

// The delivery status of the message.
//
// * `SENDING`: The message is being streamed to the user.
// * `SENT`: The message has been sent to the user.
// * `REJECTED`: The message was rejected by the system.
// * `CANCELED`: The message was canceled by the user before streaming was complete.
// * `FAILED`: The message generating or sending encountered an error.
// * `UNKNOWN`: The message status is unknown.
type MessageStatus string

const (
	MessageStatusSending  MessageStatus = "SENDING"
	MessageStatusSent     MessageStatus = "SENT"
	MessageStatusRejected MessageStatus = "REJECTED"
	MessageStatusCanceled MessageStatus = "CANCELED"
	MessageStatusFailed   MessageStatus = "FAILED"
	MessageStatusUnknown  MessageStatus = "UNKNOWN"
)

func NewMessageStatusFromString(s string) (MessageStatus, error) {
	switch s {
	case "SENDING":
		return MessageStatusSending, nil
	case "SENT":
		return MessageStatusSent, nil
	case "REJECTED":
		return MessageStatusRejected, nil
	case "CANCELED":
		return MessageStatusCanceled, nil
	case "FAILED":
		return MessageStatusFailed, nil
	case "UNKNOWN":
		return MessageStatusUnknown, nil
	}
	var t MessageStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MessageStatus) Ptr() *MessageStatus {
	return &m
}

var (
	metadataPreconditionFieldOperator = big.NewInt(1 << 0)
	metadataPreconditionFieldKey      = big.NewInt(1 << 1)
	metadataPreconditionFieldValue    = big.NewInt(1 << 2)
)

type MetadataPrecondition struct {
	// Operator to apply to this precondition
	Operator *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`
	// The key that must be present in the metadata for a precondition to be met
	Key string `json:"key" url:"key"`
	// If set, the value must match the metadata value for the given key
	Value *string `json:"value,omitempty" url:"value,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (m *MetadataPrecondition) GetOperator() *PreconditionOperator {
	if m == nil {
		return nil
	}
	return m.Operator
}

func (m *MetadataPrecondition) GetKey() string {
	if m == nil {
		return ""
	}
	return m.Key
}

func (m *MetadataPrecondition) GetValue() *string {
	if m == nil {
		return nil
	}
	return m.Value
}

func (m *MetadataPrecondition) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataPrecondition) require(field *big.Int) {
	if m.explicitFields == nil {
		m.explicitFields = big.NewInt(0)
	}
	m.explicitFields.Or(m.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MetadataPrecondition) SetOperator(operator *PreconditionOperator) {
	m.Operator = operator
	m.require(metadataPreconditionFieldOperator)
}

// SetKey sets the Key field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MetadataPrecondition) SetKey(key string) {
	m.Key = key
	m.require(metadataPreconditionFieldKey)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (m *MetadataPrecondition) SetValue(value *string) {
	m.Value = value
	m.require(metadataPreconditionFieldValue)
}

func (m *MetadataPrecondition) UnmarshalJSON(data []byte) error {
	type unmarshaler MetadataPrecondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = MetadataPrecondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties
	m.rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataPrecondition) MarshalJSON() ([]byte, error) {
	type embed MetadataPrecondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*m),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, m.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (m *MetadataPrecondition) String() string {
	if len(m.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(m.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

var (
	novelSystemEventFieldTimestamp   = big.NewInt(1 << 0)
	novelSystemEventFieldReferences  = big.NewInt(1 << 1)
	novelSystemEventFieldSourceInfo  = big.NewInt(1 << 2)
	novelSystemEventFieldSessionInfo = big.NewInt(1 << 3)
	novelSystemEventFieldContextInfo = big.NewInt(1 << 4)
	novelSystemEventFieldEventName   = big.NewInt(1 << 5)
	novelSystemEventFieldId          = big.NewInt(1 << 6)
)

type NovelSystemEvent struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`
	// The name of the event
	EventName SystemEventName `json:"eventName" url:"eventName"`
	// The unique ID of the event
	Id *EntityIdBase `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NovelSystemEvent) GetTimestamp() *time.Time {
	if n == nil {
		return nil
	}
	return n.Timestamp
}

func (n *NovelSystemEvent) GetReferences() []*ScopedEntity {
	if n == nil {
		return nil
	}
	return n.References
}

func (n *NovelSystemEvent) GetSourceInfo() *SourceInfo {
	if n == nil {
		return nil
	}
	return n.SourceInfo
}

func (n *NovelSystemEvent) GetSessionInfo() *SessionInfo {
	if n == nil {
		return nil
	}
	return n.SessionInfo
}

func (n *NovelSystemEvent) GetContextInfo() *ContextInfo {
	if n == nil {
		return nil
	}
	return n.ContextInfo
}

func (n *NovelSystemEvent) GetEventName() SystemEventName {
	if n == nil {
		return ""
	}
	return n.EventName
}

func (n *NovelSystemEvent) GetId() *EntityIdBase {
	if n == nil {
		return nil
	}
	return n.Id
}

func (n *NovelSystemEvent) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NovelSystemEvent) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetTimestamp(timestamp *time.Time) {
	n.Timestamp = timestamp
	n.require(novelSystemEventFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetReferences(references []*ScopedEntity) {
	n.References = references
	n.require(novelSystemEventFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetSourceInfo(sourceInfo *SourceInfo) {
	n.SourceInfo = sourceInfo
	n.require(novelSystemEventFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetSessionInfo(sessionInfo *SessionInfo) {
	n.SessionInfo = sessionInfo
	n.require(novelSystemEventFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetContextInfo(contextInfo *ContextInfo) {
	n.ContextInfo = contextInfo
	n.require(novelSystemEventFieldContextInfo)
}

// SetEventName sets the EventName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetEventName(eventName SystemEventName) {
	n.EventName = eventName
	n.require(novelSystemEventFieldEventName)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEvent) SetId(id *EntityIdBase) {
	n.Id = id
	n.require(novelSystemEventFieldId)
}

func (n *NovelSystemEvent) UnmarshalJSON(data []byte) error {
	type embed NovelSystemEvent
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NovelSystemEvent(unmarshaler.embed)
	n.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NovelSystemEvent) MarshalJSON() ([]byte, error) {
	type embed NovelSystemEvent
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*n),
		Timestamp: internal.NewOptionalDateTime(n.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NovelSystemEvent) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	novelSystemEventNoIdFieldTimestamp   = big.NewInt(1 << 0)
	novelSystemEventNoIdFieldReferences  = big.NewInt(1 << 1)
	novelSystemEventNoIdFieldSourceInfo  = big.NewInt(1 << 2)
	novelSystemEventNoIdFieldSessionInfo = big.NewInt(1 << 3)
	novelSystemEventNoIdFieldContextInfo = big.NewInt(1 << 4)
	novelSystemEventNoIdFieldEventName   = big.NewInt(1 << 5)
)

type NovelSystemEventNoId struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`
	// The name of the event
	EventName SystemEventName `json:"eventName" url:"eventName"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NovelSystemEventNoId) GetTimestamp() *time.Time {
	if n == nil {
		return nil
	}
	return n.Timestamp
}

func (n *NovelSystemEventNoId) GetReferences() []*ScopedEntity {
	if n == nil {
		return nil
	}
	return n.References
}

func (n *NovelSystemEventNoId) GetSourceInfo() *SourceInfo {
	if n == nil {
		return nil
	}
	return n.SourceInfo
}

func (n *NovelSystemEventNoId) GetSessionInfo() *SessionInfo {
	if n == nil {
		return nil
	}
	return n.SessionInfo
}

func (n *NovelSystemEventNoId) GetContextInfo() *ContextInfo {
	if n == nil {
		return nil
	}
	return n.ContextInfo
}

func (n *NovelSystemEventNoId) GetEventName() SystemEventName {
	if n == nil {
		return ""
	}
	return n.EventName
}

func (n *NovelSystemEventNoId) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NovelSystemEventNoId) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoId) SetTimestamp(timestamp *time.Time) {
	n.Timestamp = timestamp
	n.require(novelSystemEventNoIdFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoId) SetReferences(references []*ScopedEntity) {
	n.References = references
	n.require(novelSystemEventNoIdFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoId) SetSourceInfo(sourceInfo *SourceInfo) {
	n.SourceInfo = sourceInfo
	n.require(novelSystemEventNoIdFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoId) SetSessionInfo(sessionInfo *SessionInfo) {
	n.SessionInfo = sessionInfo
	n.require(novelSystemEventNoIdFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoId) SetContextInfo(contextInfo *ContextInfo) {
	n.ContextInfo = contextInfo
	n.require(novelSystemEventNoIdFieldContextInfo)
}

// SetEventName sets the EventName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelSystemEventNoId) SetEventName(eventName SystemEventName) {
	n.EventName = eventName
	n.require(novelSystemEventNoIdFieldEventName)
}

func (n *NovelSystemEventNoId) UnmarshalJSON(data []byte) error {
	type embed NovelSystemEventNoId
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NovelSystemEventNoId(unmarshaler.embed)
	n.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NovelSystemEventNoId) MarshalJSON() ([]byte, error) {
	type embed NovelSystemEventNoId
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*n),
		Timestamp: internal.NewOptionalDateTime(n.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NovelSystemEventNoId) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	novelUserEventFieldTimestamp    = big.NewInt(1 << 0)
	novelUserEventFieldReferences   = big.NewInt(1 << 1)
	novelUserEventFieldSourceInfo   = big.NewInt(1 << 2)
	novelUserEventFieldSessionInfo  = big.NewInt(1 << 3)
	novelUserEventFieldContextInfo  = big.NewInt(1 << 4)
	novelUserEventFieldId           = big.NewInt(1 << 5)
	novelUserEventFieldEventName    = big.NewInt(1 << 6)
	novelUserEventFieldUserInfo     = big.NewInt(1 << 7)
	novelUserEventFieldFeedbackInfo = big.NewInt(1 << 8)
	novelUserEventFieldPageInfo     = big.NewInt(1 << 9)
)

type NovelUserEvent struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`
	// The unique ID of the event
	Id *EntityIdBase `json:"id" url:"id"`
	// The name of the event
	EventName UserEventName `json:"eventName" url:"eventName"`
	// Information about the user who triggered the event
	UserInfo *EventUserInfoBase `json:"userInfo" url:"userInfo"`
	// Information about any feedback associated with the event
	FeedbackInfo []*FeedbackInfo `json:"feedbackInfo,omitempty" url:"feedbackInfo,omitempty"`
	// Information about the page on which the event occurred
	PageInfo *PageInfo `json:"pageInfo,omitempty" url:"pageInfo,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NovelUserEvent) GetTimestamp() *time.Time {
	if n == nil {
		return nil
	}
	return n.Timestamp
}

func (n *NovelUserEvent) GetReferences() []*ScopedEntity {
	if n == nil {
		return nil
	}
	return n.References
}

func (n *NovelUserEvent) GetSourceInfo() *SourceInfo {
	if n == nil {
		return nil
	}
	return n.SourceInfo
}

func (n *NovelUserEvent) GetSessionInfo() *SessionInfo {
	if n == nil {
		return nil
	}
	return n.SessionInfo
}

func (n *NovelUserEvent) GetContextInfo() *ContextInfo {
	if n == nil {
		return nil
	}
	return n.ContextInfo
}

func (n *NovelUserEvent) GetId() *EntityIdBase {
	if n == nil {
		return nil
	}
	return n.Id
}

func (n *NovelUserEvent) GetEventName() UserEventName {
	if n == nil {
		return ""
	}
	return n.EventName
}

func (n *NovelUserEvent) GetUserInfo() *EventUserInfoBase {
	if n == nil {
		return nil
	}
	return n.UserInfo
}

func (n *NovelUserEvent) GetFeedbackInfo() []*FeedbackInfo {
	if n == nil {
		return nil
	}
	return n.FeedbackInfo
}

func (n *NovelUserEvent) GetPageInfo() *PageInfo {
	if n == nil {
		return nil
	}
	return n.PageInfo
}

func (n *NovelUserEvent) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NovelUserEvent) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetTimestamp(timestamp *time.Time) {
	n.Timestamp = timestamp
	n.require(novelUserEventFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetReferences(references []*ScopedEntity) {
	n.References = references
	n.require(novelUserEventFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetSourceInfo(sourceInfo *SourceInfo) {
	n.SourceInfo = sourceInfo
	n.require(novelUserEventFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetSessionInfo(sessionInfo *SessionInfo) {
	n.SessionInfo = sessionInfo
	n.require(novelUserEventFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetContextInfo(contextInfo *ContextInfo) {
	n.ContextInfo = contextInfo
	n.require(novelUserEventFieldContextInfo)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetId(id *EntityIdBase) {
	n.Id = id
	n.require(novelUserEventFieldId)
}

// SetEventName sets the EventName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetEventName(eventName UserEventName) {
	n.EventName = eventName
	n.require(novelUserEventFieldEventName)
}

// SetUserInfo sets the UserInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetUserInfo(userInfo *EventUserInfoBase) {
	n.UserInfo = userInfo
	n.require(novelUserEventFieldUserInfo)
}

// SetFeedbackInfo sets the FeedbackInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetFeedbackInfo(feedbackInfo []*FeedbackInfo) {
	n.FeedbackInfo = feedbackInfo
	n.require(novelUserEventFieldFeedbackInfo)
}

// SetPageInfo sets the PageInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NovelUserEvent) SetPageInfo(pageInfo *PageInfo) {
	n.PageInfo = pageInfo
	n.require(novelUserEventFieldPageInfo)
}

func (n *NovelUserEvent) UnmarshalJSON(data []byte) error {
	type embed NovelUserEvent
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*n),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*n = NovelUserEvent(unmarshaler.embed)
	n.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NovelUserEvent) MarshalJSON() ([]byte, error) {
	type embed NovelUserEvent
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*n),
		Timestamp: internal.NewOptionalDateTime(n.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NovelUserEvent) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

// A range of numbers that can be used to filter search results by numeric fields.
// - `greaterThanOrEqual`: The minimum value (inclusive).
// - `lessThan`: The maximum value (exclusive).
var (
	numberRangeFieldGreaterThanOrEqual = big.NewInt(1 << 0)
	numberRangeFieldLessThan           = big.NewInt(1 << 1)
)

type NumberRange struct {
	GreaterThanOrEqual *int `json:"greaterThanOrEqual,omitempty" url:"greaterThanOrEqual,omitempty"`
	LessThan           *int `json:"lessThan,omitempty" url:"lessThan,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (n *NumberRange) GetGreaterThanOrEqual() *int {
	if n == nil {
		return nil
	}
	return n.GreaterThanOrEqual
}

func (n *NumberRange) GetLessThan() *int {
	if n == nil {
		return nil
	}
	return n.LessThan
}

func (n *NumberRange) GetExtraProperties() map[string]interface{} {
	return n.extraProperties
}

func (n *NumberRange) require(field *big.Int) {
	if n.explicitFields == nil {
		n.explicitFields = big.NewInt(0)
	}
	n.explicitFields.Or(n.explicitFields, field)
}

// SetGreaterThanOrEqual sets the GreaterThanOrEqual field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumberRange) SetGreaterThanOrEqual(greaterThanOrEqual *int) {
	n.GreaterThanOrEqual = greaterThanOrEqual
	n.require(numberRangeFieldGreaterThanOrEqual)
}

// SetLessThan sets the LessThan field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (n *NumberRange) SetLessThan(lessThan *int) {
	n.LessThan = lessThan
	n.require(numberRangeFieldLessThan)
}

func (n *NumberRange) UnmarshalJSON(data []byte) error {
	type unmarshaler NumberRange
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NumberRange(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *n)
	if err != nil {
		return err
	}
	n.extraProperties = extraProperties
	n.rawJSON = json.RawMessage(data)
	return nil
}

func (n *NumberRange) MarshalJSON() ([]byte, error) {
	type embed NumberRange
	var marshaler = struct {
		embed
	}{
		embed: embed(*n),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, n.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (n *NumberRange) String() string {
	if len(n.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(n.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

var (
	osInfoFieldType    = big.NewInt(1 << 0)
	osInfoFieldName    = big.NewInt(1 << 1)
	osInfoFieldVersion = big.NewInt(1 << 2)
)

type OsInfo struct {
	Type    *OsType `json:"type,omitempty" url:"type,omitempty"`
	Name    *string `json:"name,omitempty" url:"name,omitempty"`
	Version *string `json:"version,omitempty" url:"version,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (o *OsInfo) GetType() *OsType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OsInfo) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *OsInfo) GetVersion() *string {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *OsInfo) GetExtraProperties() map[string]interface{} {
	return o.extraProperties
}

func (o *OsInfo) require(field *big.Int) {
	if o.explicitFields == nil {
		o.explicitFields = big.NewInt(0)
	}
	o.explicitFields.Or(o.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OsInfo) SetType(type_ *OsType) {
	o.Type = type_
	o.require(osInfoFieldType)
}

// SetName sets the Name field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OsInfo) SetName(name *string) {
	o.Name = name
	o.require(osInfoFieldName)
}

// SetVersion sets the Version field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (o *OsInfo) SetVersion(version *string) {
	o.Version = version
	o.require(osInfoFieldVersion)
}

func (o *OsInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler OsInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OsInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *o)
	if err != nil {
		return err
	}
	o.extraProperties = extraProperties
	o.rawJSON = json.RawMessage(data)
	return nil
}

func (o *OsInfo) MarshalJSON() ([]byte, error) {
	type embed OsInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*o),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, o.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (o *OsInfo) String() string {
	if len(o.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(o.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type OsType string

const (
	OsTypeWindows OsType = "WINDOWS"
	OsTypeMacos   OsType = "MACOS"
	OsTypeLinux   OsType = "LINUX"
	OsTypeAndroid OsType = "ANDROID"
	OsTypeIos     OsType = "IOS"
	OsTypeOther   OsType = "OTHER"
)

func NewOsTypeFromString(s string) (OsType, error) {
	switch s {
	case "WINDOWS":
		return OsTypeWindows, nil
	case "MACOS":
		return OsTypeMacos, nil
	case "LINUX":
		return OsTypeLinux, nil
	case "ANDROID":
		return OsTypeAndroid, nil
	case "IOS":
		return OsTypeIos, nil
	case "OTHER":
		return OsTypeOther, nil
	}
	var t OsType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OsType) Ptr() *OsType {
	return &o
}

var (
	pageFieldNumber        = big.NewInt(1 << 0)
	pageFieldSize          = big.NewInt(1 << 1)
	pageFieldTotalElements = big.NewInt(1 << 2)
	pageFieldTotalPages    = big.NewInt(1 << 3)
)

type Page struct {
	// The page being returned, starts at 0
	Number int `json:"number" url:"number"`
	// The number of elements in this page
	Size int `json:"size" url:"size"`
	// The total number of elements in the collection
	TotalElements int64 `json:"totalElements" url:"totalElements"`
	// The total number of pages in the collection
	TotalPages int `json:"totalPages" url:"totalPages"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Page) GetNumber() int {
	if p == nil {
		return 0
	}
	return p.Number
}

func (p *Page) GetSize() int {
	if p == nil {
		return 0
	}
	return p.Size
}

func (p *Page) GetTotalElements() int64 {
	if p == nil {
		return 0
	}
	return p.TotalElements
}

func (p *Page) GetTotalPages() int {
	if p == nil {
		return 0
	}
	return p.TotalPages
}

func (p *Page) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Page) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetNumber sets the Number field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetNumber(number int) {
	p.Number = number
	p.require(pageFieldNumber)
}

// SetSize sets the Size field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetSize(size int) {
	p.Size = size
	p.require(pageFieldSize)
}

// SetTotalElements sets the TotalElements field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetTotalElements(totalElements int64) {
	p.TotalElements = totalElements
	p.require(pageFieldTotalElements)
}

// SetTotalPages sets the TotalPages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *Page) SetTotalPages(totalPages int) {
	p.TotalPages = totalPages
	p.require(pageFieldTotalPages)
}

func (p *Page) UnmarshalJSON(data []byte) error {
	type unmarshaler Page
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Page(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Page) MarshalJSON() ([]byte, error) {
	type embed Page
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *Page) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	pageInfoFieldPageName  = big.NewInt(1 << 0)
	pageInfoFieldPageUrl   = big.NewInt(1 << 1)
	pageInfoFieldPageTitle = big.NewInt(1 << 2)
	pageInfoFieldLinkUrl   = big.NewInt(1 << 3)
	pageInfoFieldElementId = big.NewInt(1 << 4)
)

type PageInfo struct {
	PageName  *string `json:"pageName,omitempty" url:"pageName,omitempty"`
	PageUrl   *string `json:"pageUrl,omitempty" url:"pageUrl,omitempty"`
	PageTitle *string `json:"pageTitle,omitempty" url:"pageTitle,omitempty"`
	LinkUrl   *string `json:"linkUrl,omitempty" url:"linkUrl,omitempty"`
	ElementId *string `json:"elementId,omitempty" url:"elementId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PageInfo) GetPageName() *string {
	if p == nil {
		return nil
	}
	return p.PageName
}

func (p *PageInfo) GetPageUrl() *string {
	if p == nil {
		return nil
	}
	return p.PageUrl
}

func (p *PageInfo) GetPageTitle() *string {
	if p == nil {
		return nil
	}
	return p.PageTitle
}

func (p *PageInfo) GetLinkUrl() *string {
	if p == nil {
		return nil
	}
	return p.LinkUrl
}

func (p *PageInfo) GetElementId() *string {
	if p == nil {
		return nil
	}
	return p.ElementId
}

func (p *PageInfo) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PageInfo) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetPageName sets the PageName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PageInfo) SetPageName(pageName *string) {
	p.PageName = pageName
	p.require(pageInfoFieldPageName)
}

// SetPageUrl sets the PageUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PageInfo) SetPageUrl(pageUrl *string) {
	p.PageUrl = pageUrl
	p.require(pageInfoFieldPageUrl)
}

// SetPageTitle sets the PageTitle field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PageInfo) SetPageTitle(pageTitle *string) {
	p.PageTitle = pageTitle
	p.require(pageInfoFieldPageTitle)
}

// SetLinkUrl sets the LinkUrl field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PageInfo) SetLinkUrl(linkUrl *string) {
	p.LinkUrl = linkUrl
	p.require(pageInfoFieldLinkUrl)
}

// SetElementId sets the ElementId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PageInfo) SetElementId(elementId *string) {
	p.ElementId = elementId
	p.require(pageInfoFieldElementId)
}

func (p *PageInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler PageInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PageInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PageInfo) MarshalJSON() ([]byte, error) {
	type embed PageInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PageInfo) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type Precondition struct {
	PreconditionType string
	User             *MetadataPrecondition
	Conversation     *ConversationPrecondition
	Group            *PreconditionGroup
}

func (p *Precondition) GetPreconditionType() string {
	if p == nil {
		return ""
	}
	return p.PreconditionType
}

func (p *Precondition) GetUser() *MetadataPrecondition {
	if p == nil {
		return nil
	}
	return p.User
}

func (p *Precondition) GetConversation() *ConversationPrecondition {
	if p == nil {
		return nil
	}
	return p.Conversation
}

func (p *Precondition) GetGroup() *PreconditionGroup {
	if p == nil {
		return nil
	}
	return p.Group
}

func (p *Precondition) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		PreconditionType string `json:"preconditionType"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	p.PreconditionType = unmarshaler.PreconditionType
	if unmarshaler.PreconditionType == "" {
		return fmt.Errorf("%T did not include discriminant preconditionType", p)
	}
	switch unmarshaler.PreconditionType {
	case "user":
		value := new(MetadataPrecondition)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.User = value
	case "conversation":
		var valueUnmarshaler struct {
			Conversation *ConversationPrecondition `json:"value"`
		}
		if err := json.Unmarshal(data, &valueUnmarshaler); err != nil {
			return err
		}
		p.Conversation = valueUnmarshaler.Conversation
	case "group":
		value := new(PreconditionGroup)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		p.Group = value
	}
	return nil
}

func (p Precondition) MarshalJSON() ([]byte, error) {
	if err := p.validate(); err != nil {
		return nil, err
	}
	if p.User != nil {
		return internal.MarshalJSONWithExtraProperty(p.User, "preconditionType", "user")
	}
	if p.Conversation != nil {
		var marshaler = struct {
			PreconditionType string                    `json:"preconditionType"`
			Conversation     *ConversationPrecondition `json:"value"`
		}{
			PreconditionType: "conversation",
			Conversation:     p.Conversation,
		}
		return json.Marshal(marshaler)
	}
	if p.Group != nil {
		return internal.MarshalJSONWithExtraProperty(p.Group, "preconditionType", "group")
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", p)
}

type PreconditionVisitor interface {
	VisitUser(*MetadataPrecondition) error
	VisitConversation(*ConversationPrecondition) error
	VisitGroup(*PreconditionGroup) error
}

func (p *Precondition) Accept(visitor PreconditionVisitor) error {
	if p.User != nil {
		return visitor.VisitUser(p.User)
	}
	if p.Conversation != nil {
		return visitor.VisitConversation(p.Conversation)
	}
	if p.Group != nil {
		return visitor.VisitGroup(p.Group)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", p)
}

func (p *Precondition) validate() error {
	if p == nil {
		return fmt.Errorf("type %T is nil", p)
	}
	var fields []string
	if p.User != nil {
		fields = append(fields, "user")
	}
	if p.Conversation != nil {
		fields = append(fields, "conversation")
	}
	if p.Group != nil {
		fields = append(fields, "group")
	}
	if len(fields) == 0 {
		if p.PreconditionType != "" {
			return fmt.Errorf("type %T defines a discriminant set to %q but the field is not set", p, p.PreconditionType)
		}
		return fmt.Errorf("type %T is empty", p)
	}
	if len(fields) > 1 {
		return fmt.Errorf("type %T defines values for %s, but only one value is allowed", p, fields)
	}
	if p.PreconditionType != "" {
		field := fields[0]
		if p.PreconditionType != field {
			return fmt.Errorf(
				"type %T defines a discriminant set to %q, but it does not match the %T field; either remove or update the discriminant to match",
				p,
				p.PreconditionType,
				p,
			)
		}
	}
	return nil
}

var (
	preconditionBaseFieldOperator = big.NewInt(1 << 0)
)

type PreconditionBase struct {
	// Operator to apply to this precondition
	Operator *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PreconditionBase) GetOperator() *PreconditionOperator {
	if p == nil {
		return nil
	}
	return p.Operator
}

func (p *PreconditionBase) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PreconditionBase) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PreconditionBase) SetOperator(operator *PreconditionOperator) {
	p.Operator = operator
	p.require(preconditionBaseFieldOperator)
}

func (p *PreconditionBase) UnmarshalJSON(data []byte) error {
	type unmarshaler PreconditionBase
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PreconditionBase(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PreconditionBase) MarshalJSON() ([]byte, error) {
	type embed PreconditionBase
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PreconditionBase) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

var (
	preconditionGroupFieldOperator      = big.NewInt(1 << 0)
	preconditionGroupFieldPreconditions = big.NewInt(1 << 1)
)

type PreconditionGroup struct {
	Operator      PreconditionGroupOperator `json:"operator" url:"operator"`
	Preconditions []*Precondition           `json:"preconditions" url:"preconditions"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *PreconditionGroup) GetOperator() PreconditionGroupOperator {
	if p == nil {
		return ""
	}
	return p.Operator
}

func (p *PreconditionGroup) GetPreconditions() []*Precondition {
	if p == nil {
		return nil
	}
	return p.Preconditions
}

func (p *PreconditionGroup) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *PreconditionGroup) require(field *big.Int) {
	if p.explicitFields == nil {
		p.explicitFields = big.NewInt(0)
	}
	p.explicitFields.Or(p.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PreconditionGroup) SetOperator(operator PreconditionGroupOperator) {
	p.Operator = operator
	p.require(preconditionGroupFieldOperator)
}

// SetPreconditions sets the Preconditions field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (p *PreconditionGroup) SetPreconditions(preconditions []*Precondition) {
	p.Preconditions = preconditions
	p.require(preconditionGroupFieldPreconditions)
}

func (p *PreconditionGroup) UnmarshalJSON(data []byte) error {
	type unmarshaler PreconditionGroup
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = PreconditionGroup(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *PreconditionGroup) MarshalJSON() ([]byte, error) {
	type embed PreconditionGroup
	var marshaler = struct {
		embed
	}{
		embed: embed(*p),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, p.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (p *PreconditionGroup) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type PreconditionGroupOperator string

const (
	PreconditionGroupOperatorAnd PreconditionGroupOperator = "AND"
	PreconditionGroupOperatorOr  PreconditionGroupOperator = "OR"
)

func NewPreconditionGroupOperatorFromString(s string) (PreconditionGroupOperator, error) {
	switch s {
	case "AND":
		return PreconditionGroupOperatorAnd, nil
	case "OR":
		return PreconditionGroupOperatorOr, nil
	}
	var t PreconditionGroupOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PreconditionGroupOperator) Ptr() *PreconditionGroupOperator {
	return &p
}

type PreconditionOperator string

const (
	PreconditionOperatorNot PreconditionOperator = "NOT"
)

func NewPreconditionOperatorFromString(s string) (PreconditionOperator, error) {
	switch s {
	case "NOT":
		return PreconditionOperatorNot, nil
	}
	var t PreconditionOperator
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (p PreconditionOperator) Ptr() *PreconditionOperator {
	return &p
}

type Quality string

const (
	QualityGood             Quality = "GOOD"
	QualityNeedsImprovement Quality = "NEEDS_IMPROVEMENT"
	QualityUnknown          Quality = "UNKNOWN"
)

func NewQualityFromString(s string) (Quality, error) {
	switch s {
	case "GOOD":
		return QualityGood, nil
	case "NEEDS_IMPROVEMENT":
		return QualityNeedsImprovement, nil
	case "UNKNOWN":
		return QualityUnknown, nil
	}
	var t Quality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q Quality) Ptr() *Quality {
	return &q
}

type QualityReason string

const (
	QualityReasonMissingKnowledge        QualityReason = "MISSING_KNOWLEDGE"
	QualityReasonMissingUserInformation  QualityReason = "MISSING_USER_INFORMATION"
	QualityReasonMissingAction           QualityReason = "MISSING_ACTION"
	QualityReasonNeedsUserClarification  QualityReason = "NEEDS_USER_CLARIFICATION"
	QualityReasonUnsupportedFormat       QualityReason = "UNSUPPORTED_FORMAT"
	QualityReasonInterrupted             QualityReason = "INTERRUPTED"
	QualityReasonUnsupportedUserBehavior QualityReason = "UNSUPPORTED_USER_BEHAVIOR"
	QualityReasonUnknown                 QualityReason = "UNKNOWN"
	QualityReasonNoBotReplies            QualityReason = "NO_BOT_REPLIES"
)

func NewQualityReasonFromString(s string) (QualityReason, error) {
	switch s {
	case "MISSING_KNOWLEDGE":
		return QualityReasonMissingKnowledge, nil
	case "MISSING_USER_INFORMATION":
		return QualityReasonMissingUserInformation, nil
	case "MISSING_ACTION":
		return QualityReasonMissingAction, nil
	case "NEEDS_USER_CLARIFICATION":
		return QualityReasonNeedsUserClarification, nil
	case "UNSUPPORTED_FORMAT":
		return QualityReasonUnsupportedFormat, nil
	case "INTERRUPTED":
		return QualityReasonInterrupted, nil
	case "UNSUPPORTED_USER_BEHAVIOR":
		return QualityReasonUnsupportedUserBehavior, nil
	case "UNKNOWN":
		return QualityReasonUnknown, nil
	case "NO_BOT_REPLIES":
		return QualityReasonNoBotReplies, nil
	}
	var t QualityReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (q QualityReason) Ptr() *QualityReason {
	return &q
}

var (
	responseConfigFieldCapabilities   = big.NewInt(1 << 0)
	responseConfigFieldIsCopilot      = big.NewInt(1 << 1)
	responseConfigFieldResponseLength = big.NewInt(1 << 2)
)

type ResponseConfig struct {
	// List of capabilities supported by the caller. Defaults to `[MARKDOWN, FORMS, IMAGES]`.
	//
	// - `MARKDOWN`: Whether the response should include markdown formatting. If not provided, the response will be plain text. Not respected while streaming.
	// - `FORMS`: Whether the response should include forms. If provided, the caller needs to render action forms when returned from the ask API and allow submission of the forms with the submitActionForm API. If not provided, then actions which require user interaction will not be considered by the LLM. Removing this capability is recommended for surfaces which can not display UI (e.g. SMS, voice).
	// - `IMAGES`: Whether the response should include images. Not yet supported.
	// - `CHARTS_HIGHCHARTS_TS`: Whether the response should include a Highcharts typescript chart if applicable.
	// - `ASYNC`: Whether the app that created this conversation supports asynchronous message delivery. If provided, messages may be sent to the app via the `handleMessage` function.
	// - `OAUTH_BUTTONS`: Whether the response should include OAuth buttons. If provided, the caller needs to render OAuth buttons when returned from the ask API and allow the user to click the buttons to initiate the OAuth flow. If not provided, then actions which require OAuth authorization will not be considered by the LLM. This capability is not recommended for surfaces which can not display links (e.g. voice).
	Capabilities []Capability `json:"capabilities" url:"capabilities"`
	// Whether the response is for an human agent (true) or an end user (false). Defaults to false.
	IsCopilot bool `json:"isCopilot" url:"isCopilot"`
	// The desired response length. Defaults to ResponseLength.MEDIUM.
	ResponseLength ResponseLength `json:"responseLength" url:"responseLength"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseConfig) GetCapabilities() []Capability {
	if r == nil {
		return nil
	}
	return r.Capabilities
}

func (r *ResponseConfig) GetIsCopilot() bool {
	if r == nil {
		return false
	}
	return r.IsCopilot
}

func (r *ResponseConfig) GetResponseLength() ResponseLength {
	if r == nil {
		return ""
	}
	return r.ResponseLength
}

func (r *ResponseConfig) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseConfig) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetCapabilities sets the Capabilities field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfig) SetCapabilities(capabilities []Capability) {
	r.Capabilities = capabilities
	r.require(responseConfigFieldCapabilities)
}

// SetIsCopilot sets the IsCopilot field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfig) SetIsCopilot(isCopilot bool) {
	r.IsCopilot = isCopilot
	r.require(responseConfigFieldIsCopilot)
}

// SetResponseLength sets the ResponseLength field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfig) SetResponseLength(responseLength ResponseLength) {
	r.ResponseLength = responseLength
	r.require(responseConfigFieldResponseLength)
}

func (r *ResponseConfig) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseConfig
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseConfig(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseConfig) MarshalJSON() ([]byte, error) {
	type embed ResponseConfig
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseConfig) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

var (
	responseConfigPreconditionFieldOperator       = big.NewInt(1 << 0)
	responseConfigPreconditionFieldUseMarkdown    = big.NewInt(1 << 1)
	responseConfigPreconditionFieldUseForms       = big.NewInt(1 << 2)
	responseConfigPreconditionFieldUseImages      = big.NewInt(1 << 3)
	responseConfigPreconditionFieldIsCopilot      = big.NewInt(1 << 4)
	responseConfigPreconditionFieldResponseLength = big.NewInt(1 << 5)
)

type ResponseConfigPrecondition struct {
	// Operator to apply to this precondition
	Operator       *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`
	UseMarkdown    *bool                 `json:"useMarkdown,omitempty" url:"useMarkdown,omitempty"`
	UseForms       *bool                 `json:"useForms,omitempty" url:"useForms,omitempty"`
	UseImages      *bool                 `json:"useImages,omitempty" url:"useImages,omitempty"`
	IsCopilot      *bool                 `json:"isCopilot,omitempty" url:"isCopilot,omitempty"`
	ResponseLength *ResponseLength       `json:"responseLength,omitempty" url:"responseLength,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (r *ResponseConfigPrecondition) GetOperator() *PreconditionOperator {
	if r == nil {
		return nil
	}
	return r.Operator
}

func (r *ResponseConfigPrecondition) GetUseMarkdown() *bool {
	if r == nil {
		return nil
	}
	return r.UseMarkdown
}

func (r *ResponseConfigPrecondition) GetUseForms() *bool {
	if r == nil {
		return nil
	}
	return r.UseForms
}

func (r *ResponseConfigPrecondition) GetUseImages() *bool {
	if r == nil {
		return nil
	}
	return r.UseImages
}

func (r *ResponseConfigPrecondition) GetIsCopilot() *bool {
	if r == nil {
		return nil
	}
	return r.IsCopilot
}

func (r *ResponseConfigPrecondition) GetResponseLength() *ResponseLength {
	if r == nil {
		return nil
	}
	return r.ResponseLength
}

func (r *ResponseConfigPrecondition) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *ResponseConfigPrecondition) require(field *big.Int) {
	if r.explicitFields == nil {
		r.explicitFields = big.NewInt(0)
	}
	r.explicitFields.Or(r.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetOperator(operator *PreconditionOperator) {
	r.Operator = operator
	r.require(responseConfigPreconditionFieldOperator)
}

// SetUseMarkdown sets the UseMarkdown field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetUseMarkdown(useMarkdown *bool) {
	r.UseMarkdown = useMarkdown
	r.require(responseConfigPreconditionFieldUseMarkdown)
}

// SetUseForms sets the UseForms field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetUseForms(useForms *bool) {
	r.UseForms = useForms
	r.require(responseConfigPreconditionFieldUseForms)
}

// SetUseImages sets the UseImages field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetUseImages(useImages *bool) {
	r.UseImages = useImages
	r.require(responseConfigPreconditionFieldUseImages)
}

// SetIsCopilot sets the IsCopilot field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetIsCopilot(isCopilot *bool) {
	r.IsCopilot = isCopilot
	r.require(responseConfigPreconditionFieldIsCopilot)
}

// SetResponseLength sets the ResponseLength field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (r *ResponseConfigPrecondition) SetResponseLength(responseLength *ResponseLength) {
	r.ResponseLength = responseLength
	r.require(responseConfigPreconditionFieldResponseLength)
}

func (r *ResponseConfigPrecondition) UnmarshalJSON(data []byte) error {
	type unmarshaler ResponseConfigPrecondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = ResponseConfigPrecondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties
	r.rawJSON = json.RawMessage(data)
	return nil
}

func (r *ResponseConfigPrecondition) MarshalJSON() ([]byte, error) {
	type embed ResponseConfigPrecondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*r),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, r.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (r *ResponseConfigPrecondition) String() string {
	if len(r.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(r.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type ResponseLength string

const (
	ResponseLengthShort  ResponseLength = "SHORT"
	ResponseLengthMedium ResponseLength = "MEDIUM"
	ResponseLengthLong   ResponseLength = "LONG"
)

func NewResponseLengthFromString(s string) (ResponseLength, error) {
	switch s {
	case "SHORT":
		return ResponseLengthShort, nil
	case "MEDIUM":
		return ResponseLengthMedium, nil
	case "LONG":
		return ResponseLengthLong, nil
	}
	var t ResponseLength
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r ResponseLength) Ptr() *ResponseLength {
	return &r
}

var (
	scopedEntityFieldEntityId      = big.NewInt(1 << 0)
	scopedEntityFieldScopeEntityId = big.NewInt(1 << 1)
)

type ScopedEntity struct {
	EntityId      *EntityId `json:"entityId" url:"entityId"`
	ScopeEntityId *EntityId `json:"scopeEntityId,omitempty" url:"scopeEntityId,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *ScopedEntity) GetEntityId() *EntityId {
	if s == nil {
		return nil
	}
	return s.EntityId
}

func (s *ScopedEntity) GetScopeEntityId() *EntityId {
	if s == nil {
		return nil
	}
	return s.ScopeEntityId
}

func (s *ScopedEntity) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *ScopedEntity) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetEntityId sets the EntityId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScopedEntity) SetEntityId(entityId *EntityId) {
	s.EntityId = entityId
	s.require(scopedEntityFieldEntityId)
}

// SetScopeEntityId sets the ScopeEntityId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *ScopedEntity) SetScopeEntityId(scopeEntityId *EntityId) {
	s.ScopeEntityId = scopeEntityId
	s.require(scopedEntityFieldScopeEntityId)
}

func (s *ScopedEntity) UnmarshalJSON(data []byte) error {
	type unmarshaler ScopedEntity
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = ScopedEntity(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *ScopedEntity) MarshalJSON() ([]byte, error) {
	type embed ScopedEntity
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *ScopedEntity) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// The sentiment of the conversation
type Sentiment string

const (
	SentimentPositive Sentiment = "POSITIVE"
	SentimentNegative Sentiment = "NEGATIVE"
	SentimentNeutral  Sentiment = "NEUTRAL"
	SentimentMixed    Sentiment = "MIXED"
	SentimentUnknown  Sentiment = "UNKNOWN"
)

func NewSentimentFromString(s string) (Sentiment, error) {
	switch s {
	case "POSITIVE":
		return SentimentPositive, nil
	case "NEGATIVE":
		return SentimentNegative, nil
	case "NEUTRAL":
		return SentimentNeutral, nil
	case "MIXED":
		return SentimentMixed, nil
	case "UNKNOWN":
		return SentimentUnknown, nil
	}
	var t Sentiment
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s Sentiment) Ptr() *Sentiment {
	return &s
}

var (
	sessionInfoFieldId       = big.NewInt(1 << 0)
	sessionInfoFieldStart    = big.NewInt(1 << 1)
	sessionInfoFieldEnd      = big.NewInt(1 << 2)
	sessionInfoFieldDuration = big.NewInt(1 << 3)
)

type SessionInfo struct {
	Id       string     `json:"id" url:"id"`
	Start    *time.Time `json:"start,omitempty" url:"start,omitempty"`
	End      *time.Time `json:"end,omitempty" url:"end,omitempty"`
	Duration *int64     `json:"duration,omitempty" url:"duration,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SessionInfo) GetId() string {
	if s == nil {
		return ""
	}
	return s.Id
}

func (s *SessionInfo) GetStart() *time.Time {
	if s == nil {
		return nil
	}
	return s.Start
}

func (s *SessionInfo) GetEnd() *time.Time {
	if s == nil {
		return nil
	}
	return s.End
}

func (s *SessionInfo) GetDuration() *int64 {
	if s == nil {
		return nil
	}
	return s.Duration
}

func (s *SessionInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SessionInfo) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SessionInfo) SetId(id string) {
	s.Id = id
	s.require(sessionInfoFieldId)
}

// SetStart sets the Start field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SessionInfo) SetStart(start *time.Time) {
	s.Start = start
	s.require(sessionInfoFieldStart)
}

// SetEnd sets the End field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SessionInfo) SetEnd(end *time.Time) {
	s.End = end
	s.require(sessionInfoFieldEnd)
}

// SetDuration sets the Duration field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SessionInfo) SetDuration(duration *int64) {
	s.Duration = duration
	s.require(sessionInfoFieldDuration)
}

func (s *SessionInfo) UnmarshalJSON(data []byte) error {
	type embed SessionInfo
	var unmarshaler = struct {
		embed
		Start *internal.DateTime `json:"start,omitempty"`
		End   *internal.DateTime `json:"end,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SessionInfo(unmarshaler.embed)
	s.Start = unmarshaler.Start.TimePtr()
	s.End = unmarshaler.End.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SessionInfo) MarshalJSON() ([]byte, error) {
	type embed SessionInfo
	var marshaler = struct {
		embed
		Start *internal.DateTime `json:"start,omitempty"`
		End   *internal.DateTime `json:"end,omitempty"`
	}{
		embed: embed(*s),
		Start: internal.NewOptionalDateTime(s.Start),
		End:   internal.NewOptionalDateTime(s.End),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SessionInfo) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	simulationContextFieldAdditionalPromptText    = big.NewInt(1 << 0)
	simulationContextFieldPersona                 = big.NewInt(1 << 1)
	simulationContextFieldAvailableKnowledgeBases = big.NewInt(1 << 2)
)

type SimulationContext struct {
	// If provided, overrides the agent's default additional prompt text during the simulation.
	// Note that this field is provided for backwards compatibility and will be removed in a future release.
	// Instead please use the `availableKnowledgeBases` field to include a knowledge base with a document `llmInclusionStatus` set to `ALWAYS`.
	AdditionalPromptText *string `json:"additionalPromptText,omitempty" url:"additionalPromptText,omitempty"`
	// The persona to use during the simulation. If not provided, the agent's default persona will be used.
	Persona *LlmPersona `json:"persona,omitempty" url:"persona,omitempty"`
	// If provided, knowledge search will be restricted to the provided list of knowledge bases. Otherwise, all active knowledge bases will be used. An empty list means no knowledge bases will be used.
	AvailableKnowledgeBases []*EntityId `json:"availableKnowledgeBases,omitempty" url:"availableKnowledgeBases,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SimulationContext) GetAdditionalPromptText() *string {
	if s == nil {
		return nil
	}
	return s.AdditionalPromptText
}

func (s *SimulationContext) GetPersona() *LlmPersona {
	if s == nil {
		return nil
	}
	return s.Persona
}

func (s *SimulationContext) GetAvailableKnowledgeBases() []*EntityId {
	if s == nil {
		return nil
	}
	return s.AvailableKnowledgeBases
}

func (s *SimulationContext) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SimulationContext) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetAdditionalPromptText sets the AdditionalPromptText field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SimulationContext) SetAdditionalPromptText(additionalPromptText *string) {
	s.AdditionalPromptText = additionalPromptText
	s.require(simulationContextFieldAdditionalPromptText)
}

// SetPersona sets the Persona field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SimulationContext) SetPersona(persona *LlmPersona) {
	s.Persona = persona
	s.require(simulationContextFieldPersona)
}

// SetAvailableKnowledgeBases sets the AvailableKnowledgeBases field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SimulationContext) SetAvailableKnowledgeBases(availableKnowledgeBases []*EntityId) {
	s.AvailableKnowledgeBases = availableKnowledgeBases
	s.require(simulationContextFieldAvailableKnowledgeBases)
}

func (s *SimulationContext) UnmarshalJSON(data []byte) error {
	type unmarshaler SimulationContext
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SimulationContext(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SimulationContext) MarshalJSON() ([]byte, error) {
	type embed SimulationContext
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SimulationContext) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	sourceFieldTitle = big.NewInt(1 << 0)
	sourceFieldUrl   = big.NewInt(1 << 1)
)

type Source struct {
	Title string `json:"title" url:"title"`
	Url   string `json:"url" url:"url"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Source) GetTitle() string {
	if s == nil {
		return ""
	}
	return s.Title
}

func (s *Source) GetUrl() string {
	if s == nil {
		return ""
	}
	return s.Url
}

func (s *Source) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Source) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetTitle sets the Title field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Source) SetTitle(title string) {
	s.Title = title
	s.require(sourceFieldTitle)
}

// SetUrl sets the Url field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *Source) SetUrl(url string) {
	s.Url = url
	s.require(sourceFieldUrl)
}

func (s *Source) UnmarshalJSON(data []byte) error {
	type unmarshaler Source
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = Source(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Source) MarshalJSON() ([]byte, error) {
	type embed Source
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *Source) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	sourceInfoFieldType         = big.NewInt(1 << 0)
	sourceInfoFieldDeviceInfo   = big.NewInt(1 << 1)
	sourceInfoFieldBrowserInfo  = big.NewInt(1 << 2)
	sourceInfoFieldGeoInfo      = big.NewInt(1 << 3)
	sourceInfoFieldIpInfo       = big.NewInt(1 << 4)
	sourceInfoFieldLanguageInfo = big.NewInt(1 << 5)
)

type SourceInfo struct {
	Type         SourceType    `json:"type" url:"type"`
	DeviceInfo   *DeviceInfo   `json:"deviceInfo,omitempty" url:"deviceInfo,omitempty"`
	BrowserInfo  *BrowserInfo  `json:"browserInfo,omitempty" url:"browserInfo,omitempty"`
	GeoInfo      *GeoInfo      `json:"geoInfo,omitempty" url:"geoInfo,omitempty"`
	IpInfo       *IpInfo       `json:"ipInfo,omitempty" url:"ipInfo,omitempty"`
	LanguageInfo *LanguageInfo `json:"languageInfo,omitempty" url:"languageInfo,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SourceInfo) GetType() SourceType {
	if s == nil {
		return ""
	}
	return s.Type
}

func (s *SourceInfo) GetDeviceInfo() *DeviceInfo {
	if s == nil {
		return nil
	}
	return s.DeviceInfo
}

func (s *SourceInfo) GetBrowserInfo() *BrowserInfo {
	if s == nil {
		return nil
	}
	return s.BrowserInfo
}

func (s *SourceInfo) GetGeoInfo() *GeoInfo {
	if s == nil {
		return nil
	}
	return s.GeoInfo
}

func (s *SourceInfo) GetIpInfo() *IpInfo {
	if s == nil {
		return nil
	}
	return s.IpInfo
}

func (s *SourceInfo) GetLanguageInfo() *LanguageInfo {
	if s == nil {
		return nil
	}
	return s.LanguageInfo
}

func (s *SourceInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SourceInfo) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetType sets the Type field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetType(type_ SourceType) {
	s.Type = type_
	s.require(sourceInfoFieldType)
}

// SetDeviceInfo sets the DeviceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetDeviceInfo(deviceInfo *DeviceInfo) {
	s.DeviceInfo = deviceInfo
	s.require(sourceInfoFieldDeviceInfo)
}

// SetBrowserInfo sets the BrowserInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetBrowserInfo(browserInfo *BrowserInfo) {
	s.BrowserInfo = browserInfo
	s.require(sourceInfoFieldBrowserInfo)
}

// SetGeoInfo sets the GeoInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetGeoInfo(geoInfo *GeoInfo) {
	s.GeoInfo = geoInfo
	s.require(sourceInfoFieldGeoInfo)
}

// SetIpInfo sets the IpInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetIpInfo(ipInfo *IpInfo) {
	s.IpInfo = ipInfo
	s.require(sourceInfoFieldIpInfo)
}

// SetLanguageInfo sets the LanguageInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SourceInfo) SetLanguageInfo(languageInfo *LanguageInfo) {
	s.LanguageInfo = languageInfo
	s.require(sourceInfoFieldLanguageInfo)
}

func (s *SourceInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SourceInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SourceInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SourceInfo) MarshalJSON() ([]byte, error) {
	type embed SourceInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SourceInfo) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SourceType string

const (
	SourceTypeWeb    SourceType = "WEB"
	SourceTypeApi    SourceType = "API"
	SourceTypeSystem SourceType = "SYSTEM"
)

func NewSourceTypeFromString(s string) (SourceType, error) {
	switch s {
	case "WEB":
		return SourceTypeWeb, nil
	case "API":
		return SourceTypeApi, nil
	case "SYSTEM":
		return SourceTypeSystem, nil
	}
	var t SourceType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceType) Ptr() *SourceType {
	return &s
}

var (
	surveyInfoFieldSurveyQuestion = big.NewInt(1 << 0)
	surveyInfoFieldSurveyAnswer   = big.NewInt(1 << 1)
)

type SurveyInfo struct {
	SurveyQuestion *string `json:"surveyQuestion,omitempty" url:"surveyQuestion,omitempty"`
	SurveyAnswer   *string `json:"surveyAnswer,omitempty" url:"surveyAnswer,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SurveyInfo) GetSurveyQuestion() *string {
	if s == nil {
		return nil
	}
	return s.SurveyQuestion
}

func (s *SurveyInfo) GetSurveyAnswer() *string {
	if s == nil {
		return nil
	}
	return s.SurveyAnswer
}

func (s *SurveyInfo) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SurveyInfo) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetSurveyQuestion sets the SurveyQuestion field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SurveyInfo) SetSurveyQuestion(surveyQuestion *string) {
	s.SurveyQuestion = surveyQuestion
	s.require(surveyInfoFieldSurveyQuestion)
}

// SetSurveyAnswer sets the SurveyAnswer field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SurveyInfo) SetSurveyAnswer(surveyAnswer *string) {
	s.SurveyAnswer = surveyAnswer
	s.require(surveyInfoFieldSurveyAnswer)
}

func (s *SurveyInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler SurveyInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SurveyInfo(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SurveyInfo) MarshalJSON() ([]byte, error) {
	type embed SurveyInfo
	var marshaler = struct {
		embed
	}{
		embed: embed(*s),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SurveyInfo) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

var (
	systemEventFieldTimestamp   = big.NewInt(1 << 0)
	systemEventFieldReferences  = big.NewInt(1 << 1)
	systemEventFieldSourceInfo  = big.NewInt(1 << 2)
	systemEventFieldSessionInfo = big.NewInt(1 << 3)
	systemEventFieldContextInfo = big.NewInt(1 << 4)
	systemEventFieldEventName   = big.NewInt(1 << 5)
	systemEventFieldId          = big.NewInt(1 << 6)
)

type SystemEvent struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`
	// The name of the event
	EventName SystemEventName `json:"eventName" url:"eventName"`
	// The unique ID of the event
	Id *EntityId `json:"id" url:"id"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *SystemEvent) GetTimestamp() *time.Time {
	if s == nil {
		return nil
	}
	return s.Timestamp
}

func (s *SystemEvent) GetReferences() []*ScopedEntity {
	if s == nil {
		return nil
	}
	return s.References
}

func (s *SystemEvent) GetSourceInfo() *SourceInfo {
	if s == nil {
		return nil
	}
	return s.SourceInfo
}

func (s *SystemEvent) GetSessionInfo() *SessionInfo {
	if s == nil {
		return nil
	}
	return s.SessionInfo
}

func (s *SystemEvent) GetContextInfo() *ContextInfo {
	if s == nil {
		return nil
	}
	return s.ContextInfo
}

func (s *SystemEvent) GetEventName() SystemEventName {
	if s == nil {
		return ""
	}
	return s.EventName
}

func (s *SystemEvent) GetId() *EntityId {
	if s == nil {
		return nil
	}
	return s.Id
}

func (s *SystemEvent) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *SystemEvent) require(field *big.Int) {
	if s.explicitFields == nil {
		s.explicitFields = big.NewInt(0)
	}
	s.explicitFields.Or(s.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetTimestamp(timestamp *time.Time) {
	s.Timestamp = timestamp
	s.require(systemEventFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetReferences(references []*ScopedEntity) {
	s.References = references
	s.require(systemEventFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetSourceInfo(sourceInfo *SourceInfo) {
	s.SourceInfo = sourceInfo
	s.require(systemEventFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetSessionInfo(sessionInfo *SessionInfo) {
	s.SessionInfo = sessionInfo
	s.require(systemEventFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetContextInfo(contextInfo *ContextInfo) {
	s.ContextInfo = contextInfo
	s.require(systemEventFieldContextInfo)
}

// SetEventName sets the EventName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetEventName(eventName SystemEventName) {
	s.EventName = eventName
	s.require(systemEventFieldEventName)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (s *SystemEvent) SetId(id *EntityId) {
	s.Id = id
	s.require(systemEventFieldId)
}

func (s *SystemEvent) UnmarshalJSON(data []byte) error {
	type embed SystemEvent
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = SystemEvent(unmarshaler.embed)
	s.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *SystemEvent) MarshalJSON() ([]byte, error) {
	type embed SystemEvent
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*s),
		Timestamp: internal.NewOptionalDateTime(s.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, s.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (s *SystemEvent) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SystemEventName string

const (
	// An app was installed
	SystemEventNameAppInstalled SystemEventName = "APP_INSTALLED"
	// An app was uninstalled
	SystemEventNameAppUninstalled SystemEventName = "APP_UNINSTALLED"
	// An app was updated
	SystemEventNameAppUpdated SystemEventName = "APP_UPDATED"
)

func NewSystemEventNameFromString(s string) (SystemEventName, error) {
	switch s {
	case "APP_INSTALLED":
		return SystemEventNameAppInstalled, nil
	case "APP_UNINSTALLED":
		return SystemEventNameAppUninstalled, nil
	case "APP_UPDATED":
		return SystemEventNameAppUpdated, nil
	}
	var t SystemEventName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SystemEventName) Ptr() *SystemEventName {
	return &s
}

var (
	tagsPreconditionFieldOperator = big.NewInt(1 << 0)
	tagsPreconditionFieldTags     = big.NewInt(1 << 1)
)

type TagsPrecondition struct {
	// Operator to apply to this precondition
	Operator *PreconditionOperator `json:"operator,omitempty" url:"operator,omitempty"`
	// The tags that must be present in the conversation context for the precondition to be met
	Tags []string `json:"tags" url:"tags"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (t *TagsPrecondition) GetOperator() *PreconditionOperator {
	if t == nil {
		return nil
	}
	return t.Operator
}

func (t *TagsPrecondition) GetTags() []string {
	if t == nil {
		return nil
	}
	return t.Tags
}

func (t *TagsPrecondition) GetExtraProperties() map[string]interface{} {
	return t.extraProperties
}

func (t *TagsPrecondition) require(field *big.Int) {
	if t.explicitFields == nil {
		t.explicitFields = big.NewInt(0)
	}
	t.explicitFields.Or(t.explicitFields, field)
}

// SetOperator sets the Operator field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TagsPrecondition) SetOperator(operator *PreconditionOperator) {
	t.Operator = operator
	t.require(tagsPreconditionFieldOperator)
}

// SetTags sets the Tags field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (t *TagsPrecondition) SetTags(tags []string) {
	t.Tags = tags
	t.require(tagsPreconditionFieldTags)
}

func (t *TagsPrecondition) UnmarshalJSON(data []byte) error {
	type unmarshaler TagsPrecondition
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TagsPrecondition(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *t)
	if err != nil {
		return err
	}
	t.extraProperties = extraProperties
	t.rawJSON = json.RawMessage(data)
	return nil
}

func (t *TagsPrecondition) MarshalJSON() ([]byte, error) {
	type embed TagsPrecondition
	var marshaler = struct {
		embed
	}{
		embed: embed(*t),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, t.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (t *TagsPrecondition) String() string {
	if len(t.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(t.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// The type of user message
type UserConversationMessageType string

const (
	UserConversationMessageTypeUser           UserConversationMessageType = "USER"
	UserConversationMessageTypeHumanAgent     UserConversationMessageType = "HUMAN_AGENT"
	UserConversationMessageTypeExternalSystem UserConversationMessageType = "EXTERNAL_SYSTEM"
)

func NewUserConversationMessageTypeFromString(s string) (UserConversationMessageType, error) {
	switch s {
	case "USER":
		return UserConversationMessageTypeUser, nil
	case "HUMAN_AGENT":
		return UserConversationMessageTypeHumanAgent, nil
	case "EXTERNAL_SYSTEM":
		return UserConversationMessageTypeExternalSystem, nil
	}
	var t UserConversationMessageType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UserConversationMessageType) Ptr() *UserConversationMessageType {
	return &u
}

var (
	userDataFieldValue      = big.NewInt(1 << 0)
	userDataFieldVisibility = big.NewInt(1 << 1)
)

type UserData struct {
	// The value of the user metadata
	Value string `json:"value" url:"value"`
	// The visibility of the user metadata
	Visibility VisibilityType `json:"visibility" url:"visibility"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserData) GetValue() string {
	if u == nil {
		return ""
	}
	return u.Value
}

func (u *UserData) GetVisibility() VisibilityType {
	if u == nil {
		return ""
	}
	return u.Visibility
}

func (u *UserData) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserData) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserData) SetValue(value string) {
	u.Value = value
	u.require(userDataFieldValue)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserData) SetVisibility(visibility VisibilityType) {
	u.Visibility = visibility
	u.require(userDataFieldVisibility)
}

func (u *UserData) UnmarshalJSON(data []byte) error {
	type unmarshaler UserData
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserData(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserData) MarshalJSON() ([]byte, error) {
	type embed UserData
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserData) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	userDataWithReferenceFieldValue      = big.NewInt(1 << 0)
	userDataWithReferenceFieldVisibility = big.NewInt(1 << 1)
	userDataWithReferenceFieldUserId     = big.NewInt(1 << 2)
)

type UserDataWithReference struct {
	// The value of the user metadata
	Value string `json:"value" url:"value"`
	// The visibility of the user metadata
	Visibility VisibilityType `json:"visibility" url:"visibility"`
	// Reverse index containing appId and referenceId data that identifies this app user
	UserId *EntityIdFilter `json:"userId" url:"userId"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserDataWithReference) GetValue() string {
	if u == nil {
		return ""
	}
	return u.Value
}

func (u *UserDataWithReference) GetVisibility() VisibilityType {
	if u == nil {
		return ""
	}
	return u.Visibility
}

func (u *UserDataWithReference) GetUserId() *EntityIdFilter {
	if u == nil {
		return nil
	}
	return u.UserId
}

func (u *UserDataWithReference) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserDataWithReference) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetValue sets the Value field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserDataWithReference) SetValue(value string) {
	u.Value = value
	u.require(userDataWithReferenceFieldValue)
}

// SetVisibility sets the Visibility field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserDataWithReference) SetVisibility(visibility VisibilityType) {
	u.Visibility = visibility
	u.require(userDataWithReferenceFieldVisibility)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserDataWithReference) SetUserId(userId *EntityIdFilter) {
	u.UserId = userId
	u.require(userDataWithReferenceFieldUserId)
}

func (u *UserDataWithReference) UnmarshalJSON(data []byte) error {
	type unmarshaler UserDataWithReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UserDataWithReference(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserDataWithReference) MarshalJSON() ([]byte, error) {
	type embed UserDataWithReference
	var marshaler = struct {
		embed
	}{
		embed: embed(*u),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserDataWithReference) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	userEventFieldTimestamp    = big.NewInt(1 << 0)
	userEventFieldReferences   = big.NewInt(1 << 1)
	userEventFieldSourceInfo   = big.NewInt(1 << 2)
	userEventFieldSessionInfo  = big.NewInt(1 << 3)
	userEventFieldContextInfo  = big.NewInt(1 << 4)
	userEventFieldId           = big.NewInt(1 << 5)
	userEventFieldEventName    = big.NewInt(1 << 6)
	userEventFieldUserInfo     = big.NewInt(1 << 7)
	userEventFieldFeedbackInfo = big.NewInt(1 << 8)
	userEventFieldPageInfo     = big.NewInt(1 << 9)
)

type UserEvent struct {
	Timestamp   *time.Time      `json:"timestamp,omitempty" url:"timestamp,omitempty"`
	References  []*ScopedEntity `json:"references,omitempty" url:"references,omitempty"`
	SourceInfo  *SourceInfo     `json:"sourceInfo,omitempty" url:"sourceInfo,omitempty"`
	SessionInfo *SessionInfo    `json:"sessionInfo,omitempty" url:"sessionInfo,omitempty"`
	ContextInfo *ContextInfo    `json:"contextInfo,omitempty" url:"contextInfo,omitempty"`
	// The unique ID of the event
	Id *EntityId `json:"id" url:"id"`
	// The name of the event
	EventName UserEventName `json:"eventName" url:"eventName"`
	// Information about the user who triggered the event
	UserInfo *EventUserInfo `json:"userInfo" url:"userInfo"`
	// Information about any feedback associated with the event
	FeedbackInfo []*FeedbackInfo `json:"feedbackInfo,omitempty" url:"feedbackInfo,omitempty"`
	// Information about the page on which the event occurred
	PageInfo *PageInfo `json:"pageInfo,omitempty" url:"pageInfo,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserEvent) GetTimestamp() *time.Time {
	if u == nil {
		return nil
	}
	return u.Timestamp
}

func (u *UserEvent) GetReferences() []*ScopedEntity {
	if u == nil {
		return nil
	}
	return u.References
}

func (u *UserEvent) GetSourceInfo() *SourceInfo {
	if u == nil {
		return nil
	}
	return u.SourceInfo
}

func (u *UserEvent) GetSessionInfo() *SessionInfo {
	if u == nil {
		return nil
	}
	return u.SessionInfo
}

func (u *UserEvent) GetContextInfo() *ContextInfo {
	if u == nil {
		return nil
	}
	return u.ContextInfo
}

func (u *UserEvent) GetId() *EntityId {
	if u == nil {
		return nil
	}
	return u.Id
}

func (u *UserEvent) GetEventName() UserEventName {
	if u == nil {
		return ""
	}
	return u.EventName
}

func (u *UserEvent) GetUserInfo() *EventUserInfo {
	if u == nil {
		return nil
	}
	return u.UserInfo
}

func (u *UserEvent) GetFeedbackInfo() []*FeedbackInfo {
	if u == nil {
		return nil
	}
	return u.FeedbackInfo
}

func (u *UserEvent) GetPageInfo() *PageInfo {
	if u == nil {
		return nil
	}
	return u.PageInfo
}

func (u *UserEvent) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserEvent) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetTimestamp sets the Timestamp field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetTimestamp(timestamp *time.Time) {
	u.Timestamp = timestamp
	u.require(userEventFieldTimestamp)
}

// SetReferences sets the References field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetReferences(references []*ScopedEntity) {
	u.References = references
	u.require(userEventFieldReferences)
}

// SetSourceInfo sets the SourceInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetSourceInfo(sourceInfo *SourceInfo) {
	u.SourceInfo = sourceInfo
	u.require(userEventFieldSourceInfo)
}

// SetSessionInfo sets the SessionInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetSessionInfo(sessionInfo *SessionInfo) {
	u.SessionInfo = sessionInfo
	u.require(userEventFieldSessionInfo)
}

// SetContextInfo sets the ContextInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetContextInfo(contextInfo *ContextInfo) {
	u.ContextInfo = contextInfo
	u.require(userEventFieldContextInfo)
}

// SetId sets the Id field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetId(id *EntityId) {
	u.Id = id
	u.require(userEventFieldId)
}

// SetEventName sets the EventName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetEventName(eventName UserEventName) {
	u.EventName = eventName
	u.require(userEventFieldEventName)
}

// SetUserInfo sets the UserInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetUserInfo(userInfo *EventUserInfo) {
	u.UserInfo = userInfo
	u.require(userEventFieldUserInfo)
}

// SetFeedbackInfo sets the FeedbackInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetFeedbackInfo(feedbackInfo []*FeedbackInfo) {
	u.FeedbackInfo = feedbackInfo
	u.require(userEventFieldFeedbackInfo)
}

// SetPageInfo sets the PageInfo field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserEvent) SetPageInfo(pageInfo *PageInfo) {
	u.PageInfo = pageInfo
	u.require(userEventFieldPageInfo)
}

func (u *UserEvent) UnmarshalJSON(data []byte) error {
	type embed UserEvent
	var unmarshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserEvent(unmarshaler.embed)
	u.Timestamp = unmarshaler.Timestamp.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserEvent) MarshalJSON() ([]byte, error) {
	type embed UserEvent
	var marshaler = struct {
		embed
		Timestamp *internal.DateTime `json:"timestamp,omitempty"`
	}{
		embed:     embed(*u),
		Timestamp: internal.NewOptionalDateTime(u.Timestamp),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserEvent) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserEventName string

const (
	// A button click occurred
	UserEventNameButtonClicked UserEventName = "BUTTON_CLICKED"
	// A link was clicked
	UserEventNameLinkClicked UserEventName = "LINK_CLICKED"
	// The chat window was opened
	UserEventNameChatOpened UserEventName = "CHAT_OPENED"
	// The chat window was closed
	UserEventNameChatClosed UserEventName = "CHAT_CLOSED"
	// A text was inserted into a field
	UserEventNameTextInserted UserEventName = "TEXT_INSERTED"
)

func NewUserEventNameFromString(s string) (UserEventName, error) {
	switch s {
	case "BUTTON_CLICKED":
		return UserEventNameButtonClicked, nil
	case "LINK_CLICKED":
		return UserEventNameLinkClicked, nil
	case "CHAT_OPENED":
		return UserEventNameChatOpened, nil
	case "CHAT_CLOSED":
		return UserEventNameChatClosed, nil
	case "TEXT_INSERTED":
		return UserEventNameTextInserted, nil
	}
	var t UserEventName
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UserEventName) Ptr() *UserEventName {
	return &u
}

var (
	userMessageFieldCreatedAt             = big.NewInt(1 << 0)
	userMessageFieldUpdatedAt             = big.NewInt(1 << 1)
	userMessageFieldUserId                = big.NewInt(1 << 2)
	userMessageFieldText                  = big.NewInt(1 << 3)
	userMessageFieldUserMessageType       = big.NewInt(1 << 4)
	userMessageFieldConversationMessageId = big.NewInt(1 << 5)
	userMessageFieldLanguage              = big.NewInt(1 << 6)
	userMessageFieldAttachments           = big.NewInt(1 << 7)
	userMessageFieldAgentUserId           = big.NewInt(1 << 8)
	userMessageFieldUserDisplayName       = big.NewInt(1 << 9)
	userMessageFieldStatus                = big.NewInt(1 << 10)
	userMessageFieldResponseState         = big.NewInt(1 << 11)
)

type UserMessage struct {
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// ID that uniquely identifies the user that created this message
	UserId *EntityIdBase `json:"userId" url:"userId"`
	// The text of the message. Cannot be empty
	Text            string                      `json:"text" url:"text"`
	UserMessageType UserConversationMessageType `json:"userMessageType" url:"userMessageType"`
	// The ID that uniquely identifies this message within the conversation
	ConversationMessageId *EntityId `json:"conversationMessageId" url:"conversationMessageId"`
	// The language of the message in ISO 639-1 code format
	Language *string `json:"language,omitempty" url:"language,omitempty"`
	// The attachments associated with the message
	Attachments []*AttachmentResponse `json:"attachments" url:"attachments"`
	// The ID of the agent user that created this message. More detail can be fetched via the agent user APIs. Will be empty only for legacy conversations.
	AgentUserId *string `json:"agentUserId,omitempty" url:"agentUserId,omitempty"`
	// The display name of the user who created this message. Only available for users who have saved name information.
	UserDisplayName *string `json:"userDisplayName,omitempty" url:"userDisplayName,omitempty"`
	// The delivery status of the message. Only applicable to messages sent via the deliverMessage API.
	// All other messages have an `UNKNOWN` status.
	//
	// * `SENT`: The message has been sent to the user.
	// * `FAILED`: The message sending encountered an error.
	// * `UNKNOWN`: The message status is unknown.
	Status MessageStatus `json:"status" url:"status"`
	// Only present on newer messaged where `userMessageType` is `USER`.
	// Indicates the state of the answer to the user message.
	//
	// - `NOT_ASKED`: An answer was not requested for this user message.
	// - `LLM_ENABLED`: An answer was requested for this user message and the LLM was enabled.
	// - `LLM_DISABLED`: An answer was requested for this user message and the LLM was disabled.
	ResponseState *UserMessageResponseState `json:"responseState,omitempty" url:"responseState,omitempty"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserMessage) GetCreatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.CreatedAt
}

func (u *UserMessage) GetUpdatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.UpdatedAt
}

func (u *UserMessage) GetUserId() *EntityIdBase {
	if u == nil {
		return nil
	}
	return u.UserId
}

func (u *UserMessage) GetText() string {
	if u == nil {
		return ""
	}
	return u.Text
}

func (u *UserMessage) GetUserMessageType() UserConversationMessageType {
	if u == nil {
		return ""
	}
	return u.UserMessageType
}

func (u *UserMessage) GetConversationMessageId() *EntityId {
	if u == nil {
		return nil
	}
	return u.ConversationMessageId
}

func (u *UserMessage) GetLanguage() *string {
	if u == nil {
		return nil
	}
	return u.Language
}

func (u *UserMessage) GetAttachments() []*AttachmentResponse {
	if u == nil {
		return nil
	}
	return u.Attachments
}

func (u *UserMessage) GetAgentUserId() *string {
	if u == nil {
		return nil
	}
	return u.AgentUserId
}

func (u *UserMessage) GetUserDisplayName() *string {
	if u == nil {
		return nil
	}
	return u.UserDisplayName
}

func (u *UserMessage) GetStatus() MessageStatus {
	if u == nil {
		return ""
	}
	return u.Status
}

func (u *UserMessage) GetResponseState() *UserMessageResponseState {
	if u == nil {
		return nil
	}
	return u.ResponseState
}

func (u *UserMessage) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserMessage) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetCreatedAt(createdAt *time.Time) {
	u.CreatedAt = createdAt
	u.require(userMessageFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetUpdatedAt(updatedAt *time.Time) {
	u.UpdatedAt = updatedAt
	u.require(userMessageFieldUpdatedAt)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetUserId(userId *EntityIdBase) {
	u.UserId = userId
	u.require(userMessageFieldUserId)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetText(text string) {
	u.Text = text
	u.require(userMessageFieldText)
}

// SetUserMessageType sets the UserMessageType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetUserMessageType(userMessageType UserConversationMessageType) {
	u.UserMessageType = userMessageType
	u.require(userMessageFieldUserMessageType)
}

// SetConversationMessageId sets the ConversationMessageId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetConversationMessageId(conversationMessageId *EntityId) {
	u.ConversationMessageId = conversationMessageId
	u.require(userMessageFieldConversationMessageId)
}

// SetLanguage sets the Language field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetLanguage(language *string) {
	u.Language = language
	u.require(userMessageFieldLanguage)
}

// SetAttachments sets the Attachments field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetAttachments(attachments []*AttachmentResponse) {
	u.Attachments = attachments
	u.require(userMessageFieldAttachments)
}

// SetAgentUserId sets the AgentUserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetAgentUserId(agentUserId *string) {
	u.AgentUserId = agentUserId
	u.require(userMessageFieldAgentUserId)
}

// SetUserDisplayName sets the UserDisplayName field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetUserDisplayName(userDisplayName *string) {
	u.UserDisplayName = userDisplayName
	u.require(userMessageFieldUserDisplayName)
}

// SetStatus sets the Status field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetStatus(status MessageStatus) {
	u.Status = status
	u.require(userMessageFieldStatus)
}

// SetResponseState sets the ResponseState field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessage) SetResponseState(responseState *UserMessageResponseState) {
	u.ResponseState = responseState
	u.require(userMessageFieldResponseState)
}

func (u *UserMessage) UnmarshalJSON(data []byte) error {
	type embed UserMessage
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserMessage(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	u.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserMessage) MarshalJSON() ([]byte, error) {
	type embed UserMessage
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*u),
		CreatedAt: internal.NewOptionalDateTime(u.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(u.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserMessage) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

var (
	userMessageBaseFieldCreatedAt       = big.NewInt(1 << 0)
	userMessageBaseFieldUpdatedAt       = big.NewInt(1 << 1)
	userMessageBaseFieldUserId          = big.NewInt(1 << 2)
	userMessageBaseFieldText            = big.NewInt(1 << 3)
	userMessageBaseFieldUserMessageType = big.NewInt(1 << 4)
)

type UserMessageBase struct {
	// The date and time the conversation was created
	CreatedAt *time.Time `json:"createdAt,omitempty" url:"createdAt,omitempty"`
	// The date and time the conversation was last updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty" url:"updatedAt,omitempty"`
	// ID that uniquely identifies the user that created this message
	UserId *EntityIdBase `json:"userId" url:"userId"`
	// The text of the message. Cannot be empty
	Text            string                      `json:"text" url:"text"`
	UserMessageType UserConversationMessageType `json:"userMessageType" url:"userMessageType"`

	// Private bitmask of fields set to an explicit value and therefore not to be omitted
	explicitFields *big.Int `json:"-" url:"-"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (u *UserMessageBase) GetCreatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.CreatedAt
}

func (u *UserMessageBase) GetUpdatedAt() *time.Time {
	if u == nil {
		return nil
	}
	return u.UpdatedAt
}

func (u *UserMessageBase) GetUserId() *EntityIdBase {
	if u == nil {
		return nil
	}
	return u.UserId
}

func (u *UserMessageBase) GetText() string {
	if u == nil {
		return ""
	}
	return u.Text
}

func (u *UserMessageBase) GetUserMessageType() UserConversationMessageType {
	if u == nil {
		return ""
	}
	return u.UserMessageType
}

func (u *UserMessageBase) GetExtraProperties() map[string]interface{} {
	return u.extraProperties
}

func (u *UserMessageBase) require(field *big.Int) {
	if u.explicitFields == nil {
		u.explicitFields = big.NewInt(0)
	}
	u.explicitFields.Or(u.explicitFields, field)
}

// SetCreatedAt sets the CreatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessageBase) SetCreatedAt(createdAt *time.Time) {
	u.CreatedAt = createdAt
	u.require(userMessageBaseFieldCreatedAt)
}

// SetUpdatedAt sets the UpdatedAt field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessageBase) SetUpdatedAt(updatedAt *time.Time) {
	u.UpdatedAt = updatedAt
	u.require(userMessageBaseFieldUpdatedAt)
}

// SetUserId sets the UserId field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessageBase) SetUserId(userId *EntityIdBase) {
	u.UserId = userId
	u.require(userMessageBaseFieldUserId)
}

// SetText sets the Text field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessageBase) SetText(text string) {
	u.Text = text
	u.require(userMessageBaseFieldText)
}

// SetUserMessageType sets the UserMessageType field and marks it as non-optional;
// this prevents an empty or null value for this field from being omitted during serialization.
func (u *UserMessageBase) SetUserMessageType(userMessageType UserConversationMessageType) {
	u.UserMessageType = userMessageType
	u.require(userMessageBaseFieldUserMessageType)
}

func (u *UserMessageBase) UnmarshalJSON(data []byte) error {
	type embed UserMessageBase
	var unmarshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed: embed(*u),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*u = UserMessageBase(unmarshaler.embed)
	u.CreatedAt = unmarshaler.CreatedAt.TimePtr()
	u.UpdatedAt = unmarshaler.UpdatedAt.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *u)
	if err != nil {
		return err
	}
	u.extraProperties = extraProperties
	u.rawJSON = json.RawMessage(data)
	return nil
}

func (u *UserMessageBase) MarshalJSON() ([]byte, error) {
	type embed UserMessageBase
	var marshaler = struct {
		embed
		CreatedAt *internal.DateTime `json:"createdAt,omitempty"`
		UpdatedAt *internal.DateTime `json:"updatedAt,omitempty"`
	}{
		embed:     embed(*u),
		CreatedAt: internal.NewOptionalDateTime(u.CreatedAt),
		UpdatedAt: internal.NewOptionalDateTime(u.UpdatedAt),
	}
	explicitMarshaler := internal.HandleExplicitFields(marshaler, u.explicitFields)
	return json.Marshal(explicitMarshaler)
}

func (u *UserMessageBase) String() string {
	if len(u.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(u.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

type UserMessageResponseState string

const (
	UserMessageResponseStateNotAsked    UserMessageResponseState = "NOT_ASKED"
	UserMessageResponseStateLlmEnabled  UserMessageResponseState = "LLM_ENABLED"
	UserMessageResponseStateLlmDisabled UserMessageResponseState = "LLM_DISABLED"
)

func NewUserMessageResponseStateFromString(s string) (UserMessageResponseState, error) {
	switch s {
	case "NOT_ASKED":
		return UserMessageResponseStateNotAsked, nil
	case "LLM_ENABLED":
		return UserMessageResponseStateLlmEnabled, nil
	case "LLM_DISABLED":
		return UserMessageResponseStateLlmDisabled, nil
	}
	var t UserMessageResponseState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (u UserMessageResponseState) Ptr() *UserMessageResponseState {
	return &u
}

type VisibilityType string

const (
	VisibilityTypeVisible          VisibilityType = "VISIBLE"
	VisibilityTypePartiallyVisible VisibilityType = "PARTIALLY_VISIBLE"
	VisibilityTypeHidden           VisibilityType = "HIDDEN"
)

func NewVisibilityTypeFromString(s string) (VisibilityType, error) {
	switch s {
	case "VISIBLE":
		return VisibilityTypeVisible, nil
	case "PARTIALLY_VISIBLE":
		return VisibilityTypePartiallyVisible, nil
	case "HIDDEN":
		return VisibilityTypeHidden, nil
	}
	var t VisibilityType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VisibilityType) Ptr() *VisibilityType {
	return &v
}
